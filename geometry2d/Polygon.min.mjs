'use strict';import{PI2,Vec2,Shape,Rect,Circle,Line}from"./geometry2d.mjs";let len=0,i=0,res=0,p0=Vec2.zero,p1=Vec2.zero;class Polygon extends Shape{constructor(center,relativePoints){super();this.center=center.clone();i=relativePoints.length;this.points=new Array(i);while(i--)this.points[i]=relativePoints[i].clone()}get perimeter(){i=this.points.length-1;res=Vec2.distance(this.points[0],this.points[i]);while(i)res+=Vec2.distance(this.points[i--],this.points[i]);return res}get area(){res=0;i=this.points.length;
p1=this.points[0];while(i--){p0=this.points[i];res+=(p0.x+p1.x)*(p0.y-p1.y);p1=p0}return res/2}copyCenter(){return this.center.clone()}setCenter(center){this.center.set(center);return this}setCenterXY(x,y){this.center.setXY(x,y);return this}moveXY(dX,dY){this.center.addXY(dX,dY);return this}move(delta){this.center.add(delta);return this}scale(factor){i=this.points.length;while(i--)this.points[i].mul(factor);return this}growDistance(delta){i=this.points.length;while(i--)this.points.magnitude+=delta;
return this}rotate(radians){const c=Math.cos(radians),s=Math.sin(radians);i=this.points.length;while(i--)this.points[i].transform(c,-s,s,c,0,0);return this}mirrorVertically(axisY=this.center.y){this.center.mirrorVertically(axisY);i=this.points.length;while(i--)this.points[i].mirrorVertically();return this}mirrorHorizontally(axisX=this.center.x){this.center.mirrorHorizontally(axisX);i=this.points.length;while(i--)this.points[i].mirrorHorizontally();return this}pushPath(context){len=this.points.length;
if(len){context.translate(this.center.x,this.center.y);context.moveTo(this.points[0].x,this.points[0].y);i=1;while(i<len)context.lineTo(this.points[i].x,this.points[i++].y);context.lineTo(this.points[0].x,this.points[0].y);context.translate(-this.center.x,-this.center.y)}}draw(context,fill=false,stroke=!fill){context.beginPath();len=this.points.length;if(len){context.translate(this.center.x,this.center.y);context.moveTo(this.points[0].x,this.points[0].y);i=1;while(i<len)context.lineTo(this.points[i].x,
this.points[i++].y);context.closePath();context.translate(-this.center.x,-this.center.y)}fill&&context.fill();stroke&&context.stroke()}get glPointsNumber(){return this.points.length}get glTriangles(){return this.points.length-2}ccw(){const n=this.points.length;let z=0,i,j;for(i=0,j=1;i<n;i++,j++){if(j==n)j=0;z+=(this.points[i].y+this.points[j].y)*(this.points[j].x-this.points[i].x)}return z<=0}invertPointsOrder(){let l=(this.points.length-1)/2,r=l>>0;l=r==l?l:r+1;while(r++,l--)[this.points[l],this.points[r]]=
[this.points[r],this.points[l]];return this}divideConvex(){let polygons=[];let points=this.points.slice(0);let n=points.length;if(n<4)return[ConvexPolygon.createCCW(this.center,points)];const ccw=this.ccw();let i=0;while(n>3){let prv=points[(i-1+n)%n],cur=points[i],nxt=points[(i+1)%n];while(i<n&&Vec2.ccw(prv,cur,nxt)==ccw){i++;prv=cur;cur=nxt;nxt=points[(i+1)%n]}if(i==n)break;let j=(i-3+n)%n;while(Vec2.ccw(prv,cur,points[j])==ccw&&Vec2.ccw(points[j],points[(j+1)%n],points[(j+2)%n])==ccw)j=(j-1+n)%
n;j++;let array=[points[j%n]];j=(j+1)%n;while(j!=i){array.push(points.splice(j,1)[0]);if(j<i)i--;n--;j=j%n}array.push(points[i]);polygons.push(ConvexPolygon.createCCW(this.center,array));if(n<4)break}polygons.push(ConvexPolygon.createCCW(this.center,points));return polygons}getVertices(verticesArray,vOffset,indicesArray,iOffset){const o=vOffset/2,n=this.points.length;let i=0;while(i<n){if(i>1){indicesArray[iOffset++]=o;indicesArray[iOffset++]=o+i-1;indicesArray[iOffset++]=o+i}verticesArray[vOffset++]=
this.points[i].x+this.center.x;verticesArray[vOffset++]=this.points[i++].y+this.center.y}}getPoint(index){return this.points[index].clone().add(this.center)}getPoints(){i=this.points.length;let arr=new Array(i);while(i--)arr[i]=this.points[i].clone().add(this.center);return arr}getLine(index){len=this.points.length;return(new Line(this.points[index++%len],this.points[index%len])).move(this.center)}getRelativeLine(index){len=this.points.length;return new Line(this.points[index++%len],this.points[index%
len])}getLines(){len=this.points.length;i=len;let arr=new Array(i);while(i--)arr[i]=(new Line(this.points[i],this.points[(i+1)%len])).move(this.center);return arr}getNormalVectForLine(index){return this.getLine(index).getNormalVect(false)}rotatePointsOrder(delta){if(delta%1)delta=Math.round(delta);len=this.points.length;i=len;let p=new Array(len);while(i--)p[i]=this.points[(i+delta)%len];i=len;while(i--)this.points[i]=p[i]}getReducedPolygon(distance){let n=this.points.length,points=new Array(len),
p,l1,l2,i;for(i=0;i<n;i++){p=this.points[i].clone();l1=i?this.getRelativeLine(i-1):this.getRelativeLine(n-1);l2=this.getRelativeLine(i);l1.move(l1.getNormalVect().mul(distance));l2.move(l2.getNormalVect().mul(distance));points[i]=Line.intersectionPoint(l1,l2)}return new Polygon(this.center,points)}intersect(shape){let lines=this.getLines(),i=lines.length;if(!i)return false;if(shape instanceof Polygon){let lines2=shape.getLines(),len=lines2.length,l,j;while(i--){l=lines[i];j=len;while(j--)if(lines2[j].intersect(l))return true}}else while(i--)if(lines[i].intersect(shape))return true;
return false}getIntersectionPoints(shape){let lines=this.getLines(),i=lines.length,res=[];if(!i)return[];if(shape instanceof Polygon){let lines2=shape.getLines(),len=lines2.length,l,j;while(i--){l=lines[i];j=len;while(j--)Array.prototype.push.apply(res,lines2[j].getIntersectionPoints(l))}}else while(i--)Array.prototype.push.apply(res,lines[i].getIntersectionPoints(shape));return res}getIntersectionLine(shape,startIndex=0){let lines=this.getLines(),i=lines.length;if(i<=startIndex)return null;if(shape instanceof
Polygon){let lines2=shape.getLines(),len=lines2.length,l,j;while(i-- >startIndex){l=lines[i];j=len;while(j--)if(lines2[j].intersect(l))return l}}else while(i-- >startIndex)if(lines[i].intersect(shape))return lines[i];return null}getIntersectionLines(shape,startIndex=0){let lines=this.getLines(),i=lines.length;let result=[];if(shape instanceof Polygon){let lines2=shape.getLines(),len=lines2.length,l,j;while(i-- >startIndex){l=lines[i];j=len;while(j--)if(lines2[j].intersect(l))result.push(l)}}else while(i-- >
startIndex)if(lines[i].intersect(shape))result.push(lines[i]);return result}contains(point){const n=this.points.length;const A=Vec2.zero,B=this.points[0].clone();point=point.clone().remove(this.center);let i,j;let nb=0;for(i=0;i<n;i++){A.set(B);B.set(this.points[(i+1)%n]);const cond1=A.x>=point.x,cond2=B.x>=point.x,cond3=B.y<point.y;const Z=(B.y-point.y)*(A.x-point.x)-(A.y-point.y)*(B.x-point.x);const c=cond1==cond2;if(c!=(A.y<point.y==cond3)){if(Z==0)return true;if(cond1&&cond2)nb++}else if(!c){if(Z==
0)return true;if(cond3==Z<0)nb++}}return nb%2===1}getRect(){let point,i=this.points.length-1;let xmin=this.points[i].x,ymin=this.points[i].y,xmax=xmin,ymax=ymin;while(i--){point=this.points[i];if(point.x<xmin)xmin=point.x;else if(point.x>xmax)xmax=point.x;if(point.y<ymin)ymin=point.y;else if(point.y>ymax)ymax=point.y}return(new Rect(xmin,ymin,xmax,ymax)).move(this.center)}getPercentPoint(p){let dist=this.perimeter*(p%1),lines=this.getLines(),len=lines.length,l,i;for(i=0;i<len;i++){l=lines[i].length;
if(l>dist)return lines[i].getPercentPoint(dist/l);else dist-=l}return this.points[i].add(this.center)}closestPointTo(p){let closest=null,d,D=Number.MAX_SAFE_INTEGER,l=this.getLines(),i=l.length,c;while(i--){c=l[i].closestPointTo(p);d=Vec2.squareDistance(c,p);if(d<D){closest=c;D=d}}return closest}supportPoint(direction){let bestProj=-Infinity,bestPoint,i=this.points.length;while(i--){const p=this.points[i],proj=Vec2.dotProd(p,direction);if(proj>bestProj){bestProj=proj;bestPoint=p}}return bestPoint.clone().add(this.center)}getRadius(){let r=
0,mag,i;for(i=this.points.length-1;i>=0;i--){mag=this.points[i].squareMagnitude;if(mag>r)r=mag}return Math.sqrt(r)}redefineCenter(delta=null){let i=this.points.length;if(!i)return;if(!delta){delta=Vec2.zero;const len=i;while(i--)delta.add(this.points[i]);delta.mul(1/len);i=len}while(i--)this.points[i].remove(delta);return this}clone(){return new Polygon(this.center,this.points)}static Absolute(pointsArray){const len=pointsArray.length;const c=Vec2.zero;let i=len;while(i--)c.add(pointsArray[i]);return(new Polygon(c.mul(1/
len),pointsArray)).redefineCenter(c)}static Rectangular(center,width,height){let left=-width*.5,top=-height*.5,right=left+width,bottom=top+height;return new Polygon(center,Vec2.createVec2Array([left,top,right,top,right,bottom,left,bottom]))}static Ellipsoidal(center,radiusX,radiusY,edges,radians=0){let dA=PI2/edges,a=PI2,points=new Array(edges),i=edges;while(i--){a-=dA;points[i]=Vec2(radiusX*Math.cos(a),radiusY*Math.sin(a))}return new ConvexPolygon(center,points)}static Regular(center,radiusArray,
pointsNumber,startRadians){let dR=PI2/pointsNumber,angle=startRadians,rLen=radiusArray.length,p=new Polygon(center,[]);p.points=new Array(pointsNumber);if(rLen!==undefined){let i=-1;while(++i<pointsNumber){p.points[i]=Vec2.createFromAngle(angle,radiusArray[i%rLen]);angle+=dR}}else{let i=pointsNumber;while(i--){p.points[i]=Vec2.createFromAngle(angle,radiusArray);angle-=dR}}return p}}class ConvexPolygon extends Polygon{constructor(center,relativePoints){super(center,relativePoints)}clone(){return new ConvexPolygon(this.center,
this.points)}intersect(shape){if(shape instanceof Circle){let i=this.points.length;while(i--){const norm=this.getNormalVectForLine(i);const support=shape.center.add(norm.clone().mul(shape.radius));const d=Vec2.dotProd(norm,support.remove(this.points[i]).remove(this.center));if(d>0)return false}return true}if(shape instanceof ConvexPolygon){let i=this.points.length;while(i--){const norm=this.getNormalVectForLine(i);const support=shape.supportPoint(norm.mirror());const d=-Vec2.dotProd(norm,support.remove(this.points[i]).remove(this.center));
if(d>0)return false}return true}else super.intersect(this)}static createCCW(center,points){const p=new ConvexPolygon(center,points);if(!p.ccw())p.invertPointsOrder();return p}}export default Polygon;export{Polygon,ConvexPolygon};
