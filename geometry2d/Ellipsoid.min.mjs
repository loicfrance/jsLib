'use strict';import{PI2,PI_2,Vec2,Shape,Rect,Polygon}from"./geometry2d.mjs";class Ellipsoid extends Shape{constructor(center,radiusX,radiusY,radians=0){super();this.center=center.clone();this.radiusX=radiusX;this.radiusY=radiusY;this.angle=radians}get squareFocusDistance(){return this.radiusX*this.radiusX-this.radiusY*this.radiusY}get focusDistance(){return Math.sqrt(this.squareFocusDistance)}get excentricity(){return this.focusDistance/this.radiusX}get perimeter(){return Math.PI*Math.sqrt(2*this.squareFocusDistance)}get area(){return this.radiusX*
this.radiusY*Math.PI}copyCenter(){return this.center.clone()}setCenter(center){this.center.set(center);return this}setCenterXY(x,y){this.center.setXY(x,y);return this}mirrorHorizontally(axisX=this.center.x){this.radians=-this.radians;this.center.mirrorHorizontally(axisX);return this}mirrorVertically(axisY=this.center.y){this.radians=-this.radians;this.center.mirrorVertically(axisY);return this}moveXY(dX,dY){this.center.addXY(dX,dY);return this}move(delta){this.center.add(delta);return this}scale(factor){this.radiusX*=
factor;this.radiusY*=factor;return this}growDistance(delta){this.radiusX+=delta;this.radiusY+=delta;return this}rotate(radians){this.radians+=radians;return this}setAngle(radians){this.radians=radians;return this}checkRadius(){if(this.radiusX<this.radiusY){[this.radiusX,this.radiusY]=[this.radiusY,this.radiusX];this.setAngle(this.radians+PI_2)}return this}relativePointForAngle(radians){let r=radians-this.radians;return(new Vec2(this.radiusX*Math.cos(r),this.radiusY*Math.sin(r))).rotate(this.radians)}pointForAngle(radians){return this.relativePointForAngle(radians).add(this.center)}squareRadiusForAngle(radians){return this.relativePointForAngle(radians).squareMagnitude}radiusForAngle(radians){return Math.sqrt(this.squareRadiusForAngle(radians))}pushPath(context){context.ellipse(this.center.x,
this.center.y,this.radiusX,this.radiusY,this.radians,0,PI2)}draw(context,fill=false,stroke=!fill){context.beginPath();context.ellipse(this.center.x,this.center.y,this.radiusX,this.radiusY,this.radians,0,PI2);fill&&context.fill();stroke&&context.stroke()}getVertices(verticesArray,vOffset,indicesArray,iOffset){const o=offset/2;let n=this.glPointsNumber-1,dA=PI2/n,a=0,i=-1;while(++i<n){float32Array[vOffset++]=(t=this.pointForAngle(a+=dA)).x;float32Array[vOffset++]=t.y;if(i>1){indicesArray[iOffset++]=
o;indicesArray[iOffset++]=o+i;indicesArray[iOffset++]=o+i-1}}}get glTriangles(){return this.glPointsNumber-1}contains(point){let p=point.clone().remove(this.center);return this.squareRadiusForAngle(p.angle)>p.squareMagnitude}getRect(){let h,w;if(this.radians){let a=this.radiusX,b=this.radiusY,alpha=this.radians,tanAlpha=Math.tan(alpha),sinAlpha=Math.sin(alpha),cosAlpha=Math.cos(alpha),b_a=b/a,t_xMax=Math.atan(-b_a*tanAlpha),t_yMax=Math.atan(b_a/tanAlpha);h=Math.abs(a*Math.cos(t_yMax)*sinAlpha+b*Math.sin(t_yMax)*
cosAlpha);w=Math.abs(a*Math.cos(t_xMax)*cosAlpha+b*Math.sin(t_xMax)*sinAlpha)}else{h=this.radiusY;w=this.radiusX}return new Rect(this.center.x-w,this.center.y-h,this.center.x+w,this.center.y+h)}getRadius(){return this.radiusX}getPercentPoint(percent){return this.pointForAngle(PI2*percent+this.radians)}closestPointTo(p){return this.pointForAngle(Vec2.translation(this.center,p).angle)}clone(){return new Ellipsoid(this.center,this.radiusX,this.radiusY,this.radians)}toPolygon(edges){return Polygon.createEllipsoid(this.center,
this.radiusX,this.radiusY,edges,this.radians)}}Ellipsoid.prototype.glPointsNumber=16;export default Ellipsoid;export{Ellipsoid};
