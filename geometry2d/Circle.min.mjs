'use strict';import{PI2,Vec2,Shape,Rect,Polygon}from"./geometry2d.mjs";class Circle extends Shape{constructor(center,radius){super();this.center=center.clone();this.radius=radius}get perimeter(){return PI2*this.radius}get area(){return Math.pow(this.radius,2)*Math.PI}copyCenter(){return this.center.clone()}setCenter(center){this.center.set(center);return this}setCenterXY(x,y){this.center.setXY(x,y);return this}mirrorVertically(axisY=this.center.y){this.center.mirrorVertically(axisY);return this}mirrorHorizontally(axisX=
this.center.x){this.center.mirrorHorizontally(axisX);return this}moveXY(dX,dY){this.center.addXY(dX,dY);return this}move(delta){this.center.add(delta);return this}scale(factor){this.radius*=factor;return this}growDistance(delta){this.radius+=delta;return this}relativePointForAngle(radians){return Vec2.createFromAngle(radians,this.radius)}pointForAngle(radians){return Vec2.createFromAngle(radians,this.radius).add(this.center)}pushPath(context){context.arc(this.center.x,this.center.y,this.radius,0,
PI2,false)}draw(context,fill=false,stroke=!fill){context.beginPath();context.arc(this.center.x,this.center.y,this.radius,0,PI2,false);fill&&context.fill();stroke&&context.stroke()}getVertices(verticesArray,vOffset,indicesArray,iOffset){const o=vOffset/2;let n=this.glPointsNumber,dA=PI2/n,a=-dA,i=-1,t;while(++i<n){verticesArray[vOffset++]=(t=Vec2.createFromAngle(a+=dA,this.radius)).x;verticesArray[vOffset++]=t.y;if(i>1){indicesArray[iOffset++]=o;indicesArray[iOffset++]=o+i-1;indicesArray[iOffset++]=
o+i}}}get glTriangles(){return this.glPointsNumber-2}intersect(shape){if(shape instanceof Rect)return shape.toPolygon().intersect(this);else if(shape instanceof Circle){let d=Vec2.distance(this.center,shape.center);return d<=this.radius+shape.radius&&this.radius<=d+shape.radius&&shape.radius<=d+this.radius}else return shape.intersect(this)}getIntersectionPoints(shape){if(shape instanceof Rect)return shape.toPolygon().getIntersectionPoints(this);else if(shape instanceof Circle){let trans=Vec2.translation(this.center,
shape.center),d2=trans.squareMagnitude,da=Math.acos(d2-shape.radius*shape.radius+this.radius*this.radius)/(2*Math.sqrt(d2)*this.radius),a=trans.angle;return[Vec2.createFromAngle(a+da,this.radius),Vec2.createFromAngle(a-da,this.radius)]}else return shape.getIntersectionPoints(this)}contains(point){return Vec2.distance(this.center,point)<=this.radius}getRect(){return Rect.createFromXY(this.center.x,this.center.y).addMargin(this.radius)}getPercentPoint(percent){return this.pointForAngle(percent*PI2)}closestPointTo(p){return Vec2.translation(this.center,
p).setMagnitude(this.radius)}getRadius(){return this.radius}getCircle(){return new Circle(this.center,this.radius)}clone(){return new Circle(this.center,this.radius)}toPolygon(edges,startRadians=0){return Polygon.Regular(this.center,[this.radius],edges,startRadians)}static CircumCircle(A,B,C){const AB=Vec2.translation(A,B),AC=Vec2.translation(A,C),E=AB.x*(A.x+B.x)+AB.y*(A.y+B.y),F=AC.x*(A.x+C.x)+AC.y*(A.y+C.y),G=2*(AB.x*(C.y-B.y)-AB.y*(C.x-B.x));if(Math.abs(G)<1E-6){const pos=new Vec2(Math.min(A.x,
B.x,C.x),Math.min(A.y,B.y,C.y)),dX=(Math.max(A.x,B.x,C.x)-pos.x)*.5,dY=(Math.max(A.y,B.y,C.y)-pos.y)*.5;return new Circle(pos.addXY(dX,dY),Math.sqrt(dX*dX+dY*dY))}else{const pos=new Vec2((AC.y*E-AB.y*F)/G,AB.x*-AC.x*EF/G),dX=pos.x-A.x,dY=pos.y-A.y;return new Circle(pos,Math.sqrt(dX*dX+dY*dY))}}}Circle.prototype.glPointsNumber=16;export default Circle;export{Circle};
