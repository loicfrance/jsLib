'use strict';class Vec2{constructor(x,y){this.x=x;this.y=y}get angle(){return Math.atan2(this.y,this.x)}set angle(a){const m=this.magnitude;if(m){this.x=Math.cos(a)*m;this.y=Math.sin(a)*m}}get squareMagnitude(){return this.x*this.x+this.y*this.y}get magnitude(){return Math.sqrt(this.x*this.x+this.y*this.y)}set magnitude(mag){let m=this.magnitude;if(m)this.mul(mag/m);else this.x=mag}clone(){return new Vec2(this.x,this.y)}setXY(x,y){this.x=x;this.y=y;return this}set(vec){this.x=vec.x;this.y=vec.y;return this}reset(){this.x=
this.y=0;return this}addXY(x,y){this.x+=x;this.y+=y;return this}add(vec){this.x+=vec.x;this.y+=vec.y;return this}remove(vec){this.x-=vec.x;this.y-=vec.y;return this}negate(){this.x=-this.x;this.y=-this.y;return this}mul(factor){this.x*=factor;this.y*=factor;return this}normalize(){this.mul(1/(this.magnitude||1));return this}setMagnitude(mag){this.magnitude=mag;return this}setAngle(a){this.angle=a;return this}rotate(a){this.angle+=a;return this}rotateAround(center,a){return this.set(Vec2.translation(center,
this).rotate(a).add(center))}toString(){return["(",this.x,",",this.y,")"].join("")}equalsXY(x,y){return this.x===x&&this.y===y}equals(vec){return this.x===vec.x&&this.y===vec.y}isZero(){return!(this.x||this.y)}getUnit(){return this.clone().normalize()}getMirror(center=Vec2.ZERO){return Vec2.translation(this,center).add(center)}getHorizontalMirror(axisX=0){return this.clone().mirrorHorizontally()}getVerticalMirror(axisY=0){return this.clone().mirrorVertically()}mirror(center=Vec2.ZERO){this.x=center.x?
2*center.x-this.x:-this.x;this.y=center.y?2*center.y-this.y:-this.y;return this}mirrorHorizontally(axisX=0){this.x=axisX?2*axisX-this.x:-this.x;return this}mirrorVertically(axisY=0){this.y=axisY?2*axisY-this.y:-this.y;return this}getRoundedX(digits=0){if(digits)return parseInt(this.x.toPrecision(digits));else return Math.round(this.x)}getRoundedY(digits=0){if(digits)return parseInt(this.y.toPrecision(digits));else return Math.round(this.y)}roundedVec(digits=0){return new Vec2(this.getRoundedX(digits),
this.getRoundedY(digits))}clampMagnitude(min,max){let m=this.magnitude;if(m)if(m<min)this.mul(min/m);else{if(m>max)this.mul(max/m)}else this.x=min;return this}transform(m11,m12,m21,m22,dX=0,dY=0){[this.x,this.y]=[m11*this.x+m12*this.y+dX,m21*this.x+m22*this.y+dY]}static dotProd(u,v){return u.x*v.x+u.y*v.y}static vectProd(u,v){return u.x*v.y-u.y*v.x}static translation(A,B){return new Vec2(B.x-A.x,B.y-A.y)}static squareDistance(A,B){let dX=B.x-A.x,dY=B.y-A.y;return dX*dX+dY*dY}static distance(A,B){return Math.sqrt(Vec2.squareDistance(A,
B))}static manhattanDistance(A,B){return Math.abs(B.x-A.x)+Math.abs(B.y-A.y)}static diagonalDistance(A,B){return Math.max(Math.abs(B.x-A.x),Math.abs(B.y-A.y))}static ccw(A,B,C){return(C.y-A.y)*(B.x-A.x)>(B.y-A.y)*(C.x-A.x)}static ccw2(AB,AC){return AC.y*AB.x>AB.y*AC.x}static createFromAngle(rad,mag=1){return new Vec2(Math.cos(rad)*mag,Math.sin(rad)*mag)}static createVec2Array(xyxyArray){const len=Math.floor(xyxyArray.length/2),result=new Array(len);let i=len,i2;while(i--){i2=2*i;result[i]=new Vec2(xyxyArray[i2],
xyxyArray[i2+1])}return result}static createFloatArray(vec2Array){const len=vec2Array.length,result=new Float32Array(len*2);let i=len,i2;while(i--){i2=i*2;result[i2]=vec2Array[i].x;result[i2+1]=vec2Array[i].y}return result}static get zero(){return new Vec2(0,0)}}Vec2.ZERO=Vec2.zero;export default Vec2;export{Vec2};
