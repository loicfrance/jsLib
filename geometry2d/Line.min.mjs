'use strict';import{PI_2,Vec2,Shape,Rect,Circle}from"./geometry2d.mjs";let A=Vec2.zero,B=Vec2.zero,C=Vec2.zero,D=Vec2.zero,AB=Vec2.zero,AC=Vec2.zero,AD=Vec2.zero,u=Vec2.zero,CD=Vec2.zero,d=0,BC=Vec2.zero,BD=Vec2.zero;class Line extends Shape{constructor(p0,p1){super();this.p0=p0.clone();this.p1=p1.clone()}get center(){return A.set(this.p0).add(this.p1).mul(.5)}set center(center){const d=Vec2.translation(this.center,center);this.p0.add(d);this.p1.add(d)}get length(){return Vec2.distance(this.p0,this.p1)}set length(l){const d=
this.vector.setMagnitude((l-this.length)/2);this.p1.add(d);this.p0.remove(d)}get angle(){return Math.atan2(this.p1.y-this.p0.y,this.p1.x,this.p0.x)}set angle(radians){const u=this.vector.mul(.5).setAngle(radians);const c=this.center;this.p0.set(c).remove(u);this.p1.set(c).add(u)}get vector(){return Vec2.translation(this.p0,this.p1)}get directorVect(){return Vec2.translation(this.p0,this.p1).normalize()}get perimeter(){return 2*Vec2.distance(this.p0,this.p1)}setAngle(radians){this.angle=radians;return this}setLength(length){this.length=
length;return this}setP0(p){this.p0.set(p);return this}setP1(p){this.p1.set(p);return this}setPoints(p0,p1){this.p0.set(p0);this.p1.set(p1);return this}setCenter(center){this.center.set(center);return this}setCenterXY(x,y){const c=this.center;const dX=x-c.x,dY=y-c.y;this.p0.addXY(dX,dY);this.p1.addXY(dX,dY);return this}copyCenter(){return this.center}moveXY(dX,dY){this.p0.addXY(dX,dY);this.p1.addXY(dX,dY);return this}move(delta){this.p0.add(delta);this.p1.add(delta);return this}scale(factor){const u=
this.p1.clone().remove(this.p0).mul(.5*factor);this.p1.add(u);this.p0.remove(u);return this}growDistance(delta){const l=this.length;return this.scale((l+delta)/l)}rotate(radians){this.angle+=radians;return this}mirrorVertically(axisY=(this.p0.y+this.p1.y)/2){this.p0.mirrorVertically(axisY);this.p1.mirrorVertically(axisY);return this}mirrorHorizontally(axisX=(this.p0.x+this.p1.x)/2){this.p0.mirrorHorizontally(axisX);this.p1.mirrorHorizontally(axisX);return this}pushPath(context){context.moveTo(this.p0.x,
this.p0.y);context.lineTo(this.p1.x,this.p1.y)}draw(context,fill=false,stroke=!fill){context.beginPath();context.moveTo(this.p0.x,this.p0.y);context.lineTo(this.p1.x,this.p1.y);fill&&context.fill();stroke&&context.stroke()}getVertices(verticesArray,vOffset,indicesArray,iOffset){const o=offset/2,A=this.p0,B=this.p1;verticesArray[vOffset++]=A.x;verticesArray[vOffset++]=A.y;verticesArray[vOffset++]=B.x;verticesArray[vOffset++]=B.y;indicesArray[iOffset++]=o;indicesArray[iOffset++]=o+1;indicesArray[iOffset++]=
o}intersect(shape){if(shape instanceof Rect)return shape.toPolygon().intersect(this);else if(shape instanceof Circle){if(shape.contains(this.p0)!=shape.contains(this.p1))return true;const l=this.length;AC.set(shape.center).remove(this.p0);u.set(this.p1).remove(this.p0).mul(1/this.length);d=Vec2.dotProd(u,AC);return d>=0&&d<=l&&Vec2.squareDistance(u.mul(d).add(this.p0),shape.center)<=shape.radius*shape.radius}else if(shape instanceof Line)if(Vec2.ccw2(AC.set(shape.p0).remove(this.p0),AD.set(shape.p1).remove(this.p0))!==
Vec2.ccw(this.p1,shape.p0,shape.p1)){AB.set(this.p1).remove(this.p0);return Vec2.ccw2(AB,AC)!==Vec2.ccw2(AB,AD)}else return false;else return shape.intersect(this)}getIntersectionPoints(shape){if(shape instanceof Rect)return shape.toPolygon().getIntersectionPoints(this);else if(shape instanceof Circle){A=this.p0.clone();C=shape.center;u.set(this.p1).remove(A).normalize();let a=u.x*u.x+u.y*u.y,b=2*(u.x*(A.x-C.x)+u.y*(A.y-C.y)),c=A.x*(A.x-2*C.x)+C.x*C.x+A.y*(A.y-2*C.y)+C.y*C.y-radius*radius;d=b*b-4*
a*c;if(d==0){d=-b/(2*a);if(d>=0)return A.add(u.mul(d))}else if(d>0){d=Math.sqrt(d);a*=2;let l1=(-b-d)/a,l2=(-b+d)/a;if(l1>=0)if(l2>=0)return[B.set(u).mul(l1).add(A),A.add(u.mul(l2))];else return[A.add(u.mul(l1))];else if(l2>=0)return[A.add(u.mul(l2))]}else return[]}else if(shape instanceof Line){let p=Line.intersectionPoint(this,shape);if(p.onLine1&&p.onLine2)return[p.point];else return[]}else return shape.getIntersectionPoints(this)}contains(point){return point.equals(this.p0)||point.equals(this.p1)||
Vec2.distance(this.p0,point)+Vec2.distance(this.p1,point)==Vec2.distance(this.p0,this.p1)}closestPointTo(p){A=this.p0;u=this.directorVect;AC.set(p).remove(A);d=Vec2.dotProd(u,AC);return d<0?u.set(A):d<this.length?u.mul(d).add(A):u.set(this.p1)}distanceToPoint(point){return Vec2.distance(this.closestPointTo(point),point)}getNormalVect(left=true){let d=this.directorVect;[d.x,d.y]=left?[d.y,-d.x]:[-d.y,d.x];return d}getRect(){A=this.p0;B=this.p1;let left,top,right,bottom;if(A.x<B.x){left=A.x;right=B.x}else{left=
B.x;right=A.x}if(A.y<B.y){top=A.y;bottom=B.y}else{top=B.y;bottom=A.y}return new Rect(left,top,right,bottom)}geRadius(){return Vec2.distance(this.p0,this.p1)*.5}clone(){return new Line(this.p0,this.p1)}static intersectionPoint(line1,line2){A=line1.p0;C=line2.p0;AB.set(line1.p1).remove(A);CD.set(line2.p1).remove(C);d=CD.y*AB.x-CD.x*AB.y;if(!d)return null;let CA=Vec2.translation(C,A),pos1=(CD.x*CA.y-CD.y*CA.x)/d,pos2=(AB.x*CA.y-AB.y*CA.x)/d;return{point:AB.mul(pos1).add(A),onLine1:pos1>0&&pos1<1,onLine2:pos2>
0&&pos2<1}}static createFromPointVector(A,AB){return new Line(A,A.clone().add(AB))}}Line.prototype.glPointsNumber=2;Line.prototype.glPointsNumber=1;export default Line;export{Line};
