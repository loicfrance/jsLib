'use strict';import{Vec2,Shape,Circle,Polygon}from"./geometry2d.mjs";class Rect extends Shape{constructor(xMin,yMin,xMax,yMax){super();this.xMin=xMin;this.yMin=yMin;this.xMax=xMax;this.yMax=yMax}get width(){return this.xMax-this.xMin}get height(){return this.yMax-this.yMin}get ratio(){return this.width/this.height}get perimeter(){return(this.width+this.height)*2}get area(){return this.width*this.height}get center(){return(new Vec2(this.xMin+this.xMax,this.yMin+this.yMax)).mul(.5)}set center(center){this.setCenterXY(center.x,
center.y);return center}clone(){return new Rect(this.xMin,this.yMin,this.xMax,this.yMax)}copyCenter(){return this.center}setCenter(center){return this.setCenterXY(center.x,center.y)}setCenterXY(x,y){let w=this.width/2,h=this.height/2;this.xMin=x-w;this.xMax=x+w;this.yMin=y-h;this.yMax=y+h;return this}scale(scaleX,scaleY=scaleX){let dw=this.width*(scaleX-1)*.5,dh=this.height*(scaleY-1)*.5;this.xMin-=dw;this.xMax+=dw;this.yMin-=dh;this.yMax+=dh;return this}growDistance(delta){let toCorner=(new Vec2((this.xMax-
this.xMin)/2,(this.yMax-this.yMin)/2)).setMagnitude(delta);this.xMin-=toCorner.x;this.xMax+=toCorner.x;this.yMin-=toCorner.y;this.yMax+=toCorner.y}intersect(shape){return shape instanceof Rect?this.overlap(rect)&&!this.containsRect(rect):shape.intersect(this)}getIntersectionPoints(shape){if(shape instanceof Rect){let array=[];let intersection=Rect.getIntersection([this,shape]);let xSelf=intersection.xMin==this.xMin;const ySelf1=intersection.yMin==shape.yMin,ySelf2=intersection.yMax==shape.yMax;if(xSelf==
ySelf1)array.push(new Vec2(intersection.xMin,intersection.yMin));if(xSelf==ySelf2)array.push(new Vec2(intersection.xMin,intersection.yMax));xSelf=intersection.xMax==this.xMax;if(xSelf==ySelf1)array.push(new Vec2(intersection.xMax,intersection.yMin));if(xSelf==ySelf2)array.push(new Vec2(intersection.xMax,intersection.yMax));return array}else return shape.getIntersectionPoints(this)}overlap(rect){return rect.xMin<=this.xMax&&rect.yMin<=this.yMax&&rect.xMax>=this.xMin&&rect.yMax>=this.yMin}containsXY(x,
y){return x>=this.xMin&&x<=this.xMax&&y>=this.yMin&&y<=this.yMax}containsRect(rect){return rect.xMin>=this.xMin&&rect.xMax<=this.xMax&&rect.yMin>=this.yMin&&rect.yMax<=this.yMax}contains(p){return p.x>=this.xMin&&p.x<=this.xMax&&p.y>=this.yMin&&p.y<=this.yMax}onLeftOfX(x){return this.xMax<x}onLeftOfRect(r){return this.xMax<r.xMin}onLeftOf(p){return this.xMax<p.x}onRightOfX(x){return this.xMin>x}onRightOfRect(r){return this.xMin>r.xMax}onRightOf(p){return this.xMin>p.x}aboveY(y){return this.yMax<y}aboveRect(r){return this.yMax<
r.yMin}above(p){return this.yMax<p.y}belowY(y){return this.yMin>y}belowRect(r){return this.yMin>r.yMax}below(p){return this.yMin>p.y}addMargin(margin){this.xMin-=margin;this.xMax+=margin;this.yMin-=margin;this.yMax+=margin;return this}addMarginsXY(marginX,marginY){this.xMin-=marginX;this.xMax+=marginX;this.yMin-=marginY;this.yMax+=marginY;return this}addMargins(marginLeft,marginTop,marginRight,marginBottom){this.xMin-=marginLeft;this.xMax+=marginRight;this.yMin-=marginTop;this.yMax+=marginBottom;
return this}pushPath(context){context.rect(this.xMin,this.yMin,this.width,this.height)}draw(context,fill=false,stroke=!fill){context.beginPath();context.rect(this.xMin,this.yMin,this.width,this.height);fill&&context.fill();stroke&&context.stroke()}getVertices(verticesArray,vOffset,indicesArray,iOffset){const n=offset/2;float32Array[offset++]=this.xMin;float32Array[offset++]=this.yMin;float32Array[offset++]=this.xMin;float32Array[offset++]=this.yMax;float32Array[offset++]=this.xMax;float32Array[offset++]=
this.yMin;float32Array[offset++]=this.xMax;float32Array[offset++]=this.yMax;indicesArray[iOffset++]=n;indicesArray[iOffset++]=n+1;indicesArray[iOffset++]=n+2;indicesArray[iOffset++]=n+2;indicesArray[iOffset++]=n+1;indicesArray[iOffset++]=n+3}setRect(rect){this.xMin=rect.xMin;this.xMax=rect.xMax;this.yMin=rect.yMin;this.yMax=rect.yMax;return this}set(left,top,right,bottom){this.yMin=top;this.xMin=left;this.xMax=right;this.yMax=bottom;return this}moveXY(x,y){this.xMin+=x;this.xMax+=x;this.yMin+=y;this.yMax+=
y;return this}move(delta){this.xMin+=delta.x;this.xMax+=delta.x;this.yMin+=delta.y;this.yMax+=delta.y;return this}getPercentPoint(percent){if((percent%=1)<.25)return new Vec2(this.xMin+percent*4*this.width,this.yMin);if(percent<.5)return new Vec2(this.xMax,this.yMin+(percent*4-1)*this.height);if(percent<.75)return new Vec2(this.xMax-(percent*4-2)*this.width,this.yMax);return new Vec2(this.xMin,this.yMax-(percent*4-3)*this.height)}closestPointTo(point){const p=new Vec2(point.x<this.xMin?this.xMin:
point.x>this.xMax?this.xMax:point.x,point.y>this.yMax?this.yMax:point.y<this.yMin?this.yMin:point.y);if(p.x>this.xMin&&p.x<this.xMax&&p.y>this.yMin&&p.y<this.yMax){const dx=p.x-this.xMin<this.xMax-p.x?this.xMin-p.x:this.xMax-p.x;const dy=p.y-this.yMin<this.yMax-p.y?this.yMin-p.y:this.yMax-p.y;if(Math.abs(dx)<Math.abs(dy))p.addXY(dx,0);else p.addXY(0,dy)}return p}toPolygon(){return Polygon.Absolute(Vec2.createVec2Array([this.xMin,this.yMin,this.xMax,this.yMin,this.xMax,this.yMax,this.xMin,this.yMax]))}getShape(){const error=
new Error("Rect.getShape() is deprecated. use Rect.toPolygon() instead. The result is the same.");console.error(error.message+"\n"+error.stack);return this.toPolygon()}getRect(){return this.clone()}getRadius(){return Math.sqrt(Math.pow(this.xMax-this.xMin,2)+Math.pow(this.yMax-this.yMin,2))/2}getCircle(){let dX=(this.xMax-this.xMin)/2,dY=(this.yMax-this.yMin)/2;return new Circle(new Vec2(this.xMin+dX,this.yMin+dY),Math.sqrt(dX*dX+dY*dY))}mirrorVertically(axisY=(this.yMax+this.yMin)/2){const yMax=
this.yMin+(axisY-this.yMin);this.yMin=this.yMax+(axisY-this.yMax);this.yMax=yMax;return this}mirrorHorizontally(axisX=(this.xMax+this.xMin)/2){const xMax=this.xMin+(axisx-this.xMin);this.xMin=this.xMax+(axisX-this.xMax);this.xMax=xMax;return this}toString(){return["[",this.xMin,", ",this.yMin,", ",this.xMax,", ",this.yMax,"]"].join("")}static getUnion(rects){let i=rects.length;if(i){let res=rects[--i].clone();while(i--){res.xMin=Math.min(res.xMin,rects[i].xMin);res.xMax=Math.max(res.xMax,rects[i].xMax);
res.yMin=Math.min(res.yMin,rects[i].yMin);res.yMax=Math.max(res.yMax,rects[i].yMax)}return res}else return null}static getIntersection(rects){let i=rects.length;if(i){let r=rects[0],maxLeft=r.xMin,maxTop=r.yMin,minRight=r.xMax,minBottom=r.yMax;while(--i){r=rects[i];if(r.yMin>maxTop)maxTop=r.yMin;if(r.xMin>maxLeft)maxLeft=r.xMin;if(r.xMax<minRight)minRight=r.xMax;if(r.yMax<minBottom)minBottom=r.yMax}if(maxLeft<=minRight&&maxTop<=minBottom)return new Rect(maxLeft,maxTop,minRight,minBottom)}return null}static createFromPoint(p){return new Rect(p.x,
p.y,p.x,p.y)}static createFromXY(x,y){return new Rect(x,y,x,y)}static createFromPoints(array){let i=array.length;if(i){let minX=array[0].x,maxX=minX,minY=array[0].y,maxY=minY,p;while(--i){p=array[i];if(p.x<minX)minX=p.x;else if(p.x>maxX)maxX=p.x;if(p.y<minY)minY=p.y;else if(p.y>maxY)maxY=p.y}return new Rect(minX,minY,maxX,maxY)}}static createFromCenterWidthHeight(center,width,height=width){return Rect.createFromPoint(center).addMarginsXY(width/2,height/2)}}Rect.prototype.glPointsNumber=4;Rect.prototype.glTriangles=
2;export default Rect;export{Rect};
