'use strict';{class Vec2{constructor(x,y){this.x=x;this.y=y}get angle(){return Math.atan2(this.y,this.x)}set angle(a){const m=this.magnitude;if(m){this.x=Math.cos(a)*m;this.y=Math.sin(a)*m}}get squareMagnitude(){return this.x*this.x+this.y*this.y}get magnitude(){return Math.sqrt(this.x*this.x+this.y*this.y)}set magnitude(mag){let m=this.magnitude;if(m)this.mul(mag/m);else this.x=mag}clone(){return new Vec2(this.x,this.y)}setXY(x,y){this.x=x;this.y=y;return this}set(vec){this.x=vec.x;this.y=vec.y;
return this}reset(){this.x=this.y=0;return this}addXY(x,y){this.x+=x;this.y+=y;return this}add(vec){this.x+=vec.x;this.y+=vec.y;return this}remove(vec){this.x-=vec.x;this.y-=vec.y;return this}mul(factor){this.x*=factor;this.y*=factor;return this}normalize(){this.mul(1/(this.magnitude||1));return this}setMagnitude(mag){this.magnitude=mag;return this}setAngle(a){this.angle=a;return this}rotate(a){this.angle+=a;return this}rotateAround(center,a){return this.set(Vec2.translation(center,this).rotate(a).add(center))}toString(){return["(",
this.x,",",this.y,")"].join("")}equalsXY(x,y){return this.x===x&&this.y===y}equals(vec){return this.x===vec.x&&this.y===vec.y}isZero(){return!(this.x||this.y)}getUnit(){return this.clone().normalize()}getMirror(center=Vec2.ZERO){return Vec2.translation(this,center).add(center)}getHorizontalMirror(axisX=0){return this.clone().mirrorHorizontally()}getVerticalMirror(axisY=0){return this.clone().mirrorVertically()}mirror(center=Vec2.ZERO){this.x=center.x?2*center.x-this.x:-this.x;this.y=center.y?2*center.y-
this.y:-this.y;return this}mirrorHorizontally(axisX=0){this.x=axisX?2*axisX-this.x:-this.x;return this}mirrorVertically(axisY=0){this.y=axisY?2*axisY-this.y:-this.y;return this}getRoundedX(digits=0){if(digits)return parseInt(this.x.toPrecision(digits));else return Math.round(this.x)}getRoundedY(digits=0){if(digits)return parseInt(this.y.toPrecision(digits));else return Math.round(this.y)}roundedVec(digits=0){return new Vec2(this.getRoundedX(digits),this.getRoundedY(digits))}clampMagnitude(min,max){let m=
this.magnitude;if(m)if(m<min)this.mul(min/m);else{if(m>max)this.mul(max/m)}else this.x=min;return this}static dotProd(u,v){return u.x*v.x+u.y*v.y}static vectProd(u,v){return u.x*v.y-u.y*v.x}static translation(A,B){return new Vec2(B.x-A.x,B.y-A.y)}static squareDistance(A,B){let dX=B.x-A.x,dY=B.y-A.y;return dX*dX+dY*dY}static distance(A,B){return Math.sqrt(Vec2.squareDistance(A,B))}static manhattanDistance(A,B){return Math.abs(B.x-A.x)+Math.abs(B.y-A.y)}static diagonalDistance(A,B){return Math.max(Math.abs(B.x-
A.x),Math.abs(B.y-A.y))}static ccw(A,B,C){return(C.y-A.y)*(B.x-A.x)>(B.y-A.y)*(C.x-A.x)}static ccw2(AB,AC){return AC.y*AB.x>AB.y*AC.x}static createFromAngle(rad,mag=1){return new Vec2(Math.cos(rad)*mag,Math.sin(rad)*mag)}static createVec2Array(xyxyArray){const len=Math.floor(xyxyArray.length/2),result=new Array(len);let i=len,i2;while(i--){i2=2*i;result[i]=new Vec2(xyxyArray[i2],xyxyArray[i2+1])}return result}static createFloatArray(vec2Array){const len=vec2Array.length,result=new Float32Array(len*
2);let i=len,i2;while(i--){i2=i*2;result[i2]=vec2Array[i].x;result[i2+1]=vec2Array[i].y}return result}static get zero(){return new Vec2(0,0)}}Vec2.ZERO=Vec2.zero;class Rect{constructor(xMin,yMin,xMax,yMax){this.xMin=xMin;this.yMin=yMin;this.xMax=xMax;this.yMax=yMax}get width(){return this.xMax-this.xMin}get height(){return this.yMax-this.yMin}get ratio(){return this.width/this.height}get perimeter(){return(this.width+this.height)*2}get area(){return this.width*this.height}get center(){return(new Vec2(this.xMin+
this.xMax,this.yMin+this.yMax)).mul(.5)}set center(center){this.setCenterXY(center.x,center.y);return center}clone(){return new Rect(this.xMin,this.yMin,this.xMax,this.yMax)}setCenter(center){return this.setCenterXY(center.x,center.y)}setCenterXY(x,y){let w=this.width/2,h=this.height/2;this.xMin=x-w;this.xMax=x+w;this.yMin=y-h;this.yMax=y+h;return this}scale(scaleX,scaleY=scaleX){let dw=this.width*(scaleX-1)*.5,dh=this.height*(scaleY-1)*.5;this.xMin-=dw;this.xMax+=dw;this.yMin-=dh;this.yMax+=dh;return this}overlap(rect){return rect.xMin<=
this.xMax&&rect.yMin<=this.yMax&&rect.xMax>=this.xMin&&rect.yMax>=this.yMin}containsXY(x,y){return x>=this.xMin&&x<=this.xMax&&y>=this.yMin&&y<=this.yMax}containsRect(rect){return rect.xMin>=this.xMin&&rect.xMax<=this.xMax&&rect.yMin>=this.yMin&&rect.yMax<=this.yMax}contains(p){return p.x>=this.xMin&&p.x<=this.xMax&&p.y>=this.yMin&&p.y<=this.yMax}onLeftOfX(x){return this.xMax<x}onLeftOfRect(r){return this.xMax<r.xMin}onLeftOf(p){return this.xMax<p.x}onRightOfX(x){return this.xMin>x}onRightOfRect(r){return this.xMin>
r.xMax}onRightOf(p){return this.xMin>p.x}aboveY(y){return this.yMax<y}aboveRect(r){return this.yMax<r.yMin}above(p){return this.yMax<p.y}belowY(y){return this.yMin>y}belowRect(r){return this.yMin>r.yMax}below(p){return this.yMin>p.y}addMargin(margin){this.xMin-=margin;this.xMax+=margin;this.yMin-=margin;this.yMax+=margin;return this}addMarginsXY(marginX,marginY){this.xMin-=marginX;this.xMax+=marginX;this.yMin-=marginY;this.yMax+=marginY;return this}addMargins(marginLeft,marginTop,marginRight,marginBottom){this.xMin-=
marginLeft;this.xMax+=marginRight;this.yMin-=marginTop;this.yMax+=marginBottom;return this}pushPath(context){context.rect(this.xMin,this.yMin,this.width,this.height)}draw(context,fill=false,stroke=!fill){context.beginPath();context.rect(this.xMin,this.yMin,this.width,this.height);fill&&context.fill();stroke&&context.stroke()}getVertices(verticesArray,vOffset,indicesArray,iOffset){const n=offset/2;float32Array[offset++]=this.xMin;float32Array[offset++]=this.yMin;float32Array[offset++]=this.xMin;float32Array[offset++]=
this.yMax;float32Array[offset++]=this.xMax;float32Array[offset++]=this.yMin;float32Array[offset++]=this.xMax;float32Array[offset++]=this.yMax;indicesArray[iOffset++]=n;indicesArray[iOffset++]=n+1;indicesArray[iOffset++]=n+2;indicesArray[iOffset++]=n+2;indicesArray[iOffset++]=n+1;indicesArray[iOffset++]=n+3}setRect(rect){this.xMin=rect.xMin;this.xMax=rect.xMax;this.yMin=rect.yMin;this.yMax=rect.yMax;return this}set(left,top,right,bottom){this.yMin=top;this.xMin=left;this.xMax=right;this.yMax=bottom;
return this}moveXY(x,y){this.xMin+=x;this.xMax+=x;this.yMin+=y;this.yMax+=y;return this}move(delta){this.xMin+=delta.x;this.xMax+=delta.x;this.yMin+=delta.y;this.yMax+=delta.y;return this}getPercentPoint(percent){if((percent%=1)<.25)return new Vec2(this.xMin+percent*4*this.width,this.yMin);if(percent<.5)return new Vec2(this.xMax,this.yMin+(percent*4-1)*this.height);if(percent<.75)return new Vec2(this.xMax-(percent*4-2)*this.width,this.yMax);return new Vec2(this.xMin,this.yMax-(percent*4-3)*this.height)}getShape(){return Polygon.Absolute(Vec2.createVec2Array([this.xMin,
this.yMin,this.xMax,this.yMin,this.xMax,this.yMax,this.xMin,this.yMax]))}toString(){return["[",this.xMin,", ",this.yMin,", ",this.xMax,", ",this.yMax,"]"].join("")}static getUnion(rects){let i=rects.length;if(i){let res=rects[--i].clone();while(i--){res.xMin=Math.min(res.xMin,rects[i].xMin);res.xMax=Math.max(res.xMax,rects[i].xMax);res.yMin=Math.min(res.yMin,rects[i].yMin);res.yMax=Math.max(res.yMax,rects[i].yMax)}return res}else return null}static getIntersection(rects){let i=rects.length;if(i){let r=
rects[0],maxLeft=r.xMin,maxTop=r.yMin,minRight=r.xMax,minBottom=r.yMax;while(--i){r=rects[i];if(r.yMin>maxTop)maxTop=r.yMin;if(r.xMin>maxLeft)maxLeft=r.xMin;if(r.xMax<minRight)minRight=r.xMax;if(r.yMax<minBottom)minBottom=r.yMax}if(maxLeft<=minRight&&maxTop<=minBottom)return new Rect(maxLeft,maxTop,minRight,minBottom)}return null}static createFromPoint(p){return new Rect(p.x,p.y,p.x,p.y)}static createFromXY(x,y){return new Rect(x,y,x,y)}static createFromPoints(array){let i=array.length;if(i){let minX=
array[0].x,maxX=minX,minY=array[0].y,maxY=minY,p;while(--i){p=array[i];if(p.x<minX)minX=p.x;else if(p.x>maxX)maxX=p.x;if(p.y<minY)minY=p.y;else if(p.y>maxY)maxY=p.y}return new Rect(minX,minY,maxX,maxY)}}static createFromCenterWidthHeight(center,width,height=width){return Rect.createFromPoint(center).addMarginsXY(width/2,height/2)}}Rect.prototype.glPointsNumber=4;Rect.prototype.glTriangles=2;class Shape{constructor(center){if(center)this.center=center.clone()}get perimeter(){return 0}get area(){return 0}copyCenter(){return this.center.clone()}setCenter(center){this.center.set(center);
return this}setCenterXY(x,y){this.center.setXY(x,y);return this}scale(factor){return this}growDistance(delta){return this}rotate(radians){return this}pushPath(context){}getVertices(verticesArray,vOffset,indicesArray,iOffset){}draw(context,fill=false,stroke=!fill){context.beginPath();this.pushPath(context);fill&&context.fill();stroke&&context.stroke()}intersect(shape){return false}getIntersectionPoints(shape){return[]}contains(point){return false}getRect(){return Rect.createFromPoint(this.center)}getRadius(){return 0}getCircle(){return new Circle(this.center,
this.getRadius())}getPercentPoint(percent){return this.center}closestPointTo(p){return this.center}clone(){return new Shape(this.center)}mirrorVertically(axisY=this.center.y){this.center.mirrorVertically(axisY);return this}mirrorHorizontally(axisX=this.center.x){this.center.mirrorHorizontally(axisX);return this}moveXY(dX,dY){this.center.addXY(dX,dY);return this}move(delta){this.center.add(delta);return this}}Shape.prototype.glPointsNumber=0;Shape.prototype.glTriangles=0;class Circle extends Shape{constructor(center,
radius){super(center);this.radius=radius}get perimeter(){return Circle.PI2*this.radius}get area(){return Math.pow(this.radius,2)*Math.PI}scale(factor){this.radius*=factor;return this}growDistance(delta){this.radius+=delta;return this}relativePointForAngle(radians){return Vec2.createFromAngle(radians,this.radius)}pointForAngle(radians){return Vec2.createFromAngle(radians,this.radius).add(this.center)}pushPath(context){context.arc(this.center.x,this.center.y,this.radius,0,Circle.PI2,false)}draw(context,
fill=false,stroke=!fill){context.beginPath();context.arc(this.center.x,this.center.y,this.radius,0,Circle.PI2,false);fill&&context.fill();stroke&&context.stroke()}getVertices(verticesArray,vOffset,indicesArray,iOffset){const o=vOffset/2;let n=this.glPointsNumber,dA=Circle.PI2/n,a=-dA,i=-1,t;while(++i<n){verticesArray[vOffset++]=(t=Vec2.createFromAngle(a+=dA,this.radius)).x;verticesArray[vOffset++]=t.y;if(i>1){indicesArray[iOffset++]=o;indicesArray[iOffset++]=o+i-1;indicesArray[iOffset++]=o+i}}}get glTriangles(){return this.glPointsNumber-
2}intersect(shape){if(shape instanceof Circle){let d=Vec2.distance(this.center,shape.center);return d<this.radius+shape.radius&&this.radius<d+shape.radius&&shape.radius<d+this.radius}else return shape.intersect(this)}getIntersectionPoints(shape){if(shape instanceof Circle){let trans=Vec2.translation(this.center,shape.center),d2=trans.squareMagnitude,da=Math.acos(d2-shape.radius*shape.radius+this.radius*this.radius)/(2*Math.sqrt(d2)*this.radius),a=trans.angle;return[Vec2.createFromAngle(a+da,this.radius),
Vec2.createFromAngle(a-da,this.radius)]}else return shape.getIntersectionPoints(this)}contains(point){return Vec2.distance(this.center,point)<=this.radius}getRect(){return Rect.createFromXY(this.center.x,this.center.y).addMargin(this.radius)}getPercentPoint(percent){return this.pointForAngle(percent*Circle.PI2)}closestPointTo(p){return Vec2.translation(this.center,p).setMagnitude(this.radius)}getRadius(){return this.radius}getCircle(){return new Circle(this.center,this.radius)}clone(){return new Circle(this.center,
this.radius)}toPolygon(edges,startRadians=0){return Polygon.Regular(this.center,[this.radius],edges,startRadians)}}Circle.prototype.glPointsNumber=16;Circle.PI2=2*Math.PI;Circle.PI_2=2*Math.PI;class Ellipsoid extends Shape{constructor(center,radiusX,radiusY,radians=0){super(center);this.radiusX=radiusX;this.radiusY=radiusY;this.angle=radians}get squareFocusDistance(){return this.radiusX*this.radiusX-this.radiusY*this.radiusY}get focusDistance(){return Math.sqrt(this.squareFocusDistance)}get excentricity(){return this.focusDistance/
this.radiusX}get perimeter(){return Math.PI*Math.sqrt(2*this.squareFocusDistance)}get area(){return this.radiusX*this.radiusY*Math.PI}mirrorHorizontally(axisX=this.center.x){this.radians=-this.radians;return super.mirrorHorizontally(axisX)}mirrorVertically(axisY=this.center.y){this.radians=-this.radians;return super.mirrorVertically(axisY)}scale(factor){this.radiusX*=factor;this.radiusY*=factor;return this}growDistance(delta){this.radiusX+=delta;this.radiusY+=delta;return this}rotate(radians){this.radians+=
radians;return this}setAngle(radians){this.radians=radians;return this}checkRadius(){if(this.radiusX<this.radiusY){[this.radiusX,this.radiusY]=[this.radiusY,this.radiusX];this.setAngle(this.radians+Circle.PI_2)}return this}relativePointForAngle(radians){let r=radians-this.radians;return(new Vec2(this.radiusX*Math.cos(r),this.radiusY*Math.sin(r))).rotate(this.radians)}pointForAngle(radians){return this.relativePointForAngle(radians).add(this.center)}squareRadiusForAngle(radians){return this.relativePointForAngle(radians).squareMagnitude}radiusForAngle(radians){return Math.sqrt(this.squareRadiusForAngle(radians))}pushPath(context){context.ellipse(this.center.x,
this.center.y,this.radiusX,this.radiusY,this.radians,0,Circle.PI2)}draw(context,fill=false,stroke=!fill){context.beginPath();context.ellipse(this.center.x,this.center.y,this.radiusX,this.radiusY,this.radians,0,Circle.PI2);fill&&context.fill();stroke&&context.stroke()}getVertices(verticesArray,vOffset,indicesArray,iOffset){const o=offset/2;let n=this.glPointsNumber-1,dA=Circle.PI2/n,a=0,i=-1;while(++i<n){float32Array[vOffset++]=(t=this.pointForAngle(a+=dA)).x;float32Array[vOffset++]=t.y;if(i>1){indicesArray[iOffset++]=
o;indicesArray[iOffset++]=o+i;indicesArray[iOffset++]=o+i-1}}}get glTriangles(){return this.glPointsNumber-1}contains(point){let p=point.clone().remove(this.center);return this.squareRadiusForAngle(p.angle)>p.squareMagnitude}getRect(){let h,w;if(this.radians){let a=this.radiusX,b=this.radiusY,alpha=this.radians,tanAlpha=Math.tan(alpha),sinAlpha=Math.sin(alpha),cosAlpha=Math.cos(alpha),b_a=b/a,t_xMax=Math.atan(-b_a*tanAlpha),t_yMax=Math.atan(b_a/tanAlpha);h=Math.abs(a*Math.cos(t_yMax)*sinAlpha+b*Math.sin(t_yMax)*
cosAlpha);w=Math.abs(a*Math.cos(t_xMax)*cosAlpha+b*Math.sin(t_xMax)*sinAlpha)}else{h=this.radiusY;w=this.radiusX}return new Rect(this.center.x-w,this.center.y-h,this.center.x+w,this.center.y+h)}getRadius(){return this.radiusX}getPercentPoint(percent){return this.pointForAngle(Circle.PI2*percent+this.radians)}closestPointTo(p){return this.pointForAngle(Vec2.translation(this.center,p).angle)}clone(){return new Ellipsoid(this.center,this.radiusX,this.radiusY,this.radians)}createPolygon(edges){return Polygon.createEllipsoid(this.center,
this.radiusX,this.radiusY,edges,this.radians)}}Ellipsoid.prototype.glPointsNumber=16;let A=Vec2.zero,B=Vec2.zero,C=Vec2.zero,D=Vec2.zero,AB=Vec2.zero,AC=Vec2.zero,AD=Vec2.zero,u=Vec2.zero,CD=Vec2.zero,d=0,BC=Vec2.zero,BD=Vec2.zero;class Line extends Shape{constructor(p0,p1){super(undefined);this.p0=p0.clone();this.p1=p1.clone()}get center(){return A.set(this.p0).add(this.p1).mul(.5)}set center(center){const d=Vec2.translation(this.center,center);this.p0.add(d);this.p1.add(d)}get length(){return Vec2.distance(this.p0,
this.p1)}set length(l){const d=this.vector.setMagnitude((l-this.length)/2);this.p1.add(d);this.p0.remove(d)}get angle(){return Math.atan2(this.p1.y-this.p0.y,this.p1.x,this.p0.x)}set angle(radians){const u=this.vector.mul(.5).setAngle(radians);const c=this.center;this.p0.set(c).remove(u);this.p1.set(c).add(u)}get vector(){return Vec2.translation(this.p0,this.p1)}get directorVect(){return Vec2.translation(this.p0,this.p1).normalize()}get perimeter(){return 2*Vec2.distance(this.p0,this.p1)}setAngle(radians){this.angle=
radians;return this}setLength(length){this.length=length;return this}setP0(p){this.p0.set(p);return this}setP1(p){this.p1.set(p);return this}setPoints(p0,p1){this.p0.set(p0);this.p1.set(p1);return this}setCenter(center){this.center=center;return this}setCenterXY(x,y){const c=this.center;const dX=x-c.x,dY=y-c.y;this.p0.addXY(dX,dY);this.p1.addXY(dX,dY);return this}moveXY(dX,dY){this.p0.addXY(dX,dY);this.p1.addXY(dX,dY);return this}move(delta){this.p0.add(delta);this.p1.add(delta);return this}scale(factor){const u=
this.p1.clone().remove(this.p0).mul(.5*factor);this.p1.add(u);this.p0.remove(u);return this}growDistance(delta){const l=this.length;return this.scale((l+delta)/l)}rotate(radians){this.angle+=radians;return this}mirrorVertically(axisY=(this.p0.y+this.p1.y)/2){this.p0.mirrorVertically(axisY);this.p1.mirrorVertically(axisY);return this}mirrorHorizontally(axisX=(this.p0.x+this.p1.x)/2){this.p0.mirrorHorizontally(axisX);this.p1.mirrorHorizontally(axisX);return this}pushPath(context){context.moveTo(this.p0.x,
this.p0.y);context.lineTo(this.p1.x,this.p1.y)}draw(context,fill=false,stroke=!fill){context.beginPath();context.moveTo(this.p0.x,this.p0.y);context.lineTo(this.p1.x,this.p1.y);fill&&context.fill();stroke&&context.stroke()}getVertices(verticesArray,vOffset,indicesArray,iOffset){const o=offset/2,A=this.p0,B=this.p1;verticesArray[vOffset++]=A.x;verticesArray[vOffset++]=A.y;verticesArray[vOffset++]=B.x;verticesArray[vOffset++]=B.y;indicesArray[iOffset++]=o;indicesArray[iOffset++]=o+1;indicesArray[iOffset++]=
o}intersect(shape){if(shape instanceof Circle){if(shape.contains(this.p0)!=shape.contains(this.p1))return true;const l=this.length;AC.set(shape.center).remove(this.p0);u.set(this.p1).remove(this.p0).mul(1/length);d=Vec2.dotProd(u,AC);return d>=0&&d<=l&&Vec2.squareDistance(u.mul(d).add(this.p0),shape.center)<=shape.radius*shape.radius}else if(shape instanceof Line)if(Vec2.ccw2(AC.set(shape.p0).remove(this.p0),AD.set(shape.p1).remove(this.p0))!==Vec2.ccw(this.p1,shape.p0,shape.p1)){AB.set(this.p1).remove(this.p0);
return Vec2.ccw2(AB,AC)!==Vec2.ccw2(AB,AD)}else return false;else return shape.intersect(this)}getIntersectionPoints(shape){if(shape instanceof Circle){A=this.p0.clone();C=shape.center;u.set(this.p1).remove(A).normalize();let a=u.x*u.x+u.y*u.y,b=2*(u.x*(A.x-C.x)+u.y*(A.y-C.y)),c=A.x*(A.x-2*C.x)+C.x*C.x+A.y*(A.y-2*C.y)+C.y*C.y-radius*radius;d=b*b-4*a*c;if(d==0){d=-b/(2*a);if(d>=0)return A.add(u.mul(d))}else if(d>0){d=Math.sqrt(d);a*=2;let l1=(-b-d)/a,l2=(-b+d)/a;if(l1>=0)if(l2>=0)return[B.set(u).mul(l1).add(A),
A.add(u.mul(l2))];else return[A.add(u.mul(l1))];else if(l2>=0)return[A.add(u.mul(l2))]}else return[]}else if(shape instanceof Line){let p=Line.intersectionPoint(this,shape);if(p.onLine1&&p.onLine2)return[p.point];else return[]}else return shape.getIntersectionPoints(this)}contains(point){return point.equals(this.p0)||point.equals(this.p1)||Vec2.distance(this.p0,point)+Vec2.distance(this.p1,point)==Vec2.distance(this.p0,this.p1)}closestPointTo(p){A=this.p0;u=this.directorVect;AC.set(p).remove(A);d=
Vec2.dotProd(u,AC);return d<0?u.set(A):d<this.length?u.mul(d).add(A):u.set(this.p1)}distanceToPoint(point){return Vec2.distance(this.closestPointTo(point),point)}getNormalVect(left=true){return this.directorVect.rotate(left?-Circle.PI_2:Circle.PI_2)}getRect(){A=this.p0;B=this.p1;let left,top,right,bottom;if(A.x<B.x){left=A.x;right=B.x}else{left=B.x;right=A.x}if(A.y<B.y){top=A.y;bottom=B.y}else{top=B.y;bottom=A.y}return new Rect(left,top,right,bottom)}geRadius(){return Vec2.distance(this.p0,this.p1)*
.5}clone(){return new Line(this.p0,this.p1)}static intersectionPoint(line1,line2){A=line1.p0;C=line2.p0;AB.set(line1.p1).remove(A);CD.set(line2.p1).remove(C);d=CD.y*AB.x-CD.x*AB.y;if(!d)return null;let CA=Vec2.translation(C,A),pos1=(CD.x*CA.y-CD.y*CA.x)/d,pos2=(AB.x*CA.y-AB.y*CA.x)/d;return{point:AB.mul(pos1).add(A),onLine1:pos1>0&&pos1<1,onLine2:pos2>0&&pos2<1}}static createFromPointVector(A,AB){return new Line(A,A.clone().add(AB))}}Line.prototype.glPointsNumber=2;Line.prototype.glPointsNumber=1;
class Point extends Shape{constructor(p){super(p)}pushPath(context){context.rect(this.center.x-.5,this.center.y-.5,1,1)}draw(context,fill=true,stroke=!fill){context.fillRect(this.center.x-1,this.center.y-1,2,2)}getVertices(verticesArray,vOffset,indicesArray,iOffset){const o=offset/2;verticesArray[vOffset++]=this.center.x;verticesArray[vOffset++]=this.center.y;indicesArray[iOffset++]=o;indicesArray[iOffset++]=o;indicesArray[iOffset++]=o}clone(){return new Point(this.center)}}Point.prototype.glPointsNumber=
1;Point.prototype.glPointsNumber=1;let len=0,i=0,res=0,p0=Vec2.zero,p1=Vec2.zero;class Polygon extends Shape{constructor(center,relativePoints){super(center);i=relativePoints.length;this.points=new Array(i);while(i--)this.points[i]=relativePoints[i].clone()}get perimeter(){i=this.points.length-1;res=Vec2.distance(this.points[0],this.points[i]);while(i)res+=Vec2.distance(this.points[i--],this.points[i]);return res}get area(){res=0;i=this.points.length;p1=this.points[0];while(i--){p0=this.points[i];
res+=(p0.x+p1.x)*(p0.y-p1.y);p1=p0}return res/2}scale(factor){i=this.points.length;while(i--)this.points[i].mul(factor);return this}growDistance(delta){i=this.points.length;while(i--)this.points.magnitude+=delta;return this}rotate(radians){i=this.points.length;while(i--)this.points[i].angle+=radians;return this}mirrorVertically(axisY=this.center.y){super.mirrorVertically(axisY);i=this.points.length;while(i--)this.points[i].mirrorVertically();return this}mirrorHorizontally(axisX){super.mirrorHorizontally(axisX);
i=this.points.length;while(i--)this.points[i].mirrorHorizontally();return this}pushPath(context){len=this.points.length;if(len){context.translate(this.center.x,this.center.y);context.moveTo(this.points[0].x,this.points[0].y);i=1;while(i<len)context.lineTo(this.points[i].x,this.points[i++].y);context.lineTo(this.points[0].x,this.points[0].y);context.translate(-this.center.x,-this.center.y)}}draw(context,fill=false,stroke=!fill){context.beginPath();len=this.points.length;if(len){context.translate(this.center.x,
this.center.y);context.moveTo(this.points[0].x,this.points[0].y);i=1;while(i<len)context.lineTo(this.points[i].x,this.points[i++].y);context.closePath();context.translate(-this.center.x,-this.center.y)}fill&&context.fill();stroke&&context.stroke()}get glPointsNumber(){return this.points.length}get glTriangles(){return this.points.length-2}ccw(){const n=this.points.length;let z=0,i,j;for(i=0,j=1;i<n;i++,j++){if(j==n)j=0;z+=(this.points[i].y+this.points[j].y)*(this.points[j].x-this.points[i].x)}return z<=
0}divideConvex(){let polygons=[];let points=this.points.slice(0);let n=points.length;if(n<4)return[new Polygon(this.center,points)];const ccw=this.ccw();let i=0;while(n>3){let prv=points[(i-1+n)%n],cur=points[i],nxt=points[(i+1)%n];while(i<n&&Vec2.ccw(prv,cur,nxt)==ccw){i++;prv=cur;cur=nxt;nxt=points[(i+1)%n]}if(i==n)break;let j=(i-3+n)%n;while(Vec2.ccw(prv,cur,points[j])==ccw&&Vec2.ccw(points[j],points[(j+1)%n],points[(j+2)%n])==ccw)j=(j-1+n)%n;j++;let array=[points[j%n]];j=(j+1)%n;while(j!=i){array.push(points.splice(j,
1)[0]);if(j<i)i--;n--;j=j%n}array.push(points[i]);polygons.push(new Polygon(this.center,array));if(n<4)break}polygons.push(new Polygon(this.center,points));return polygons}getVertices(verticesArray,vOffset,indicesArray,iOffset){const o=vOffset/2,n=this.points.length;let i=0;while(i<n){if(i>1){indicesArray[iOffset++]=o;indicesArray[iOffset++]=o+i-1;indicesArray[iOffset++]=o+i}verticesArray[vOffset++]=this.points[i].x+this.center.x;verticesArray[vOffset++]=this.points[i++].y+this.center.y}}getPoint(index){return this.points[index].clone().add(this.center)}getPoints(){i=
this.points.length;let arr=new Array(i);while(i--)arr[i]=this.points[i].clone().add(this.center);return arr}getLine(index){len=this.points.length;return(new Line(this.points[index++%len],this.points[index%len])).move(this.center)}getRelativeLine(index){len=this.points.length;return new Line(this.points[index++%len],this.points[index%len])}getLines(){len=this.points.length;i=len;let arr=new Array(i);while(i--)arr[i]=(new Line(this.points[i],this.points[(i+1)%len])).move(this.center);return arr}getNormalVectForLine(index){return this.getLine(index).getNormalVect(false)}rotatePointsOrder(delta){if(delta%
1)delta=Math.round(delta);len=this.points.length;i=len;let p=new Array(len);while(i--)p[i]=this.points[(i+delta)%len];i=len;while(i--)this.points[i]=p[i]}getReducedPolygon(distance){let n=this.points.length,points=new Array(len),p,l1,l2,i;for(i=0;i<n;i++){p=this.points[i].clone();l1=i?this.getRelativeLine(i-1):this.getRelativeLine(n-1);l2=this.getRelativeLine(i);l1.move(l1.getNormalVect().mul(distance));l2.move(l2.getNormalVect().mul(distance));points[i]=Line.intersectionPoint(l1,l2)}return new Polygon(this.center,
points)}intersect(shape){let lines=this.getLines(),i=lines.length;if(!i)return false;if(shape instanceof Polygon){let lines2=shape.getLines(),len=lines2.length,l,j;while(i--){l=lines[i];j=len;while(j--)if(lines2[j].intersect(l))return true}}else while(i--)if(lines[i].intersect(shape))return true;return false}getIntersectionPoints(shape){let lines=this.getLines(),i=lines.length,res=[];if(!i)return[];if(shape instanceof Polygon){let lines2=shape.getLines(),len=lines2.length,l,j;while(i--){l=lines[i];
j=len;while(j--)Array.prototype.push.apply(res,lines2[j].getIntersectionPoints(l))}}else while(i--)Array.prototype.push.apply(res,lines[i].getIntersectionPoints(shape));return res}getIntersectionLine(shape,startIndex=0){let lines=this.getLines(),i=lines.length;if(i<=startIndex)return null;if(shape instanceof Polygon){let lines2=shape.getLines(),len=lines2.length,l,j;while(i-- >startIndex){l=lines[i];j=len;while(j--)if(lines2[j].intersect(l))return l}}else while(i-- >startIndex)if(lines[i].intersect(shape))return lines[i];
return null}getIntersectionLines(shape,startIndex=0){let lines=this.getLines(),i=lines.length;let result=[];if(shape instanceof Polygon){let lines2=shape.getLines(),len=lines2.length,l,j;while(i-- >startIndex){l=lines[i];j=len;while(j--)if(lines2[j].intersect(l))result.push(l)}}else while(i-- >startIndex)if(lines[i].intersect(shape))result.push(lines[i]);return result}contains(point){const n=this.points.length;const A=Vec2.zero,B=this.points[0].clone();point=point.clone().remove(this.center);let i,
j;let nb=0;for(i=0;i<n;i++){A.set(B);B.set(this.points[(i+1)%n]);if(A.y>point.y&&B.y>point.y||A.y<point.y&&B.y<point.y||A.x<point.x&&B.x<point.x||A.y==point.y&&B.y<point.y||A.y<point.y&&B.y==point.y||A.y==B.y||A.x>point.x&&B.x<point.x&&Vec2.ccw(point,B,A)||A.x<point.x&&B.x>point.x&&Vec2.ccw(point,A,B))continue;nb++}return nb%2===1}getRect(){let point,i=this.points.length-1;let xmin=this.points[i].x,ymin=this.points[i].y,xmax=xmin,ymax=ymin;while(i--){point=this.points[i];if(point.x<xmin)xmin=point.x;
else if(point.x>xmax)xmax=point.x;if(point.y<ymin)ymin=point.y;else if(point.y>ymax)ymax=point.y}return(new Rect(xmin,ymin,xmax,ymax)).move(this.center)}getPercentPoint(p){let dist=this.perimeter*(p%1),lines=this.getLines(),len=lines.length,l,i;for(i=0;i<len;i++){l=lines[i].length;if(l>dist)return lines[i].getPercentPoint(dist/l);else dist-=l}return this.points[i].add(this.center)}closestPointTo(p){let closest=null,d,D=Number.MAX_SAFE_INTEGER,l=this.getLines(),i=l.length,c;while(i--){c=l[i].closestPointTo(p);
d=Vec2.squareDistance(c,p);if(d<D){closest=c;D=d}}return closest}getRadius(){let r=0,mag,i;for(i=this.points.length-1;i>=0;i--){mag=this.points[i].squareMagnitude;if(mag>r)r=mag}return Math.sqrt(r)}redefineCenter(delta=null){let i=this.points.length;if(!i)return;if(!delta){delta=Vec2.zero;let len=i;while(i--)delta.add(this.points[i]);delta.mul(1/len);i=len}while(i--)this.points[i].remove(delta);return this}clone(){return new Polygon(this.center,this.points)}static Absolute(pointsArray){return(new Polygon(Vec2.ZERO,
pointsArray)).redefineCenter()}static Rectangular(center,width,height){let left=-width*.5,top=-height*.5,right=left+width,bottom=top+height;return new Polygon(center,Vec2.createVec2Array([left,top,right,top,right,bottom,left,bottom]))}static Ellipsoidal(center,radiusX,radiusY,edges,radians=0){let dA=Circle.PI2/edges,a=Circle.PI2,points=new Array(edges),i=edges;while(i--){a-=dA;points[i]=Vec2(radiusX*Math.cos(a),radiusY*Math.sin(a))}return new Polygon(center,points)}static Regular(center,radiusArray,
pointsNumber,startRadians){let dR=Circle.PI2/pointsNumber,angle=startRadians,rLen=radiusArray.length,p=new Polygon(center,[]);p.points=new Array(pointsNumber);if(rLen!==undefined){let i=-1;while(++i<pointsNumber){p.points[i]=Vec2.createFromAngle(angle,radiusArray[i%rLen]);angle+=dR}}else{let i=pointsNumber;while(i--){p.points[i]=Vec2.createFromAngle(angle,radiusArray);angle-=dR}}return p}}class Ray extends Shape{constructor(origin,radians){super(origin);this.angle=radians}get perimeter(){return Infinity}rotate(radians){this.angle+=
radians;return this}mirrorVertically(axisY=this.center.y){super.mirrorVertically(axisY);this.angle=-this.angle;return this}mirrorHorizontally(axisX=this.center.x){super.mirrorHorizontally(axisX);this.angle=Math.PI-this.angle;return this}endPoint(length){return this.center.clone().addXY(Math.cos(this.angle)*length,Math.sin(this.angle)*length)}getLine(length){return Line.createFromPointVector(this.center,Vec2.createFromAngle(this.angle,length))}pushPath(context){const p=this.endPoint(context.canvas.clientWidth+
context.canvas.clientHeight);context.moveTo(this.center.x,this.center.y);context.moveTo(this.center.x,this.center.y);context.lineTo(p.x,p.y)}getVertices(verticesArray,vOffset,indicesArray,iOffset){const o=offset/2,t=this.endPoint(Number.MAX_SAFE_INTEGER);verticesArray[vOffset++]=this.center.x;verticesArray[vOffset++]=this.center.y;verticesArray[vOffset++]=t.x;verticesArray[vOffset++]=t.y;indicesArray[iOffset++]=o;indicesArray[iOffset++]=o+1;indicesArray[iOffset++]=o}intersect(shape){const rect=shape.getRect();
return(new Line(this.center,this.endPoint(Vec2.distance(this.center,shape.center)+rect.width+rect.height))).intersect(shape)}getIntersectionPoints(shape){const rect=shape.getRect();return this.getLine(Vec2.distance(this.center,shape.center)+rect.width+rect.height).getIntersectionPoints(shape)}contains(point){return this.endPoint(Vec2.distance(this.center,point)).equals(point)}getRect(){const endPoint=this.endPoint(Infinity);return new Rect(Math.min(endPoint.x,this.center.x),Math.min(endPoint.y,this.center.y),
Math.max(endPoint.x,this.center.x),Math.max(endPoint.y,this.center.y))}get directorVect(){return Vec2.createFromAngle(this.angle)}closestpointTo(p){let A=this.center,AC=Vec2.translation(A,p),u=this.directorVect,d=Vec2.dotProd(u,AC);return d<0?u.set(A):u.mul(d).add(A)}getRadius(){return Infinity}clone(){return new Ray(this.center,this.angle)}}Ray.prototype.glPointsNumber=2;Ray.prototype.glTrinagles=1;let asm={};let wasmCode=new Uint8Array([0,97,115,109,1,0,0,0,1,189,128,128,128,0,7,96,1,125,1,125,
96,6,125,125,125,125,125,125,1,127,96,4,125,125,125,125,1,127,96,2,125,125,1,125,96,4,125,125,125,125,1,125,96,7,125,125,125,125,125,125,125,1,127,96,8,125,125,125,125,125,125,125,125,1,125,3,142,128,128,128,0,13,1,2,3,3,4,4,4,4,4,4,1,5,6,4,132,128,128,128,0,1,112,0,0,5,131,128,128,128,0,1,0,1,6,129,128,128,128,0,0,7,225,129,128,128,0,14,6,109,101,109,111,114,121,2,0,3,99,99,119,0,0,4,99,99,119,50,0,1,15,115,113,117,97,114,101,77,97,103,110,105,116,117,100,101,0,2,9,109,97,103,110,105,116,117,100,
101,0,3,10,100,111,116,80,114,111,100,117,99,116,0,4,13,118,101,99,116,111,114,80,114,111,100,117,99,116,0,5,23,115,113,117,97,114,101,69,117,99,108,105,100,101,97,110,68,105,115,116,97,110,99,101,0,6,17,101,117,99,108,105,100,101,97,110,68,105,115,116,97,110,99,101,0,7,17,109,97,110,104,97,116,116,97,110,68,105,115,116,97,110,99,101,0,8,16,100,105,97,103,111,110,97,108,68,105,115,116,97,110,99,101,0,9,16,99,105,114,99,108,101,115,73,110,116,101,114,115,101,99,116,0,10,19,99,105,114,99,108,101,76,
105,110,101,73,110,116,101,114,115,101,99,116,0,11,14,108,105,110,101,115,73,110,116,101,114,115,101,99,116,0,12,10,236,132,128,128,0,13,153,128,128,128,0,0,32,2,32,0,147,32,5,32,1,147,148,32,3,32,1,147,32,4,32,0,147,148,94,11,141,128,128,128,0,0,32,0,32,3,148,32,1,32,2,148,94,11,141,128,128,128,0,0,32,0,32,0,148,32,1,32,1,148,146,11,142,128,128,128,0,0,32,0,32,0,148,32,1,32,1,148,146,145,11,141,128,128,128,0,0,32,0,32,2,148,32,1,32,3,148,146,11,141,128,128,128,0,0,32,0,32,3,148,32,1,32,2,148,147,
11,151,128,128,128,0,0,32,2,32,0,147,34,2,32,2,148,32,3,32,1,147,34,2,32,2,148,146,11,152,128,128,128,0,0,32,2,32,0,147,34,2,32,2,148,32,3,32,1,147,34,2,32,2,148,146,145,11,158,128,128,128,0,1,1,127,32,2,32,0,147,32,3,32,1,147,146,168,34,4,32,4,65,31,117,34,4,106,32,4,115,178,11,182,128,128,128,0,1,1,127,32,2,32,0,147,168,34,4,32,4,65,31,117,34,4,106,32,4,115,178,34,2,32,3,32,1,147,168,34,4,32,4,65,31,117,34,4,106,32,4,115,178,34,0,32,2,32,0,94,27,11,178,128,128,128,0,0,32,3,32,0,147,34,3,32,3,148,
32,4,32,1,147,34,3,32,3,148,146,145,34,3,32,2,146,32,5,94,32,3,32,2,32,5,146,93,32,3,32,5,146,32,2,94,113,113,11,173,129,128,128,0,2,3,125,1,127,65,1,33,10,2,64,32,0,32,3,147,34,7,32,7,148,32,1,32,4,147,34,8,32,8,148,146,145,32,2,93,32,0,32,5,147,34,9,32,9,148,32,1,32,6,147,34,9,32,9,148,146,145,32,2,93,115,13,0,65,0,33,10,32,7,32,5,32,3,147,34,5,32,5,32,5,148,32,6,32,4,147,34,5,32,5,148,146,145,34,6,149,34,9,148,32,8,32,5,32,6,149,34,7,148,146,34,5,67,0,0,0,0,93,13,0,32,5,32,6,94,13,0,32,0,32,9,
32,5,148,32,3,146,147,34,0,32,0,148,32,1,32,7,32,5,148,32,4,146,147,34,0,32,0,148,146,32,2,32,2,148,95,33,10,11,32,10,11,237,128,128,128,0,1,4,125,67,0,0,0,0,33,11,2,64,32,4,32,0,147,34,4,32,7,32,1,147,34,10,148,32,5,32,1,147,34,8,32,6,32,0,147,34,9,148,94,32,5,32,2,147,32,7,32,3,147,148,32,5,32,3,147,32,6,32,2,147,148,94,70,13,0,32,2,32,0,147,34,5,32,8,148,32,3,32,1,147,34,1,32,4,148,94,32,5,32,10,148,32,1,32,9,148,94,115,179,33,11,11,32,11,11]);if(WebAssembly)WebAssembly.instantiate(wasmCode,{}).then((wasm)=>
{asm=wasm.instance.exports});if(window){window.utils=window.utils||{};utils.geometry2d={Vec2,Rect,Shape,Circle,Ellipsoid,Line,Point,Polygon,Ray}}else;};
