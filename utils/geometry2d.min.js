'use strict';{class Vec2{constructor(x,y){this.x=x;this.y=y}get angle(){return Math.atan2(this.y,this.x)}set angle(a){const m=this.magnitude;if(m){this.x=Math.cos(a)*m;this.y=Math.sin(a)*m}}get squareMagnitude(){return this.x*this.x+this.y*this.y}get magnitude(){return Math.sqrt(this.x*this.x+this.y*this.y)}set magnitude(mag){let m=this.magnitude;if(m)this.mul(mag/m);else this.x=mag}clone(){return new Vec2(this.x,this.y)}setXY(x,y){this.x=x;this.y=y;return this}set(vec){this.x=vec.x;this.y=vec.y;
return this}reset(){this.x=this.y=0;return this}addXY(x,y){this.x+=x;this.y+=y;return this}add(vec){this.x+=vec.x;this.y+=vec.y;return this}remove(vec){this.x-=vec.x;this.y-=vec.y;return this}negate(){this.x=-this.x;this.y=-this.y;return this}mul(factor){this.x*=factor;this.y*=factor;return this}normalize(){this.mul(1/(this.magnitude||1));return this}setMagnitude(mag){this.magnitude=mag;return this}setAngle(a){this.angle=a;return this}rotate(a){this.angle+=a;return this}rotateAround(center,a){return this.set(Vec2.translation(center,
this).rotate(a).add(center))}toString(){return["(",this.x,",",this.y,")"].join("")}equalsXY(x,y){return this.x===x&&this.y===y}equals(vec){return this.x===vec.x&&this.y===vec.y}isZero(){return!(this.x||this.y)}getUnit(){return this.clone().normalize()}getMirror(center=Vec2.ZERO){return Vec2.translation(this,center).add(center)}getHorizontalMirror(axisX=0){return this.clone().mirrorHorizontally()}getVerticalMirror(axisY=0){return this.clone().mirrorVertically()}mirror(center=Vec2.ZERO){this.x=center.x?
2*center.x-this.x:-this.x;this.y=center.y?2*center.y-this.y:-this.y;return this}mirrorHorizontally(axisX=0){this.x=axisX?2*axisX-this.x:-this.x;return this}mirrorVertically(axisY=0){this.y=axisY?2*axisY-this.y:-this.y;return this}getRoundedX(digits=0){if(digits)return parseInt(this.x.toPrecision(digits));else return Math.round(this.x)}getRoundedY(digits=0){if(digits)return parseInt(this.y.toPrecision(digits));else return Math.round(this.y)}roundedVec(digits=0){return new Vec2(this.getRoundedX(digits),
this.getRoundedY(digits))}clampMagnitude(min,max){let m=this.magnitude;if(m)if(m<min)this.mul(min/m);else{if(m>max)this.mul(max/m)}else this.x=min;return this}static dotProd(u,v){return u.x*v.x+u.y*v.y}static vectProd(u,v){return u.x*v.y-u.y*v.x}static translation(A,B){return new Vec2(B.x-A.x,B.y-A.y)}static squareDistance(A,B){let dX=B.x-A.x,dY=B.y-A.y;return dX*dX+dY*dY}static distance(A,B){return Math.sqrt(Vec2.squareDistance(A,B))}static manhattanDistance(A,B){return Math.abs(B.x-A.x)+Math.abs(B.y-
A.y)}static diagonalDistance(A,B){return Math.max(Math.abs(B.x-A.x),Math.abs(B.y-A.y))}static ccw(A,B,C){return(C.y-A.y)*(B.x-A.x)>(B.y-A.y)*(C.x-A.x)}static ccw2(AB,AC){return AC.y*AB.x>AB.y*AC.x}static createFromAngle(rad,mag=1){return new Vec2(Math.cos(rad)*mag,Math.sin(rad)*mag)}static createVec2Array(xyxyArray){const len=Math.floor(xyxyArray.length/2),result=new Array(len);let i=len,i2;while(i--){i2=2*i;result[i]=new Vec2(xyxyArray[i2],xyxyArray[i2+1])}return result}static createFloatArray(vec2Array){const len=
vec2Array.length,result=new Float32Array(len*2);let i=len,i2;while(i--){i2=i*2;result[i2]=vec2Array[i].x;result[i2+1]=vec2Array[i].y}return result}static get zero(){return new Vec2(0,0)}}Vec2.ZERO=Vec2.zero;class Shape{constructor(){}get perimeter(){return 0}get area(){return 0}copyCenter(){return this.center.clone()}setCenter(center){this.center.set(center);return this}setCenterXY(x,y){this.center.setXY(x,y);return this}scale(factor){return this}growDistance(delta){return this}rotate(radians){return this}pushPath(context){}getVertices(verticesArray,
vOffset,indicesArray,iOffset){}draw(context,fill=false,stroke=!fill){context.beginPath();this.pushPath(context);fill&&context.fill();stroke&&context.stroke()}intersect(shape){return false}getIntersectionPoints(shape){return[]}contains(point){return false}getRect(){return Rect.createFromPoint(this.center)}getRadius(){return 0}getCircle(){return new Circle(this.center,this.getRadius())}getPercentPoint(percent){return this.center}closestPointTo(p){return this.center}clone(){return new Shape}mirrorVertically(axisY=
this.center.y){this.center.mirrorVertically(axisY);return this}mirrorHorizontally(axisX=this.center.x){this.center.mirrorHorizontally(axisX);return this}moveXY(dX,dY){this.center.addXY(dX,dY);return this}move(delta){this.center.add(delta);return this}}Shape.prototype.glPointsNumber=0;Shape.prototype.glTriangles=0;class Rect extends Shape{constructor(xMin,yMin,xMax,yMax){super();this.xMin=xMin;this.yMin=yMin;this.xMax=xMax;this.yMax=yMax}get width(){return this.xMax-this.xMin}get height(){return this.yMax-
this.yMin}get ratio(){return this.width/this.height}get perimeter(){return(this.width+this.height)*2}get area(){return this.width*this.height}get center(){return(new Vec2(this.xMin+this.xMax,this.yMin+this.yMax)).mul(.5)}set center(center){this.setCenterXY(center.x,center.y);return center}clone(){return new Rect(this.xMin,this.yMin,this.xMax,this.yMax)}copyCenter(){return this.center}setCenter(center){return this.setCenterXY(center.x,center.y)}setCenterXY(x,y){let w=this.width/2,h=this.height/2;this.xMin=
x-w;this.xMax=x+w;this.yMin=y-h;this.yMax=y+h;return this}scale(scaleX,scaleY=scaleX){let dw=this.width*(scaleX-1)*.5,dh=this.height*(scaleY-1)*.5;this.xMin-=dw;this.xMax+=dw;this.yMin-=dh;this.yMax+=dh;return this}growDistance(delta){let toCorner=(new Vec2((this.xMax-this.xMin)/2,(this.yMax-this.yMin)/2)).setMagnitude(delta);this.xMin-=toCorner.x;this.xMax+=toCorner.x;this.yMin-=toCorner.y;this.yMax+=toCorner.y}intersect(shape){return shape instanceof Rect?this.overlap(rect)&&!this.containsRect(rect):
shape.intersect(this)}getIntersectionPoints(shape){if(shape instanceof Rect){let array=[];let intersection=Rect.getIntersection([this,shape]);let xSelf=intersection.xMin==this.xMin;const ySelf1=intersection.yMin==shape.yMin,ySelf2=intersection.yMax==shape.yMax;if(xSelf==ySelf1)array.push(new Vec2(intersection.xMin,intersection.yMin));if(xSelf==ySelf2)array.push(new Vec2(intersection.xMin,intersection.yMax));xSelf=intersection.xMax==this.xMax;if(xSelf==ySelf1)array.push(new Vec2(intersection.xMax,
intersection.yMin));if(xSelf==ySelf2)array.push(new Vec2(intersection.xMax,intersection.yMax));return array}else return shape.getIntersectionPoints(this)}overlap(rect){return rect.xMin<=this.xMax&&rect.yMin<=this.yMax&&rect.xMax>=this.xMin&&rect.yMax>=this.yMin}containsXY(x,y){return x>=this.xMin&&x<=this.xMax&&y>=this.yMin&&y<=this.yMax}containsRect(rect){return rect.xMin>=this.xMin&&rect.xMax<=this.xMax&&rect.yMin>=this.yMin&&rect.yMax<=this.yMax}contains(p){return p.x>=this.xMin&&p.x<=this.xMax&&
p.y>=this.yMin&&p.y<=this.yMax}onLeftOfX(x){return this.xMax<x}onLeftOfRect(r){return this.xMax<r.xMin}onLeftOf(p){return this.xMax<p.x}onRightOfX(x){return this.xMin>x}onRightOfRect(r){return this.xMin>r.xMax}onRightOf(p){return this.xMin>p.x}aboveY(y){return this.yMax<y}aboveRect(r){return this.yMax<r.yMin}above(p){return this.yMax<p.y}belowY(y){return this.yMin>y}belowRect(r){return this.yMin>r.yMax}below(p){return this.yMin>p.y}addMargin(margin){this.xMin-=margin;this.xMax+=margin;this.yMin-=
margin;this.yMax+=margin;return this}addMarginsXY(marginX,marginY){this.xMin-=marginX;this.xMax+=marginX;this.yMin-=marginY;this.yMax+=marginY;return this}addMargins(marginLeft,marginTop,marginRight,marginBottom){this.xMin-=marginLeft;this.xMax+=marginRight;this.yMin-=marginTop;this.yMax+=marginBottom;return this}pushPath(context){context.rect(this.xMin,this.yMin,this.width,this.height)}draw(context,fill=false,stroke=!fill){context.beginPath();context.rect(this.xMin,this.yMin,this.width,this.height);
fill&&context.fill();stroke&&context.stroke()}getVertices(verticesArray,vOffset,indicesArray,iOffset){const n=offset/2;float32Array[offset++]=this.xMin;float32Array[offset++]=this.yMin;float32Array[offset++]=this.xMin;float32Array[offset++]=this.yMax;float32Array[offset++]=this.xMax;float32Array[offset++]=this.yMin;float32Array[offset++]=this.xMax;float32Array[offset++]=this.yMax;indicesArray[iOffset++]=n;indicesArray[iOffset++]=n+1;indicesArray[iOffset++]=n+2;indicesArray[iOffset++]=n+2;indicesArray[iOffset++]=
n+1;indicesArray[iOffset++]=n+3}setRect(rect){this.xMin=rect.xMin;this.xMax=rect.xMax;this.yMin=rect.yMin;this.yMax=rect.yMax;return this}set(left,top,right,bottom){this.yMin=top;this.xMin=left;this.xMax=right;this.yMax=bottom;return this}moveXY(x,y){this.xMin+=x;this.xMax+=x;this.yMin+=y;this.yMax+=y;return this}move(delta){this.xMin+=delta.x;this.xMax+=delta.x;this.yMin+=delta.y;this.yMax+=delta.y;return this}getPercentPoint(percent){if((percent%=1)<.25)return new Vec2(this.xMin+percent*4*this.width,
this.yMin);if(percent<.5)return new Vec2(this.xMax,this.yMin+(percent*4-1)*this.height);if(percent<.75)return new Vec2(this.xMax-(percent*4-2)*this.width,this.yMax);return new Vec2(this.xMin,this.yMax-(percent*4-3)*this.height)}closestPointTo(point){const p=new Vec2(point.x<this.xMin?this.xMin:point.x>this.xMax?this.xMax:point.x,point.y>this.yMax?this.yMax:point.y<this.yMin?this.yMin:point.y);if(p.x>this.xMin&&p.x<this.xMax&&p.y>this.yMin&&p.y<this.yMax){const dx=p.x-this.xMin<this.xMax-p.x?this.xMin-
p.x:this.xMax-p.x;const dy=p.y-this.yMin<this.yMax-p.y?this.yMin-p.y:this.yMax-p.y;if(Math.abs(dx)<Math.abs(dy))p.addXY(dx,0);else p.addXY(0,dy)}return p}toPolygon(){return Polygon.Absolute(Vec2.createVec2Array([this.xMin,this.yMin,this.xMax,this.yMin,this.xMax,this.yMax,this.xMin,this.yMax]))}getShape(){const error=new Error("Rect.getShape() is deprecated. use Rect.toPolygon() instead. The result is the same.");console.error(error.message+"\n"+error.stack);return this.toPolygon()}getRect(){return this.clone()}getRadius(){return Math.sqrt(Math.pow(this.xMax-
this.xMin,2)+Math.pow(this.yMax-this.yMin,2))/2}getCircle(){let dX=(this.xMax-this.xMin)/2,dY=(this.yMax-this.yMin)/2;return new Circle(new Vec2(this.xMin+dX,this.yMin+dY),Math.sqrt(dX*dX+dY*dY))}mirrorVertically(axisY=(this.yMax+this.yMin)/2){const yMax=this.yMin+(axisY-this.yMin);this.yMin=this.yMax+(axisY-this.yMax);this.yMax=yMax;return this}mirrorHorizontally(axisX=(this.xMax+this.xMin)/2){const xMax=this.xMin+(axisx-this.xMin);this.xMin=this.xMax+(axisX-this.xMax);this.xMax=xMax;return this}toString(){return["[",
this.xMin,", ",this.yMin,", ",this.xMax,", ",this.yMax,"]"].join("")}static getUnion(rects){let i=rects.length;if(i){let res=rects[--i].clone();while(i--){res.xMin=Math.min(res.xMin,rects[i].xMin);res.xMax=Math.max(res.xMax,rects[i].xMax);res.yMin=Math.min(res.yMin,rects[i].yMin);res.yMax=Math.max(res.yMax,rects[i].yMax)}return res}else return null}static getIntersection(rects){let i=rects.length;if(i){let r=rects[0],maxLeft=r.xMin,maxTop=r.yMin,minRight=r.xMax,minBottom=r.yMax;while(--i){r=rects[i];
if(r.yMin>maxTop)maxTop=r.yMin;if(r.xMin>maxLeft)maxLeft=r.xMin;if(r.xMax<minRight)minRight=r.xMax;if(r.yMax<minBottom)minBottom=r.yMax}if(maxLeft<=minRight&&maxTop<=minBottom)return new Rect(maxLeft,maxTop,minRight,minBottom)}return null}static createFromPoint(p){return new Rect(p.x,p.y,p.x,p.y)}static createFromXY(x,y){return new Rect(x,y,x,y)}static createFromPoints(array){let i=array.length;if(i){let minX=array[0].x,maxX=minX,minY=array[0].y,maxY=minY,p;while(--i){p=array[i];if(p.x<minX)minX=
p.x;else if(p.x>maxX)maxX=p.x;if(p.y<minY)minY=p.y;else if(p.y>maxY)maxY=p.y}return new Rect(minX,minY,maxX,maxY)}}static createFromCenterWidthHeight(center,width,height=width){return Rect.createFromPoint(center).addMarginsXY(width/2,height/2)}}Rect.prototype.glPointsNumber=4;Rect.prototype.glTriangles=2;class Circle extends Shape{constructor(center,radius){super();this.center=center.clone();this.radius=radius}get perimeter(){return Circle.PI2*this.radius}get area(){return Math.pow(this.radius,2)*
Math.PI}copyCenter(){return this.center.clone()}setCenter(center){this.center.set(center);return this}setCenterXY(x,y){this.center.setXY(x,y);return this}mirrorVertically(axisY=this.center.y){this.center.mirrorVertically(axisY);return this}mirrorHorizontally(axisX=this.center.x){this.center.mirrorHorizontally(axisX);return this}moveXY(dX,dY){this.center.addXY(dX,dY);return this}move(delta){this.center.add(delta);return this}scale(factor){this.radius*=factor;return this}growDistance(delta){this.radius+=
delta;return this}relativePointForAngle(radians){return Vec2.createFromAngle(radians,this.radius)}pointForAngle(radians){return Vec2.createFromAngle(radians,this.radius).add(this.center)}pushPath(context){context.arc(this.center.x,this.center.y,this.radius,0,Circle.PI2,false)}draw(context,fill=false,stroke=!fill){context.beginPath();context.arc(this.center.x,this.center.y,this.radius,0,Circle.PI2,false);fill&&context.fill();stroke&&context.stroke()}getVertices(verticesArray,vOffset,indicesArray,iOffset){const o=
vOffset/2;let n=this.glPointsNumber,dA=Circle.PI2/n,a=-dA,i=-1,t;while(++i<n){verticesArray[vOffset++]=(t=Vec2.createFromAngle(a+=dA,this.radius)).x;verticesArray[vOffset++]=t.y;if(i>1){indicesArray[iOffset++]=o;indicesArray[iOffset++]=o+i-1;indicesArray[iOffset++]=o+i}}}get glTriangles(){return this.glPointsNumber-2}intersect(shape){if(shape instanceof Rect)return shape.toPolygon().intersect(this);else if(shape instanceof Circle){let d=Vec2.distance(this.center,shape.center);return d<=this.radius+
shape.radius&&this.radius<=d+shape.radius&&shape.radius<=d+this.radius}else return shape.intersect(this)}getIntersectionPoints(shape){if(shape instanceof Rect)return shape.toPolygon().getIntersectionPoints(this);else if(shape instanceof Circle){let trans=Vec2.translation(this.center,shape.center),d2=trans.squareMagnitude,da=Math.acos(d2-shape.radius*shape.radius+this.radius*this.radius)/(2*Math.sqrt(d2)*this.radius),a=trans.angle;return[Vec2.createFromAngle(a+da,this.radius),Vec2.createFromAngle(a-
da,this.radius)]}else return shape.getIntersectionPoints(this)}contains(point){return Vec2.distance(this.center,point)<=this.radius}getRect(){return Rect.createFromXY(this.center.x,this.center.y).addMargin(this.radius)}getPercentPoint(percent){return this.pointForAngle(percent*Circle.PI2)}closestPointTo(p){return Vec2.translation(this.center,p).setMagnitude(this.radius)}getRadius(){return this.radius}getCircle(){return new Circle(this.center,this.radius)}clone(){return new Circle(this.center,this.radius)}toPolygon(edges,
startRadians=0){return Polygon.Regular(this.center,[this.radius],edges,startRadians)}}Circle.prototype.glPointsNumber=16;Circle.PI2=2*Math.PI;Circle.PI_2=2*Math.PI;class Ellipsoid extends Shape{constructor(center,radiusX,radiusY,radians=0){super();this.center=center.clone();this.radiusX=radiusX;this.radiusY=radiusY;this.angle=radians}get squareFocusDistance(){return this.radiusX*this.radiusX-this.radiusY*this.radiusY}get focusDistance(){return Math.sqrt(this.squareFocusDistance)}get excentricity(){return this.focusDistance/
this.radiusX}get perimeter(){return Math.PI*Math.sqrt(2*this.squareFocusDistance)}get area(){return this.radiusX*this.radiusY*Math.PI}copyCenter(){return this.center.clone()}setCenter(center){this.center.set(center);return this}setCenterXY(x,y){this.center.setXY(x,y);return this}mirrorHorizontally(axisX=this.center.x){this.radians=-this.radians;this.center.mirrorHorizontally(axisX);return this}mirrorVertically(axisY=this.center.y){this.radians=-this.radians;this.center.mirrorVertically(axisY);return this}moveXY(dX,
dY){this.center.addXY(dX,dY);return this}move(delta){this.center.add(delta);return this}scale(factor){this.radiusX*=factor;this.radiusY*=factor;return this}growDistance(delta){this.radiusX+=delta;this.radiusY+=delta;return this}rotate(radians){this.radians+=radians;return this}setAngle(radians){this.radians=radians;return this}checkRadius(){if(this.radiusX<this.radiusY){[this.radiusX,this.radiusY]=[this.radiusY,this.radiusX];this.setAngle(this.radians+Circle.PI_2)}return this}relativePointForAngle(radians){let r=
radians-this.radians;return(new Vec2(this.radiusX*Math.cos(r),this.radiusY*Math.sin(r))).rotate(this.radians)}pointForAngle(radians){return this.relativePointForAngle(radians).add(this.center)}squareRadiusForAngle(radians){return this.relativePointForAngle(radians).squareMagnitude}radiusForAngle(radians){return Math.sqrt(this.squareRadiusForAngle(radians))}pushPath(context){context.ellipse(this.center.x,this.center.y,this.radiusX,this.radiusY,this.radians,0,Circle.PI2)}draw(context,fill=false,stroke=
!fill){context.beginPath();context.ellipse(this.center.x,this.center.y,this.radiusX,this.radiusY,this.radians,0,Circle.PI2);fill&&context.fill();stroke&&context.stroke()}getVertices(verticesArray,vOffset,indicesArray,iOffset){const o=offset/2;let n=this.glPointsNumber-1,dA=Circle.PI2/n,a=0,i=-1;while(++i<n){float32Array[vOffset++]=(t=this.pointForAngle(a+=dA)).x;float32Array[vOffset++]=t.y;if(i>1){indicesArray[iOffset++]=o;indicesArray[iOffset++]=o+i;indicesArray[iOffset++]=o+i-1}}}get glTriangles(){return this.glPointsNumber-
1}contains(point){let p=point.clone().remove(this.center);return this.squareRadiusForAngle(p.angle)>p.squareMagnitude}getRect(){let h,w;if(this.radians){let a=this.radiusX,b=this.radiusY,alpha=this.radians,tanAlpha=Math.tan(alpha),sinAlpha=Math.sin(alpha),cosAlpha=Math.cos(alpha),b_a=b/a,t_xMax=Math.atan(-b_a*tanAlpha),t_yMax=Math.atan(b_a/tanAlpha);h=Math.abs(a*Math.cos(t_yMax)*sinAlpha+b*Math.sin(t_yMax)*cosAlpha);w=Math.abs(a*Math.cos(t_xMax)*cosAlpha+b*Math.sin(t_xMax)*sinAlpha)}else{h=this.radiusY;
w=this.radiusX}return new Rect(this.center.x-w,this.center.y-h,this.center.x+w,this.center.y+h)}getRadius(){return this.radiusX}getPercentPoint(percent){return this.pointForAngle(Circle.PI2*percent+this.radians)}closestPointTo(p){return this.pointForAngle(Vec2.translation(this.center,p).angle)}clone(){return new Ellipsoid(this.center,this.radiusX,this.radiusY,this.radians)}toPolygon(edges){return Polygon.createEllipsoid(this.center,this.radiusX,this.radiusY,edges,this.radians)}}Ellipsoid.prototype.glPointsNumber=
16;let A=Vec2.zero,B=Vec2.zero,C=Vec2.zero,D=Vec2.zero,AB=Vec2.zero,AC=Vec2.zero,AD=Vec2.zero,u=Vec2.zero,CD=Vec2.zero,d=0,BC=Vec2.zero,BD=Vec2.zero;class Line extends Shape{constructor(p0,p1){super();this.p0=p0.clone();this.p1=p1.clone()}get center(){return A.set(this.p0).add(this.p1).mul(.5)}set center(center){const d=Vec2.translation(this.center,center);this.p0.add(d);this.p1.add(d)}get length(){return Vec2.distance(this.p0,this.p1)}set length(l){const d=this.vector.setMagnitude((l-this.length)/
2);this.p1.add(d);this.p0.remove(d)}get angle(){return Math.atan2(this.p1.y-this.p0.y,this.p1.x,this.p0.x)}set angle(radians){const u=this.vector.mul(.5).setAngle(radians);const c=this.center;this.p0.set(c).remove(u);this.p1.set(c).add(u)}get vector(){return Vec2.translation(this.p0,this.p1)}get directorVect(){return Vec2.translation(this.p0,this.p1).normalize()}get perimeter(){return 2*Vec2.distance(this.p0,this.p1)}setAngle(radians){this.angle=radians;return this}setLength(length){this.length=length;
return this}setP0(p){this.p0.set(p);return this}setP1(p){this.p1.set(p);return this}setPoints(p0,p1){this.p0.set(p0);this.p1.set(p1);return this}setCenter(center){this.center.set(center);return this}setCenterXY(x,y){const c=this.center;const dX=x-c.x,dY=y-c.y;this.p0.addXY(dX,dY);this.p1.addXY(dX,dY);return this}copyCenter(){return this.center}moveXY(dX,dY){this.p0.addXY(dX,dY);this.p1.addXY(dX,dY);return this}move(delta){this.p0.add(delta);this.p1.add(delta);return this}scale(factor){const u=this.p1.clone().remove(this.p0).mul(.5*
factor);this.p1.add(u);this.p0.remove(u);return this}growDistance(delta){const l=this.length;return this.scale((l+delta)/l)}rotate(radians){this.angle+=radians;return this}mirrorVertically(axisY=(this.p0.y+this.p1.y)/2){this.p0.mirrorVertically(axisY);this.p1.mirrorVertically(axisY);return this}mirrorHorizontally(axisX=(this.p0.x+this.p1.x)/2){this.p0.mirrorHorizontally(axisX);this.p1.mirrorHorizontally(axisX);return this}pushPath(context){context.moveTo(this.p0.x,this.p0.y);context.lineTo(this.p1.x,
this.p1.y)}draw(context,fill=false,stroke=!fill){context.beginPath();context.moveTo(this.p0.x,this.p0.y);context.lineTo(this.p1.x,this.p1.y);fill&&context.fill();stroke&&context.stroke()}getVertices(verticesArray,vOffset,indicesArray,iOffset){const o=offset/2,A=this.p0,B=this.p1;verticesArray[vOffset++]=A.x;verticesArray[vOffset++]=A.y;verticesArray[vOffset++]=B.x;verticesArray[vOffset++]=B.y;indicesArray[iOffset++]=o;indicesArray[iOffset++]=o+1;indicesArray[iOffset++]=o}intersect(shape){if(shape instanceof
Rect)return shape.toPolygon().intersect(this);else if(shape instanceof Circle){if(shape.contains(this.p0)!=shape.contains(this.p1))return true;const l=this.length;AC.set(shape.center).remove(this.p0);u.set(this.p1).remove(this.p0).mul(1/this.length);d=Vec2.dotProd(u,AC);return d>=0&&d<=l&&Vec2.squareDistance(u.mul(d).add(this.p0),shape.center)<=shape.radius*shape.radius}else if(shape instanceof Line)if(Vec2.ccw2(AC.set(shape.p0).remove(this.p0),AD.set(shape.p1).remove(this.p0))!==Vec2.ccw(this.p1,
shape.p0,shape.p1)){AB.set(this.p1).remove(this.p0);return Vec2.ccw2(AB,AC)!==Vec2.ccw2(AB,AD)}else return false;else return shape.intersect(this)}getIntersectionPoints(shape){if(shape instanceof Rect)return shape.toPolygon().getIntersectionPoints(this);else if(shape instanceof Circle){A=this.p0.clone();C=shape.center;u.set(this.p1).remove(A).normalize();let a=u.x*u.x+u.y*u.y,b=2*(u.x*(A.x-C.x)+u.y*(A.y-C.y)),c=A.x*(A.x-2*C.x)+C.x*C.x+A.y*(A.y-2*C.y)+C.y*C.y-radius*radius;d=b*b-4*a*c;if(d==0){d=-b/
(2*a);if(d>=0)return A.add(u.mul(d))}else if(d>0){d=Math.sqrt(d);a*=2;let l1=(-b-d)/a,l2=(-b+d)/a;if(l1>=0)if(l2>=0)return[B.set(u).mul(l1).add(A),A.add(u.mul(l2))];else return[A.add(u.mul(l1))];else if(l2>=0)return[A.add(u.mul(l2))]}else return[]}else if(shape instanceof Line){let p=Line.intersectionPoint(this,shape);if(p.onLine1&&p.onLine2)return[p.point];else return[]}else return shape.getIntersectionPoints(this)}contains(point){return point.equals(this.p0)||point.equals(this.p1)||Vec2.distance(this.p0,
point)+Vec2.distance(this.p1,point)==Vec2.distance(this.p0,this.p1)}closestPointTo(p){A=this.p0;u=this.directorVect;AC.set(p).remove(A);d=Vec2.dotProd(u,AC);return d<0?u.set(A):d<this.length?u.mul(d).add(A):u.set(this.p1)}distanceToPoint(point){return Vec2.distance(this.closestPointTo(point),point)}getNormalVect(left=true){return this.directorVect.rotate(left?-Circle.PI_2:Circle.PI_2)}getRect(){A=this.p0;B=this.p1;let left,top,right,bottom;if(A.x<B.x){left=A.x;right=B.x}else{left=B.x;right=A.x}if(A.y<
B.y){top=A.y;bottom=B.y}else{top=B.y;bottom=A.y}return new Rect(left,top,right,bottom)}geRadius(){return Vec2.distance(this.p0,this.p1)*.5}clone(){return new Line(this.p0,this.p1)}static intersectionPoint(line1,line2){A=line1.p0;C=line2.p0;AB.set(line1.p1).remove(A);CD.set(line2.p1).remove(C);d=CD.y*AB.x-CD.x*AB.y;if(!d)return null;let CA=Vec2.translation(C,A),pos1=(CD.x*CA.y-CD.y*CA.x)/d,pos2=(AB.x*CA.y-AB.y*CA.x)/d;return{point:AB.mul(pos1).add(A),onLine1:pos1>0&&pos1<1,onLine2:pos2>0&&pos2<1}}static createFromPointVector(A,
AB){return new Line(A,A.clone().add(AB))}}Line.prototype.glPointsNumber=2;Line.prototype.glPointsNumber=1;class Point extends Shape{constructor(p){super();this.center=p.clone()}copyCenter(){return this.center.clone()}setCenter(center){this.center.set(center);return this}setCenterXY(x,y){this.center.setXY(x,y);return this}mirrorVertically(axisY=this.center.y){this.center.mirrorVertically(axisY);return this}mirrorHorizontally(axisX=this.center.x){this.center.mirrorHorizontally(axisX);return this}moveXY(dX,
dY){this.center.addXY(dX,dY);return this}move(delta){this.center.add(delta);return this}pushPath(context){context.rect(this.center.x-.5,this.center.y-.5,1,1)}draw(context,fill=true,stroke=!fill){context.fillRect(this.center.x-this.drawThickness,this.center.y-this.drawThickness,2*this.drawThickness,2*this.drawThickness)}getVertices(verticesArray,vOffset,indicesArray,iOffset){const o=offset/2;verticesArray[vOffset++]=this.center.x;verticesArray[vOffset++]=this.center.y;indicesArray[iOffset++]=o;indicesArray[iOffset++]=
o;indicesArray[iOffset++]=o}clone(){return new Point(this.center)}}Point.prototype.drawThickness=1;Point.prototype.glPointsNumber=1;Point.prototype.glPointsNumber=1;let len=0,i=0,res=0,p0=Vec2.zero,p1=Vec2.zero;class Polygon extends Shape{constructor(center,relativePoints){super();this.center=center.clone();i=relativePoints.length;this.points=new Array(i);while(i--)this.points[i]=relativePoints[i].clone()}get perimeter(){i=this.points.length-1;res=Vec2.distance(this.points[0],this.points[i]);while(i)res+=
Vec2.distance(this.points[i--],this.points[i]);return res}get area(){res=0;i=this.points.length;p1=this.points[0];while(i--){p0=this.points[i];res+=(p0.x+p1.x)*(p0.y-p1.y);p1=p0}return res/2}copyCenter(){return this.center.clone()}setCenter(center){this.center.set(center);return this}setCenterXY(x,y){this.center.setXY(x,y);return this}moveXY(dX,dY){this.center.addXY(dX,dY);return this}move(delta){this.center.add(delta);return this}scale(factor){i=this.points.length;while(i--)this.points[i].mul(factor);
return this}growDistance(delta){i=this.points.length;while(i--)this.points.magnitude+=delta;return this}rotate(radians){i=this.points.length;while(i--)this.points[i].angle+=radians;return this}mirrorVertically(axisY=this.center.y){this.center.mirrorVertically(axisY);i=this.points.length;while(i--)this.points[i].mirrorVertically();return this}mirrorHorizontally(axisX){this.center.mirrorHorizontally(axisX);i=this.points.length;while(i--)this.points[i].mirrorHorizontally();return this}pushPath(context){len=
this.points.length;if(len){context.translate(this.center.x,this.center.y);context.moveTo(this.points[0].x,this.points[0].y);i=1;while(i<len)context.lineTo(this.points[i].x,this.points[i++].y);context.lineTo(this.points[0].x,this.points[0].y);context.translate(-this.center.x,-this.center.y)}}draw(context,fill=false,stroke=!fill){context.beginPath();len=this.points.length;if(len){context.translate(this.center.x,this.center.y);context.moveTo(this.points[0].x,this.points[0].y);i=1;while(i<len)context.lineTo(this.points[i].x,
this.points[i++].y);context.closePath();context.translate(-this.center.x,-this.center.y)}fill&&context.fill();stroke&&context.stroke()}get glPointsNumber(){return this.points.length}get glTriangles(){return this.points.length-2}ccw(){const n=this.points.length;let z=0,i,j;for(i=0,j=1;i<n;i++,j++){if(j==n)j=0;z+=(this.points[i].y+this.points[j].y)*(this.points[j].x-this.points[i].x)}return z<=0}divideConvex(){let polygons=[];let points=this.points.slice(0);let n=points.length;if(n<4)return[new Polygon(this.center,
points)];const ccw=this.ccw();let i=0;while(n>3){let prv=points[(i-1+n)%n],cur=points[i],nxt=points[(i+1)%n];while(i<n&&Vec2.ccw(prv,cur,nxt)==ccw){i++;prv=cur;cur=nxt;nxt=points[(i+1)%n]}if(i==n)break;let j=(i-3+n)%n;while(Vec2.ccw(prv,cur,points[j])==ccw&&Vec2.ccw(points[j],points[(j+1)%n],points[(j+2)%n])==ccw)j=(j-1+n)%n;j++;let array=[points[j%n]];j=(j+1)%n;while(j!=i){array.push(points.splice(j,1)[0]);if(j<i)i--;n--;j=j%n}array.push(points[i]);polygons.push(new Polygon(this.center,array));if(n<
4)break}polygons.push(new Polygon(this.center,points));return polygons}getVertices(verticesArray,vOffset,indicesArray,iOffset){const o=vOffset/2,n=this.points.length;let i=0;while(i<n){if(i>1){indicesArray[iOffset++]=o;indicesArray[iOffset++]=o+i-1;indicesArray[iOffset++]=o+i}verticesArray[vOffset++]=this.points[i].x+this.center.x;verticesArray[vOffset++]=this.points[i++].y+this.center.y}}getPoint(index){return this.points[index].clone().add(this.center)}getPoints(){i=this.points.length;let arr=new Array(i);
while(i--)arr[i]=this.points[i].clone().add(this.center);return arr}getLine(index){len=this.points.length;return(new Line(this.points[index++%len],this.points[index%len])).move(this.center)}getRelativeLine(index){len=this.points.length;return new Line(this.points[index++%len],this.points[index%len])}getLines(){len=this.points.length;i=len;let arr=new Array(i);while(i--)arr[i]=(new Line(this.points[i],this.points[(i+1)%len])).move(this.center);return arr}getNormalVectForLine(index){return this.getLine(index).getNormalVect(false)}rotatePointsOrder(delta){if(delta%
1)delta=Math.round(delta);len=this.points.length;i=len;let p=new Array(len);while(i--)p[i]=this.points[(i+delta)%len];i=len;while(i--)this.points[i]=p[i]}getReducedPolygon(distance){let n=this.points.length,points=new Array(len),p,l1,l2,i;for(i=0;i<n;i++){p=this.points[i].clone();l1=i?this.getRelativeLine(i-1):this.getRelativeLine(n-1);l2=this.getRelativeLine(i);l1.move(l1.getNormalVect().mul(distance));l2.move(l2.getNormalVect().mul(distance));points[i]=Line.intersectionPoint(l1,l2)}return new Polygon(this.center,
points)}intersect(shape){let lines=this.getLines(),i=lines.length;if(!i)return false;if(shape instanceof Polygon){let lines2=shape.getLines(),len=lines2.length,l,j;while(i--){l=lines[i];j=len;while(j--)if(lines2[j].intersect(l))return true}}else while(i--)if(lines[i].intersect(shape))return true;return false}getIntersectionPoints(shape){let lines=this.getLines(),i=lines.length,res=[];if(!i)return[];if(shape instanceof Polygon){let lines2=shape.getLines(),len=lines2.length,l,j;while(i--){l=lines[i];
j=len;while(j--)Array.prototype.push.apply(res,lines2[j].getIntersectionPoints(l))}}else while(i--)Array.prototype.push.apply(res,lines[i].getIntersectionPoints(shape));return res}getIntersectionLine(shape,startIndex=0){let lines=this.getLines(),i=lines.length;if(i<=startIndex)return null;if(shape instanceof Polygon){let lines2=shape.getLines(),len=lines2.length,l,j;while(i-- >startIndex){l=lines[i];j=len;while(j--)if(lines2[j].intersect(l))return l}}else while(i-- >startIndex)if(lines[i].intersect(shape))return lines[i];
return null}getIntersectionLines(shape,startIndex=0){let lines=this.getLines(),i=lines.length;let result=[];if(shape instanceof Polygon){let lines2=shape.getLines(),len=lines2.length,l,j;while(i-- >startIndex){l=lines[i];j=len;while(j--)if(lines2[j].intersect(l))result.push(l)}}else while(i-- >startIndex)if(lines[i].intersect(shape))result.push(lines[i]);return result}contains(point){const n=this.points.length;const A=Vec2.zero,B=this.points[0].clone();point=point.clone().remove(this.center);let i,
j;let nb=0;for(i=0;i<n;i++){A.set(B);B.set(this.points[(i+1)%n]);if(A.y>point.y&&B.y>point.y||A.y<point.y&&B.y<point.y||A.x<point.x&&B.x<point.x||A.y==point.y&&B.y<point.y||A.y<point.y&&B.y==point.y||A.y==B.y||A.x>point.x&&B.x<point.x&&Vec2.ccw(point,B,A)||A.x<point.x&&B.x>point.x&&Vec2.ccw(point,A,B))continue;nb++}return nb%2===1}getRect(){let point,i=this.points.length-1;let xmin=this.points[i].x,ymin=this.points[i].y,xmax=xmin,ymax=ymin;while(i--){point=this.points[i];if(point.x<xmin)xmin=point.x;
else if(point.x>xmax)xmax=point.x;if(point.y<ymin)ymin=point.y;else if(point.y>ymax)ymax=point.y}return(new Rect(xmin,ymin,xmax,ymax)).move(this.center)}getPercentPoint(p){let dist=this.perimeter*(p%1),lines=this.getLines(),len=lines.length,l,i;for(i=0;i<len;i++){l=lines[i].length;if(l>dist)return lines[i].getPercentPoint(dist/l);else dist-=l}return this.points[i].add(this.center)}closestPointTo(p){let closest=null,d,D=Number.MAX_SAFE_INTEGER,l=this.getLines(),i=l.length,c;while(i--){c=l[i].closestPointTo(p);
d=Vec2.squareDistance(c,p);if(d<D){closest=c;D=d}}return closest}getRadius(){let r=0,mag,i;for(i=this.points.length-1;i>=0;i--){mag=this.points[i].squareMagnitude;if(mag>r)r=mag}return Math.sqrt(r)}redefineCenter(delta=null){let i=this.points.length;if(!i)return;if(!delta){delta=Vec2.zero;const len=i;while(i--)delta.add(this.points[i]);delta.mul(1/len);i=len}while(i--)this.points[i].remove(delta);return this}clone(){return new Polygon(this.center,this.points)}static Absolute(pointsArray){const len=
pointsArray.length;const c=Vec2.zero;let i=len;while(i--)c.add(pointsArray[i]);return(new Polygon(c.mul(1/len),pointsArray)).redefineCenter(c)}static Rectangular(center,width,height){let left=-width*.5,top=-height*.5,right=left+width,bottom=top+height;return new Polygon(center,Vec2.createVec2Array([left,top,right,top,right,bottom,left,bottom]))}static Ellipsoidal(center,radiusX,radiusY,edges,radians=0){let dA=Circle.PI2/edges,a=Circle.PI2,points=new Array(edges),i=edges;while(i--){a-=dA;points[i]=
Vec2(radiusX*Math.cos(a),radiusY*Math.sin(a))}return new Polygon(center,points)}static Regular(center,radiusArray,pointsNumber,startRadians){let dR=Circle.PI2/pointsNumber,angle=startRadians,rLen=radiusArray.length,p=new Polygon(center,[]);p.points=new Array(pointsNumber);if(rLen!==undefined){let i=-1;while(++i<pointsNumber){p.points[i]=Vec2.createFromAngle(angle,radiusArray[i%rLen]);angle+=dR}}else{let i=pointsNumber;while(i--){p.points[i]=Vec2.createFromAngle(angle,radiusArray);angle-=dR}}return p}}
class Ray extends Shape{constructor(origin,radians){super();this.origin=origin;this.angle=radians}get center(){return this.origin}set center(center){this.origin.set(center)}get perimeter(){return Infinity}moveXY(dX,dY){this.origin.addXY(dX,dY);return this}move(delta){this.origin.add(delta);return this}rotate(radians){this.angle+=radians;return this}mirrorVertically(axisY=this.center.y){this.origin.mirrorVertically(axisY);this.angle=-this.angle;return this}mirrorHorizontally(axisX=this.center.x){this.origin.mirrorHorizontally(axisX);
this.angle=Math.PI-this.angle;return this}endPoint(length){return this.origin.clone().addXY(Math.cos(this.angle)*length,Math.sin(this.angle)*length)}getLine(length){return Line.createFromPointVector(this.origin,Vec2.createFromAngle(this.angle,length))}pushPath(context){const p=this.endPoint(context.canvas.clientWidth+context.canvas.clientHeight);context.moveTo(this.origin.x,this.origin.y);context.moveTo(this.origin.x,this.origin.y);context.lineTo(p.x,p.y)}getVertices(verticesArray,vOffset,indicesArray,
iOffset){const o=offset/2,t=this.endPoint(Number.MAX_SAFE_INTEGER);verticesArray[vOffset++]=this.origin.x;verticesArray[vOffset++]=this.origin.y;verticesArray[vOffset++]=t.x;verticesArray[vOffset++]=t.y;indicesArray[iOffset++]=o;indicesArray[iOffset++]=o+1;indicesArray[iOffset++]=o}intersect(shape){const rect=shape instanceof Rect?shape:shape.getRect();return(new Line(this.center,this.endPoint(Vec2.distance(this.origin,shape.center)+rect.width+rect.height))).intersect(shape)}getIntersectionPoints(shape){const rect=
shape instanceof Rect?shape:shape.getRect();return this.getLine(Vec2.distance(this.origin,shape.center)+rect.width+rect.height).getIntersectionPoints(shape)}contains(point){return this.endPoint(Vec2.distance(this.origin,point)).equals(point)}getRect(){const endPoint=this.endPoint(Infinity);return new Rect(Math.min(endPoint.x,this.origin.x),Math.min(endPoint.y,this.origin.y),Math.max(endPoint.x,this.origin.x),Math.max(endPoint.y,this.origin.y))}get directorVect(){return Vec2.createFromAngle(this.angle)}closestpointTo(p){let A=
this.origin,AC=Vec2.translation(A,p),u=this.directorVect,d=Vec2.dotProd(u,AC);return d<0?u.set(A):u.mul(d).add(A)}getRadius(){return Infinity}clone(){return new Ray(this.origin,this.angle)}}Ray.prototype.glPointsNumber=2;Ray.prototype.glTrinagles=1;if(window){window.utils=window.utils||{};utils.geometry2d={Vec2,Rect,Shape,Circle,Ellipsoid,Line,Point,Polygon,Ray}}else;};
