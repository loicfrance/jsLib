'use strict';window["webgl"]={getContext(canvas){return canvas.getContext("webgl2")||canvas.getContext("webgl")||canvas.getContext("experimental-webgl")},initContext(gl){gl.clearColor(0,0,0,1);gl.enable(gl.CULL_FACE);gl.enable(gl.DEPTH_TEST);gl.depthFunc(gl.LEQUAL);gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT)},setAlphaEnabled(gl,enable){gl.blendFunc(gl.SRC_ALPHA,gl.ONE_MINUS_SRC_ALPHA);if(enable)gl.enable(gl.BLEND);else gl.disable(gl.BLEND)},createShader(gl,shaderScript,type){let shader;if(type!=
WebGLRenderingContext.VERTEX_SHADER||type!=WebGLRenderingContext.FRAGMENT_SHADER)switch(type){case "vertex":type=WebGLRenderingContext.VERTEX_SHADER;break;case "fragment":type=WebGLRenderingContext.FRAGMENT_SHADER;break;default:console.error((new Error(`'${type}' is not a valid shader type. only 'vertex' and 'fragment' are accepted as shader type.\n\t\t\t\t\t\tyou can also use VERTEX_SHADER or FRAGMENT_SHADER constants of the WebGLRenderingContext class`)).stack);return}shader=gl.createShader(type);
gl.shaderSource(shader,shaderScript);gl.compileShader(shader);if(!gl.getShaderParameter(shader,gl.COMPILE_STATUS)){console.error((new Error(gl.getShaderInfoLog(shader))).stack);gl.deleteShader(shader);return null}return shader},createProgram(gl,vertexShader,fragmentShader){const prog=gl.createProgram();if(vertexShader.substr)gl.attachShader(prog,webgl.createShader(gl,vertexShader,"vertex"));else gl.attachShader(prog,vertexShader);if(fragmentShader.substr)gl.attachShader(prog,webgl.createShader(gl,
fragmentShader,"fragment"));else gl.attachShader(prog,fragmentShader);gl.linkProgram(prog);if(!gl.getProgramParameter(prog,gl.LINK_STATUS)){console.error((new Error(gl.getProgramInfoLog(prog))).stack);gl.deleteProgram(prog);return}return prog},getAttribLocations(gl,program,names){let result=new Array(names.length);for(let i=0;i<names.length;i++)result[i]=gl.getAttribLocation(program,names[i]);return result},getUniformLocations(gl,program,names){let result=new Array(names.length);for(let i=0;i<names.length;i++)result[i]=
gl.getUniformLocation(program,names[i]);return result},createAttribBuffer(gl,target,srcData,usage=WebGLRenderingContext.STATIC_DRAW,srcOffset=0,length=0){const buffer=gl.createBuffer();gl.bindBuffer(target,buffer);gl.bufferData(target,srcData,usage,srcOffset,length);return buffer},standardFragmentShader:`#version 300 es\nprecision mediump float;\nin vec4 v_color;\nout vec4 outColor;\nvoid main() { outColor = v_color; }\n\t`,createMVMat3:function(tx,ty,rad,scaleX,scaleY){let cos=Math.cos(rad),sin=
Math.sin(rad);return[cos*scaleX,-sin*scaleY,0,sin*scaleX,cos*scaleY,0,tx,ty,1]},translationMat3:function(dX,dY){return[1,0,0,0,1,0,dX,dY,1]},rotationMat3:function(rad){return[cos,-sin,0,sin,cos,0,0,0,1]},scaleMat3:function(scaleX,scaleY){return[scaleX,0,0,0,scaleY,0,0,0,1]},perspectiveMat4:function(fov,aspect,zNear,zFar){const f=Math.tan(Math.PI*.5-.5*fov),rangeInv=1/(zNear-zFar);return[f/aspect,0,0,0,0,f,0,0,0,0,(zNear+zFar)*rangeInv,-1,0,0,zNear*zFar*rangeInv*2,1]},projectionMat4:function(xmin,
xmax,ymin,ymax,zNear,zFar){const w=xmax-xmin,h=ymax-ymin,d=zFar-zNear;return[2/w,0,0,-(xmax+xmin)/w,0,2/h,0,-(ymax+ymin)/h,0,0,-2/d,-(zFar+zNear)/d,0,0,0,1]},identityMat4:function(){return[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]}};
