'use strict';{if(window);else;const G={LEFT:1,TOP:2,RIGHT:4,BOTTOM:8,CENTER:16,getRect:(gravity,availableRect,width,height,marginX=0,marginY=marginX)=>{availableRect=availableRect.clone().addMarginsXY(-marginX,-marginY);if(!(gravity&G.CENTER))if(gravity){if(!(gravity&G.LEFT)&&!(gravity&G.RIGHT))gravity|=G.LEFT;if(!(gravity&G.TOP)&&gravity&G.BOTTOM)gravity|=G.TOP}else gravity=G.LEFT|G.TOP;let left=NaN,top=NaN,right=NaN,bottom=NaN;if(gravity&G.CENTER){let w=(availableRect.width-width)/2,h=(availableRect.h.height-
height)/2;left=availableRect.xMin+w;right=availableRect.xMax-w;top=availableRect.yMin+h;bottom=availableRect.yMax-h}if(gravity&G.LEFT!==0)left=availableRect.xMin;if(gravity&G.TOP!==0)top=availableRect.yMin;if(gravity&G.RIGHT!==0)right=availableRect.xMax;if(gravity&G.BOTTOM!==0)bottom=availableRect.yMax;if(isNaN(left))left=right-width;else if(isNaN(right))right=left+width;if(isNaN(top))top=bottom-height;else if(isNaN(bottom))bottom=top+height;return new Rect(left,top,right,bottom)},getHorizontalGravity:(g,
defaultG=null)=>g&G.LEFT?G.LEFT:g&G.RIGHT?G.RIGHT:g&G.CENTER?G.CENTER:defaultG?defaultG:G.LEFT,getVerticalGravity:(g,defaultG=null)=>g&G.TOP?G.TOP:g&G.BOTTOM?G.BOTTOM:g&G.CENTER?G.CENTER:defaultG?defaultG:G.TOP};const inclusionFilter=(array,x)=>array.indexOf(x)!==-1;const exclusionFilter=(array,x)=>array.indexOf(x)===-1;const instanceFilter=(_class,x)=>x instanceof _class;const randomColor=(octets=3)=>"#"+Math.random().toString(16).substr(2,2*octets);function HSVtoRGB(h,s,v){const i=Math.floor(h*
6),f=h*6-i,p=v*(1-s),q=v*(1-f*s),t=v*(1-(1-f)*s);let r,g,b;switch(i%6){case 0:r=v,g=t,b=p;break;case 1:r=q,g=v,b=p;break;case 2:r=p,g=v,b=t;break;case 3:r=p,g=q,b=v;break;case 4:r=t,g=p,b=v;break;case 5:r=v,g=p,b=q;break}return{r:Math.round(r*255),g:Math.round(g*255),b:Math.round(b*255)}}function RBGtoHSV(r,g,b){const max=Math.max(r,g,b),min=Math.min(r,g,b),d=max-min,s=max===0?0:d/max,v=max/255;switch(max){case min:return{h:0,s:s,v:v};case r:return{h:(g-b+d*(g<b?6:0))/(6*d),s:s,v:v};case g:return{h:(b-
r+d*2)/(6*d),s:s,v:v};case b:return{h:(r-g+d*4)/(6*d),s:s,v:v};default:return{h:0,s:0,s:0}}}const RGBToHex=(r,g,b)=>r<16&&g<16&&b<16||r>=16&&g>=16&&b>=16?`#${r.toString(16)}${g.toString(16)}${b.toString(16)}`:`#${r.toString(16).padStart(2,"0")}${g.toString(16).padStart(2,"0")}${b.toString(16).padStart(2,"0")}`;function mix(superclass,...mixins){class C extends superclass{}let len=mixins.length,i=-1;while(++i<len)merge(C.prototype,mixins[i],true);return C}function merge(out,src,override=false){for(let p in src)if(src.hasOwnProperty(p)&&
(override||!out.hasOwnProperty(p)))out[p]=src[p]}const loadString=(url)=>new Promise((resolve)=>{const client=new XMLHttpRequest;client.open("GET",url);client.onreadystatechange=()=>{if(client.readyState===4&&client.status===200||client.status===0)resolve(client.responseText)};client.send()});const loadImage=(url)=>new Promise((resolve)=>{const img=new Image;img.onload=()=>resolve(img);img.src=url});function createScriptWorker(script){const url=URL.createObjectURL(new Blob([script],{type:"application/javascript"}));
const worker=new Worker(url);URL.revokeObjectURL(url);return worker}function polyfill(container,name,vendors){for(let i=0;i<vendors.length&&!container[name];i++)container[name]=container[vendors[i]+name]||container[vendors[i]+name[0].toUpperCase()+name.substr(1)]}function waitForEvent(object,event){const attr=`on${event}`;return new Promise((r)=>{const old=object[attr];object[attr]=(evt)=>{object[attr]=old;r(evt)}})}function delay(ms){return new Promise((r)=>setTimeout(r,ms))}function textFileUserDownload(text,
fileName){let element=document.createElement("a");element.setAttribute("href","data:text/plain;charset=utf-8,"+encodeURIComponent(text));element.setAttribute("download",fileName);element.style.display="none";document.body.appendChild(element);element.click();document.body.removeChild(element)}function BBCodeToHTML(bbCode){let str=bbCode;str=str.replace(/\[b](.+?)\[\/b]/g,"<b>$1</b>");str=str.replace(/\[br\/]/g,"");str=str.replace(/\[br]/g,"");str=str.replace(/\[i](.+?)\[\/i]/g,"<i>$1</i>");str=str.replace(/\[u](.+?)\[\/u]/g,
"<u>$1</u>");str=str.replace(/\[s](.+?)\[\/s]/g,"<s>$1</s>");str=str.replace(/\[code](.+?)\[\/code]/g,"<code>$1</code>");str=str.replace(/\[pre](.+?)\[\/pre]/g,"<code>$1</code>");str=str.replace(/\[style (.+?)](.+?)\[\/style]/g,"<font $1>$2</font>");str=str.replace(/\[size=(.+?)](.+?)\[\/size]/g,'<span style="font-size:$1px;">$2</span>');str=str.replace(/\[color=(.+?)](.+?)\[\/color]/g,'<span style="color:$1;">$2</span>');str=str.replace(/\[url=([^]+)](.+?)\[\/url]/g,'<a href="$1">$2</a>');str=str.replace(/\[url](.+?)\[\/url]/g,
'<a href="$1" target="_blank">$1</a>');str=str.replace(/\[img](.+?)\[\/img]/g,'<img src="$1" border="0">');return str}const loadWASM=(wasmUrl,imports)=>fetch(wasmUrl).then((response)=>response.arrayBuffer()).then((bytes)=>WebAssembly.instantiate(bytes,imports));const instanciateWASM=(wasmUrl,imports)=>loadWASM(wasmUrl,imports).then((results)=>results.instance);Math.rangedRandom=(min,max)=>Math.random()*(max-min)+min;Math.gaussianRandom=()=>(Math.random()+Math.random()+Math.random()+Math.random()+
Math.random()+Math.random()-3)/3;CanvasRenderingContext2D.prototype.wrapText=function(text,rect,lineHeight,textGravity,fill=true,stroke=false){const paragraphs=text.split("\n");const parLen=paragraphs.length;const rectWidth=rect.width;let lines=[],line;let linesX=[],lineX=0;let words,len;let testLine;let metrics;let width=0;let n;for(let i=0;i<parLen;i++){words=paragraphs[i].split(" ");len=words.length;if(!len){lines.push(paragraphs[i]);linesX.push(0);continue}line=words[0];for(n=1;n<len;n++){testLine=
line+" "+words[n];metrics=this.measureText(testLine);width=metrics.width;if(width>rectWidth&&n>0){lineX=rect.xMin;if(!(textGravity&G.LEFT))if(textGravity&G.RIGHT)lineX+=this.measureText(line).width-width;else if(textGravity&G.CENTER)lineX+=(this.measureText(line).width-width)/2;lines.push(line);line=words[n];linesX.push(lineX)}else line=testLine}lineX=rect.xMin;if(!(textGravity&G.LEFT)){metrics=this.measureText(line);width=metrics.width;if(textGravity&G.RIGHT)lineX+=rectWidth-width;else if(textGravity&
G.CENTER)lineX+=(rectWidth-width)/2}lines.push(line);linesX.push(lineX)}len=lines.length;let y=rect.yMin+lineHeight;if(!(textGravity&G.TOP))if(textGravity&G.BOTTOM)y=rect.yMax-lineHeight*(len-1);else if(textGravity&G.CENTER)y+=(rect.height-lineHeight*len)/2;for(n=0;n<len;n++){if(fill)this.fillText(lines[n],linesX[n],y);if(stroke)this.strokeText(lines[n],linesX[n],y);y+=lineHeight}};if(window){window.utils=window.utils||{};utils.tools={LayoutGravity:G,inclusionFilter,exclusionFilter,instanceFilter,
randomColor,HSVtoRGB,RBGtoHSV,RGBToHex,mix,merge,loadString,loadImage,createScriptWorker,polyfill,textFileUserDownload,BBCodeToHTML,loadWASM,instanciateWASM}}else;}
{class Vec2{constructor(x,y){this.x=x;this.y=y}get angle(){return Math.atan2(this.y,this.x)}set angle(a){const m=this.magnitude;if(m){this.x=Math.cos(a)*m;this.y=Math.sin(a)*m}}get squareMagnitude(){return this.x*this.x+this.y*this.y}get magnitude(){return Math.sqrt(this.x*this.x+this.y*this.y)}set magnitude(mag){let m=this.magnitude;if(m)this.mul(mag/m);else this.x=mag}clone(){return new Vec2(this.x,this.y)}setXY(x,y){this.x=x;this.y=y;return this}set(vec){this.x=vec.x;this.y=vec.y;return this}reset(){this.x=
this.y=0;return this}addXY(x,y){this.x+=x;this.y+=y;return this}add(vec){this.x+=vec.x;this.y+=vec.y;return this}remove(vec){this.x-=vec.x;this.y-=vec.y;return this}mul(factor){this.x*=factor;this.y*=factor;return this}normalize(){this.mul(1/(this.magnitude||1));return this}setMagnitude(mag){this.magnitude=mag;return this}setAngle(a){this.angle=a;return this}rotate(a){this.angle+=a;return this}rotateAround(center,a){return this.set(Vec2.translation(center,this).rotate(a).add(center))}toString(){return["(",
this.x,",",this.y,")"].join("")}equalsXY(x,y){return this.x===x&&this.y===y}equals(vec){return this.x===vec.x&&this.y===vec.y}isZero(){return!(this.x||this.y)}getUnit(){return this.clone().normalize()}getMirror(center=Vec2.ZERO){return Vec2.translation(this,center).add(center)}getHorizontalMirror(axisX=0){return this.clone().mirrorHorizontally()}getVerticalMirror(axisY=0){return this.clone().mirrorVertically()}mirror(center=Vec2.ZERO){this.x=center.x?2*center.x-this.x:-this.x;this.y=center.y?2*center.y-
this.y:-this.y;return this}mirrorHorizontally(axisX=0){this.x=axisX?2*axisX-this.x:-this.x;return this}mirrorVertically(axisY=0){this.y=axisY?2*axisY-this.y:-this.y;return this}getRoundedX(digits=0){if(digits)return parseInt(this.x.toPrecision(digits));else return Math.round(this.x)}getRoundedY(digits=0){if(digits)return parseInt(this.y.toPrecision(digits));else return Math.round(this.y)}roundedVec(digits=0){return new Vec2(this.getRoundedX(digits),this.getRoundedY(digits))}clampMagnitude(min,max){let m=
this.magnitude;if(m)if(m<min)this.mul(min/m);else{if(m>max)this.mul(max/m)}else this.x=min;return this}static dotProd(u,v){return u.x*v.x+u.y*v.y}static vectProd(u,v){return u.x*v.y-u.y*v.x}static translation(A,B){return new Vec2(B.x-A.x,B.y-A.y)}static squareDistance(A,B){let dX=B.x-A.x,dY=B.y-A.y;return dX*dX+dY*dY}static distance(A,B){return Math.sqrt(Vec2.squareDistance(A,B))}static manhattanDistance(A,B){return Math.abs(B.x-A.x)+Math.abs(B.y-A.y)}static diagonalDistance(A,B){return Math.max(Math.abs(B.x-
A.x),Math.abs(B.y-A.y))}static ccw(A,B,C){return(C.y-A.y)*(B.x-A.x)>(B.y-A.y)*(C.x-A.x)}static ccw2(AB,AC){return AC.y*AB.x>AB.y*AC.x}static createFromAngle(rad,mag=1){return new Vec2(Math.cos(rad)*mag,Math.sin(rad)*mag)}static createVec2Array(xyxyArray){const len=Math.floor(xyxyArray.length/2),result=new Array(len);let i=len,i2;while(i--){i2=2*i;result[i]=new Vec2(xyxyArray[i2],xyxyArray[i2+1])}return result}static createFloatArray(vec2Array){const len=vec2Array.length,result=new Float32Array(len*
2);let i=len,i2;while(i--){i2=i*2;result[i2]=vec2Array[i].x;result[i2+1]=vec2Array[i].y}return result}static get zero(){return new Vec2(0,0)}}Vec2.ZERO=Vec2.zero;class Rect{constructor(xMin,yMin,xMax,yMax){this.xMin=xMin;this.yMin=yMin;this.xMax=xMax;this.yMax=yMax}get width(){return this.xMax-this.xMin}get height(){return this.yMax-this.yMin}get ratio(){return this.width/this.height}get perimeter(){return(this.width+this.height)*2}get area(){return this.width*this.height}get center(){return(new Vec2(this.xMin+
this.xMax,this.yMin+this.yMax)).mul(.5)}set center(center){this.setCenterXY(center.x,center.y);return center}clone(){return new Rect(this.xMin,this.yMin,this.xMax,this.yMax)}setCenter(center){return this.setCenterXY(center.x,center.y)}setCenterXY(x,y){let w=this.width/2,h=this.height/2;this.xMin=x-w;this.xMax=x+w;this.yMin=y-h;this.yMax=y+h;return this}scale(scaleX,scaleY=scaleX){let dw=this.width*(scaleX-1)*.5,dh=this.height*(scaleY-1)*.5;this.xMin-=dw;this.xMax+=dw;this.yMin-=dh;this.yMax+=dh;return this}overlap(rect){return rect.xMin<=
this.xMax&&rect.yMin<=this.yMax&&rect.xMax>=this.xMin&&rect.yMax>=this.yMin}containsXY(x,y){return x>=this.xMin&&x<=this.xMax&&y>=this.yMin&&y<=this.yMax}containsRect(rect){return rect.xMin>=this.xMin&&rect.xMax<=this.xMax&&rect.yMin>=this.yMin&&rect.yMax<=this.yMax}contains(p){return p.x>=this.xMin&&p.x<=this.xMax&&p.y>=this.yMin&&p.y<=this.yMax}onLeftOfX(x){return this.xMax<x}onLeftOfRect(r){return this.xMax<r.xMin}onLeftOf(p){return this.xMax<p.x}onRightOfX(x){return this.xMin>x}onRightOfRect(r){return this.xMin>
r.xMax}onRightOf(p){return this.xMin>p.x}aboveY(y){return this.yMax<y}aboveRect(r){return this.yMax<r.yMin}above(p){return this.yMax<p.y}belowY(y){return this.yMin>y}belowRect(r){return this.yMin>r.yMax}below(p){return this.yMin>p.y}addMargin(margin){this.xMin-=margin;this.xMax+=margin;this.yMin-=margin;this.yMax+=margin;return this}addMarginsXY(marginX,marginY){this.xMin-=marginX;this.xMax+=marginX;this.yMin-=marginY;this.yMax+=marginY;return this}addMargins(marginLeft,marginTop,marginRight,marginBottom){this.xMin-=
marginLeft;this.xMax+=marginRight;this.yMin-=marginTop;this.yMax+=marginBottom;return this}pushPath(context){context.rect(this.xMin,this.yMin,this.width,this.height)}draw(context,fill=false,stroke=!fill){context.beginPath();context.rect(this.xMin,this.yMin,this.width,this.height);fill&&context.fill();stroke&&context.stroke()}getVertices(verticesArray,vOffset,indicesArray,iOffset){const n=offset/2;float32Array[offset++]=this.xMin;float32Array[offset++]=this.yMin;float32Array[offset++]=this.xMin;float32Array[offset++]=
this.yMax;float32Array[offset++]=this.xMax;float32Array[offset++]=this.yMin;float32Array[offset++]=this.xMax;float32Array[offset++]=this.yMax;indicesArray[iOffset++]=n;indicesArray[iOffset++]=n+1;indicesArray[iOffset++]=n+2;indicesArray[iOffset++]=n+2;indicesArray[iOffset++]=n+1;indicesArray[iOffset++]=n+3}setRect(rect){this.xMin=rect.xMin;this.xMax=rect.xMax;this.yMin=rect.yMin;this.yMax=rect.yMax;return this}set(left,top,right,bottom){this.yMin=top;this.xMin=left;this.xMax=right;this.yMax=bottom;
return this}moveXY(x,y){this.xMin+=x;this.xMax+=x;this.yMin+=y;this.yMax+=y;return this}move(delta){this.xMin+=delta.x;this.xMax+=delta.x;this.yMin+=delta.y;this.yMax+=delta.y;return this}getPercentPoint(percent){if((percent%=1)<.25)return new Vec2(this.xMin+percent*4*this.width,this.yMin);if(percent<.5)return new Vec2(this.xMax,this.yMin+(percent*4-1)*this.height);if(percent<.75)return new Vec2(this.xMax-(percent*4-2)*this.width,this.yMax);return new Vec2(this.xMin,this.yMax-(percent*4-3)*this.height)}getShape(){return Polygon.Absolute(Vec2.createVec2Array([this.xMin,
this.yMin,this.xMax,this.yMin,this.xMax,this.yMax,this.xMin,this.yMax]))}toString(){return["[",this.xMin,", ",this.yMin,", ",this.xMax,", ",this.yMax,"]"].join("")}static getUnion(rects){let i=rects.length;if(i){let res=rects[--i].clone();while(i--){res.xMin=Math.min(res.xMin,rects[i].xMin);res.xMax=Math.max(res.xMax,rects[i].xMax);res.yMin=Math.min(res.yMin,rects[i].yMin);res.yMax=Math.max(res.yMax,rects[i].yMax)}return res}else return null}static getIntersection(rects){let i=rects.length;if(i){let r=
rects[0],maxLeft=r.xMin,maxTop=r.yMin,minRight=r.xMax,minBottom=r.yMax;while(--i){r=rects[i];if(r.yMin>maxTop)maxTop=r.yMin;if(r.xMin>maxLeft)maxLeft=r.xMin;if(r.xMax<minRight)minRight=r.xMax;if(r.yMax<minBottom)minBottom=r.yMax}if(maxLeft<=minRight&&maxTop<=minBottom)return new Rect(maxLeft,maxTop,minRight,minBottom)}return null}static createFromPoint(p){return new Rect(p.x,p.y,p.x,p.y)}static createFromXY(x,y){return new Rect(x,y,x,y)}static createFromPoints(array){let i=array.length;if(i){let minX=
array[0].x,maxX=minX,minY=array[0].y,maxY=minY,p;while(--i){p=array[i];if(p.x<minX)minX=p.x;else if(p.x>maxX)maxX=p.x;if(p.y<minY)minY=p.y;else if(p.y>maxY)maxY=p.y}return new Rect(minX,minY,maxX,maxY)}}static createFromCenterWidthHeight(center,width,height=width){return Rect.createFromPoint(center).addMarginsXY(width/2,height/2)}}Rect.prototype.glPointsNumber=4;Rect.prototype.glTriangles=2;class Shape{constructor(center){if(center)this.center=center.clone()}get perimeter(){return 0}get area(){return 0}copyCenter(){return this.center.clone()}setCenter(center){this.center.set(center);
return this}setCenterXY(x,y){this.center.setXY(x,y);return this}scale(factor){return this}growDistance(delta){return this}rotate(radians){return this}pushPath(context){}getVertices(verticesArray,vOffset,indicesArray,iOffset){}draw(context,fill=false,stroke=!fill){context.beginPath();this.pushPath(context);fill&&context.fill();stroke&&context.stroke()}intersect(shape){return false}getIntersectionPoints(shape){return[]}contains(point){return false}getRect(){return Rect.createFromPoint(this.center)}getRadius(){return 0}getCircle(){return new Circle(this.center,
this.getRadius())}getPercentPoint(percent){return this.center}closestPointTo(p){return this.center}clone(){return new Shape(this.center)}mirrorVertically(axisY=this.center.y){this.center.mirrorVertically(axisY);return this}mirrorHorizontally(axisX=this.center.x){this.center.mirrorHorizontally(axisX);return this}moveXY(dX,dY){this.center.addXY(dX,dY);return this}move(delta){this.center.add(delta);return this}}Shape.prototype.glPointsNumber=0;Shape.prototype.glTriangles=0;class Circle extends Shape{constructor(center,
radius){super(center);this.radius=radius}get perimeter(){return Circle.PI2*this.radius}get area(){return Math.pow(this.radius,2)*Math.PI}scale(factor){this.radius*=factor;return this}growDistance(delta){this.radius+=delta;return this}relativePointForAngle(radians){return Vec2.createFromAngle(radians,this.radius)}pointForAngle(radians){return Vec2.createFromAngle(radians,this.radius).add(this.center)}pushPath(context){context.arc(this.center.x,this.center.y,this.radius,0,Circle.PI2,false)}draw(context,
fill=false,stroke=!fill){context.beginPath();context.arc(this.center.x,this.center.y,this.radius,0,Circle.PI2,false);fill&&context.fill();stroke&&context.stroke()}getVertices(verticesArray,vOffset,indicesArray,iOffset){const o=vOffset/2;let n=this.glPointsNumber,dA=Circle.PI2/n,a=-dA,i=-1,t;while(++i<n){verticesArray[vOffset++]=(t=Vec2.createFromAngle(a+=dA,this.radius)).x;verticesArray[vOffset++]=t.y;if(i>1){indicesArray[iOffset++]=o;indicesArray[iOffset++]=o+i-1;indicesArray[iOffset++]=o+i}}}get glTriangles(){return this.glPointsNumber-
2}intersect(shape){if(shape instanceof Circle){let d=Vec2.distance(this.center,shape.center);return d<this.radius+shape.radius&&this.radius<d+shape.radius&&shape.radius<d+this.radius}else return shape.intersect(this)}getIntersectionPoints(shape){if(shape instanceof Circle){let trans=Vec2.translation(this.center,shape.center),d2=trans.squareMagnitude,da=Math.acos(d2-shape.radius*shape.radius+this.radius*this.radius)/(2*Math.sqrt(d2)*this.radius),a=trans.angle;return[Vec2.createFromAngle(a+da,this.radius),
Vec2.createFromAngle(a-da,this.radius)]}else return shape.getIntersectionPoints(this)}contains(point){return Vec2.distance(this.center,point)<=this.radius}getRect(){return Rect.createFromXY(this.center.x,this.center.y).addMargin(this.radius)}getPercentPoint(percent){return this.pointForAngle(percent*Circle.PI2)}closestPointTo(p){return Vec2.translation(this.center,p).setMagnitude(this.radius)}getRadius(){return this.radius}getCircle(){return new Circle(this.center,this.radius)}clone(){return new Circle(this.center,
this.radius)}toPolygon(edges,startRadians=0){return Polygon.Regular(this.center,[this.radius],edges,startRadians)}}Circle.prototype.glPointsNumber=16;Circle.PI2=2*Math.PI;Circle.PI_2=2*Math.PI;class Ellipsoid extends Shape{constructor(center,radiusX,radiusY,radians=0){super(center);this.radiusX=radiusX;this.radiusY=radiusY;this.angle=radians}get squareFocusDistance(){return this.radiusX*this.radiusX-this.radiusY*this.radiusY}get focusDistance(){return Math.sqrt(this.squareFocusDistance)}get excentricity(){return this.focusDistance/
this.radiusX}get perimeter(){return Math.PI*Math.sqrt(2*this.squareFocusDistance)}get area(){return this.radiusX*this.radiusY*Math.PI}mirrorHorizontally(axisX=this.center.x){this.radians=-this.radians;return super.mirrorHorizontally(axisX)}mirrorVertically(axisY=this.center.y){this.radians=-this.radians;return super.mirrorVertically(axisY)}scale(factor){this.radiusX*=factor;this.radiusY*=factor;return this}growDistance(delta){this.radiusX+=delta;this.radiusY+=delta;return this}rotate(radians){this.radians+=
radians;return this}setAngle(radians){this.radians=radians;return this}checkRadius(){if(this.radiusX<this.radiusY){[this.radiusX,this.radiusY]=[this.radiusY,this.radiusX];this.setAngle(this.radians+Circle.PI_2)}return this}relativePointForAngle(radians){let r=radians-this.radians;return(new Vec2(this.radiusX*Math.cos(r),this.radiusY*Math.sin(r))).rotate(this.radians)}pointForAngle(radians){return this.relativePointForAngle(radians).add(this.center)}squareRadiusForAngle(radians){return this.relativePointForAngle(radians).squareMagnitude}radiusForAngle(radians){return Math.sqrt(this.squareRadiusForAngle(radians))}pushPath(context){context.ellipse(this.center.x,
this.center.y,this.radiusX,this.radiusY,this.radians,0,Circle.PI2)}draw(context,fill=false,stroke=!fill){context.beginPath();context.ellipse(this.center.x,this.center.y,this.radiusX,this.radiusY,this.radians,0,Circle.PI2);fill&&context.fill();stroke&&context.stroke()}getVertices(verticesArray,vOffset,indicesArray,iOffset){const o=offset/2;let n=this.glPointsNumber-1,dA=Circle.PI2/n,a=0,i=-1;while(++i<n){float32Array[vOffset++]=(t=this.pointForAngle(a+=dA)).x;float32Array[vOffset++]=t.y;if(i>1){indicesArray[iOffset++]=
o;indicesArray[iOffset++]=o+i;indicesArray[iOffset++]=o+i-1}}}get glTriangles(){return this.glPointsNumber-1}contains(point){let p=point.clone().remove(this.center);return this.squareRadiusForAngle(p.angle)>p.squareMagnitude}getRect(){let h,w;if(this.radians){let a=this.radiusX,b=this.radiusY,alpha=this.radians,tanAlpha=Math.tan(alpha),sinAlpha=Math.sin(alpha),cosAlpha=Math.cos(alpha),b_a=b/a,t_xMax=Math.atan(-b_a*tanAlpha),t_yMax=Math.atan(b_a/tanAlpha);h=Math.abs(a*Math.cos(t_yMax)*sinAlpha+b*Math.sin(t_yMax)*
cosAlpha);w=Math.abs(a*Math.cos(t_xMax)*cosAlpha+b*Math.sin(t_xMax)*sinAlpha)}else{h=this.radiusY;w=this.radiusX}return new Rect(this.center.x-w,this.center.y-h,this.center.x+w,this.center.y+h)}getRadius(){return this.radiusX}getPercentPoint(percent){return this.pointForAngle(Circle.PI2*percent+this.radians)}closestPointTo(p){return this.pointForAngle(Vec2.translation(this.center,p).angle)}clone(){return new Ellipsoid(this.center,this.radiusX,this.radiusY,this.radians)}createPolygon(edges){return Polygon.createEllipsoid(this.center,
this.radiusX,this.radiusY,edges,this.radians)}}Ellipsoid.prototype.glPointsNumber=16;let A=Vec2.zero,B=Vec2.zero,C=Vec2.zero,D=Vec2.zero,AB=Vec2.zero,AC=Vec2.zero,AD=Vec2.zero,u=Vec2.zero,CD=Vec2.zero,d=0,BC=Vec2.zero,BD=Vec2.zero;class Line extends Shape{constructor(p0,p1){super(undefined);this.p0=p0.clone();this.p1=p1.clone()}get center(){return A.set(this.p0).add(this.p1).mul(.5)}set center(center){const d=Vec2.translation(this.center,center);this.p0.add(d);this.p1.add(d)}get length(){return Vec2.distance(this.p0,
this.p1)}set length(l){const d=this.vector.setMagnitude((l-this.length)/2);this.p1.add(d);this.p0.remove(d)}get angle(){return Math.atan2(this.p1.y-this.p0.y,this.p1.x,this.p0.x)}set angle(radians){const u=this.vector.mul(.5).setAngle(radians);const c=this.center;this.p0.set(c).remove(u);this.p1.set(c).add(u)}get vector(){return Vec2.translation(this.p0,this.p1)}get directorVect(){return Vec2.translation(this.p0,this.p1).normalize()}get perimeter(){return 2*Vec2.distance(this.p0,this.p1)}setAngle(radians){this.angle=
radians;return this}setLength(length){this.length=length;return this}setP0(p){this.p0.set(p);return this}setP1(p){this.p1.set(p);return this}setPoints(p0,p1){this.p0.set(p0);this.p1.set(p1);return this}setCenter(center){this.center=center;return this}setCenterXY(x,y){const c=this.center;const dX=x-c.x,dY=y-c.y;this.p0.addXY(dX,dY);this.p1.addXY(dX,dY);return this}moveXY(dX,dY){this.p0.addXY(dX,dY);this.p1.addXY(dX,dY);return this}move(delta){this.p0.add(delta);this.p1.add(delta);return this}scale(factor){const u=
this.p1.clone().remove(this.p0).mul(.5*factor);this.p1.add(u);this.p0.remove(u);return this}growDistance(delta){const l=this.length;return this.scale((l+delta)/l)}rotate(radians){this.angle+=radians;return this}mirrorVertically(axisY=(this.p0.y+this.p1.y)/2){this.p0.mirrorVertically(axisY);this.p1.mirrorVertically(axisY);return this}mirrorHorizontally(axisX=(this.p0.x+this.p1.x)/2){this.p0.mirrorHorizontally(axisX);this.p1.mirrorHorizontally(axisX);return this}pushPath(context){context.moveTo(this.p0.x,
this.p0.y);context.lineTo(this.p1.x,this.p1.y)}draw(context,fill=false,stroke=!fill){context.beginPath();context.moveTo(this.p0.x,this.p0.y);context.lineTo(this.p1.x,this.p1.y);fill&&context.fill();stroke&&context.stroke()}getVertices(verticesArray,vOffset,indicesArray,iOffset){const o=offset/2,A=this.p0,B=this.p1;verticesArray[vOffset++]=A.x;verticesArray[vOffset++]=A.y;verticesArray[vOffset++]=B.x;verticesArray[vOffset++]=B.y;indicesArray[iOffset++]=o;indicesArray[iOffset++]=o+1;indicesArray[iOffset++]=
o}intersect(shape){if(shape instanceof Circle){if(shape.contains(this.p0)!=shape.contains(this.p1))return true;const l=this.length;AC.set(shape.center).remove(this.p0);u.set(this.p1).remove(this.p0).mul(1/length);d=Vec2.dotProd(u,AC);return d>=0&&d<=l&&Vec2.squareDistance(u.mul(d).add(this.p0),shape.center)<=shape.radius*shape.radius}else if(shape instanceof Line)if(Vec2.ccw2(AC.set(shape.p0).remove(this.p0),AD.set(shape.p1).remove(this.p0))!==Vec2.ccw(this.p1,shape.p0,shape.p1)){AB.set(this.p1).remove(this.p0);
return Vec2.ccw2(AB,AC)!==Vec2.ccw2(AB,AD)}else return false;else return shape.intersect(this)}getIntersectionPoints(shape){if(shape instanceof Circle){A=this.p0.clone();C=shape.center;u.set(this.p1).remove(A).normalize();let a=u.x*u.x+u.y*u.y,b=2*(u.x*(A.x-C.x)+u.y*(A.y-C.y)),c=A.x*(A.x-2*C.x)+C.x*C.x+A.y*(A.y-2*C.y)+C.y*C.y-radius*radius;d=b*b-4*a*c;if(d==0){d=-b/(2*a);if(d>=0)return A.add(u.mul(d))}else if(d>0){d=Math.sqrt(d);a*=2;let l1=(-b-d)/a,l2=(-b+d)/a;if(l1>=0)if(l2>=0)return[B.set(u).mul(l1).add(A),
A.add(u.mul(l2))];else return[A.add(u.mul(l1))];else if(l2>=0)return[A.add(u.mul(l2))]}else return[]}else if(shape instanceof Line){let p=Line.intersectionPoint(this,shape);if(p.onLine1&&p.onLine2)return[p.point];else return[]}else return shape.getIntersectionPoints(this)}contains(point){return point.equals(this.p0)||point.equals(this.p1)||Vec2.distance(this.p0,point)+Vec2.distance(this.p1,point)==Vec2.distance(this.p0,this.p1)}closestPointTo(p){A=this.p0;u=this.directorVect;AC.set(p).remove(A);d=
Vec2.dotProd(u,AC);return d<0?u.set(A):d<this.length?u.mul(d).add(A):u.set(this.p1)}distanceToPoint(point){return Vec2.distance(this.closestPointTo(point),point)}getNormalVect(left=true){return this.directorVect.rotate(left?-Circle.PI_2:Circle.PI_2)}getRect(){A=this.p0;B=this.p1;let left,top,right,bottom;if(A.x<B.x){left=A.x;right=B.x}else{left=B.x;right=A.x}if(A.y<B.y){top=A.y;bottom=B.y}else{top=B.y;bottom=A.y}return new Rect(left,top,right,bottom)}geRadius(){return Vec2.distance(this.p0,this.p1)*
.5}clone(){return new Line(this.p0,this.p1)}static intersectionPoint(line1,line2){A=line1.p0;C=line2.p0;AB.set(line1.p1).remove(A);CD.set(line2.p1).remove(C);d=CD.y*AB.x-CD.x*AB.y;if(!d)return null;let CA=Vec2.translation(C,A),pos1=(CD.x*CA.y-CD.y*CA.x)/d,pos2=(AB.x*CA.y-AB.y*CA.x)/d;return{point:AB.mul(pos1).add(A),onLine1:pos1>0&&pos1<1,onLine2:pos2>0&&pos2<1}}static createFromPointVector(A,AB){return new Line(A,A.clone().add(AB))}}Line.prototype.glPointsNumber=2;Line.prototype.glPointsNumber=1;
class Point extends Shape{constructor(p){super(p)}pushPath(context){context.rect(this.center.x-.5,this.center.y-.5,1,1)}draw(context,fill=true,stroke=!fill){context.fillRect(this.center.x-1,this.center.y-1,2,2)}getVertices(verticesArray,vOffset,indicesArray,iOffset){const o=offset/2;verticesArray[vOffset++]=this.center.x;verticesArray[vOffset++]=this.center.y;indicesArray[iOffset++]=o;indicesArray[iOffset++]=o;indicesArray[iOffset++]=o}clone(){return new Point(this.center)}}Point.prototype.glPointsNumber=
1;Point.prototype.glPointsNumber=1;let len=0,i=0,res=0,p0=Vec2.zero,p1=Vec2.zero;class Polygon extends Shape{constructor(center,relativePoints){super(center);i=relativePoints.length;this.points=new Array(i);while(i--)this.points[i]=relativePoints[i].clone()}get perimeter(){i=this.points.length-1;res=Vec2.distance(this.points[0],this.points[i]);while(i)res+=Vec2.distance(this.points[i--],this.points[i]);return res}get area(){res=0;i=this.points.length;p1=this.points[0];while(i--){p0=this.points[i];
res+=(p0.x+p1.x)*(p0.y-p1.y);p1=p0}return res/2}scale(factor){i=this.points.length;while(i--)this.points[i].mul(factor);return this}growDistance(delta){i=this.points.length;while(i--)this.points.magnitude+=delta;return this}rotate(radians){i=this.points.length;while(i--)this.points[i].angle+=radians;return this}mirrorVertically(axisY=this.center.y){super.mirrorVertically(axisY);i=this.points.length;while(i--)this.points[i].mirrorVertically();return this}mirrorHorizontally(axisX){super.mirrorHorizontally(axisX);
i=this.points.length;while(i--)this.points[i].mirrorHorizontally();return this}pushPath(context){len=this.points.length;if(len){context.translate(this.center.x,this.center.y);context.moveTo(this.points[0].x,this.points[0].y);i=1;while(i<len)context.lineTo(this.points[i].x,this.points[i++].y);context.lineTo(this.points[0].x,this.points[0].y);context.translate(-this.center.x,-this.center.y)}}draw(context,fill=false,stroke=!fill){context.beginPath();len=this.points.length;if(len){context.translate(this.center.x,
this.center.y);context.moveTo(this.points[0].x,this.points[0].y);i=1;while(i<len)context.lineTo(this.points[i].x,this.points[i++].y);context.closePath();context.translate(-this.center.x,-this.center.y)}fill&&context.fill();stroke&&context.stroke()}get glPointsNumber(){return this.points.length}get glTriangles(){return this.points.length-2}ccw(){const n=this.points.length;let z=0,i,j;for(i=0,j=1;i<n;i++,j++){if(j==n)j=0;z+=(this.points[i].y+this.points[j].y)*(this.points[j].x-this.points[i].x)}return z<=
0}divideConvex(){let polygons=[];let points=this.points.slice(0);let n=points.length;if(n<4)return[new Polygon(this.center,points)];const ccw=this.ccw();let i=0;while(n>3){let prv=points[(i-1+n)%n],cur=points[i],nxt=points[(i+1)%n];while(i<n&&Vec2.ccw(prv,cur,nxt)==ccw){i++;prv=cur;cur=nxt;nxt=points[(i+1)%n]}if(i==n)break;let j=(i-3+n)%n;while(Vec2.ccw(prv,cur,points[j])==ccw&&Vec2.ccw(points[j],points[(j+1)%n],points[(j+2)%n])==ccw)j=(j-1+n)%n;j++;let array=[points[j%n]];j=(j+1)%n;while(j!=i){array.push(points.splice(j,
1)[0]);if(j<i)i--;n--;j=j%n}array.push(points[i]);polygons.push(new Polygon(this.center,array));if(n<4)break}polygons.push(new Polygon(this.center,points));return polygons}getVertices(verticesArray,vOffset,indicesArray,iOffset){const o=vOffset/2,n=this.points.length;let i=0;while(i<n){if(i>1){indicesArray[iOffset++]=o;indicesArray[iOffset++]=o+i-1;indicesArray[iOffset++]=o+i}verticesArray[vOffset++]=this.points[i].x+this.center.x;verticesArray[vOffset++]=this.points[i++].y+this.center.y}}getPoint(index){return this.points[index].clone().add(this.center)}getPoints(){i=
this.points.length;let arr=new Array(i);while(i--)arr[i]=this.points[i].clone().add(this.center);return arr}getLine(index){len=this.points.length;return(new Line(this.points[index++%len],this.points[index%len])).move(this.center)}getRelativeLine(index){len=this.points.length;return new Line(this.points[index++%len],this.points[index%len])}getLines(){len=this.points.length;i=len;let arr=new Array(i);while(i--)arr[i]=(new Line(this.points[i],this.points[(i+1)%len])).move(this.center);return arr}getNormalVectForLine(index){return this.getLine(index).getNormalVect(false)}rotatePointsOrder(delta){if(delta%
1)delta=Math.round(delta);len=this.points.length;i=len;let p=new Array(len);while(i--)p[i]=this.points[(i+delta)%len];i=len;while(i--)this.points[i]=p[i]}getReducedPolygon(distance){let n=this.points.length,points=new Array(len),p,l1,l2,i;for(i=0;i<n;i++){p=this.points[i].clone();l1=i?this.getRelativeLine(i-1):this.getRelativeLine(n-1);l2=this.getRelativeLine(i);l1.move(l1.getNormalVect().mul(distance));l2.move(l2.getNormalVect().mul(distance));points[i]=Line.intersectionPoint(l1,l2)}return new Polygon(this.center,
points)}intersect(shape){let lines=this.getLines(),i=lines.length;if(!i)return false;if(shape instanceof Polygon){let lines2=shape.getLines(),len=lines2.length,l,j;while(i--){l=lines[i];j=len;while(j--)if(lines2[j].intersect(l))return true}}else while(i--)if(lines[i].intersect(shape))return true;return false}getIntersectionPoints(shape){let lines=this.getLines(),i=lines.length,res=[];if(!i)return[];if(shape instanceof Polygon){let lines2=shape.getLines(),len=lines2.length,l,j;while(i--){l=lines[i];
j=len;while(j--)Array.prototype.push.apply(res,lines2[j].getIntersectionPoints(l))}}else while(i--)Array.prototype.push.apply(res,lines[i].getIntersectionPoints(shape));return res}getIntersectionLine(shape,startIndex=0){let lines=this.getLines(),i=lines.length;if(i<=startIndex)return null;if(shape instanceof Polygon){let lines2=shape.getLines(),len=lines2.length,l,j;while(i-- >startIndex){l=lines[i];j=len;while(j--)if(lines2[j].intersect(l))return l}}else while(i-- >startIndex)if(lines[i].intersect(shape))return lines[i];
return null}getIntersectionLines(shape,startIndex=0){let lines=this.getLines(),i=lines.length;let result=[];if(shape instanceof Polygon){let lines2=shape.getLines(),len=lines2.length,l,j;while(i-- >startIndex){l=lines[i];j=len;while(j--)if(lines2[j].intersect(l))result.push(l)}}else while(i-- >startIndex)if(lines[i].intersect(shape))result.push(lines[i]);return result}contains(point){const n=this.points.length;const A=Vec2.zero,B=this.points[0].clone();point=point.clone().remove(this.center);let i,
j;let nb=0;for(i=0;i<n;i++){A.set(B);B.set(this.points[(i+1)%n]);if(A.y>point.y&&B.y>point.y||A.y<point.y&&B.y<point.y||A.x<point.x&&B.x<point.x||A.y==point.y&&B.y<point.y||A.y<point.y&&B.y==point.y||A.y==B.y||A.x>point.x&&B.x<point.x&&Vec2.ccw(point,B,A)||A.x<point.x&&B.x>point.x&&Vec2.ccw(point,A,B))continue;nb++}return nb%2===1}getRect(){let point,i=this.points.length-1;let xmin=this.points[i].x,ymin=this.points[i].y,xmax=xmin,ymax=ymin;while(i--){point=this.points[i];if(point.x<xmin)xmin=point.x;
else if(point.x>xmax)xmax=point.x;if(point.y<ymin)ymin=point.y;else if(point.y>ymax)ymax=point.y}return(new Rect(xmin,ymin,xmax,ymax)).move(this.center)}getPercentPoint(p){let dist=this.perimeter*(p%1),lines=this.getLines(),len=lines.length,l,i;for(i=0;i<len;i++){l=lines[i].length;if(l>dist)return lines[i].getPercentPoint(dist/l);else dist-=l}return this.points[i].add(this.center)}closestPointTo(p){let closest=null,d,D=Number.MAX_SAFE_INTEGER,l=this.getLines(),i=l.length,c;while(i--){c=l[i].closestPointTo(p);
d=Vec2.squareDistance(c,p);if(d<D){closest=c;D=d}}return closest}getRadius(){let r=0,mag,i;for(i=this.points.length-1;i>=0;i--){mag=this.points[i].squareMagnitude;if(mag>r)r=mag}return Math.sqrt(r)}redefineCenter(delta=null){let i=this.points.length;if(!i)return;if(!delta){delta=Vec2.zero;let len=i;while(i--)delta.add(this.points[i]);delta.mul(1/len);i=len}while(i--)this.points[i].remove(delta);return this}clone(){return new Polygon(this.center,this.points)}static Absolute(pointsArray){return(new Polygon(Vec2.ZERO,
pointsArray)).redefineCenter()}static Rectangular(center,width,height){let left=-width*.5,top=-height*.5,right=left+width,bottom=top+height;return new Polygon(center,Vec2.createVec2Array([left,top,right,top,right,bottom,left,bottom]))}static Ellipsoidal(center,radiusX,radiusY,edges,radians=0){let dA=Circle.PI2/edges,a=Circle.PI2,points=new Array(edges),i=edges;while(i--){a-=dA;points[i]=Vec2(radiusX*Math.cos(a),radiusY*Math.sin(a))}return new Polygon(center,points)}static Regular(center,radiusArray,
pointsNumber,startRadians){let dR=Circle.PI2/pointsNumber,angle=startRadians,rLen=radiusArray.length,p=new Polygon(center,[]);p.points=new Array(pointsNumber);if(rLen!==undefined){let i=-1;while(++i<pointsNumber){p.points[i]=Vec2.createFromAngle(angle,radiusArray[i%rLen]);angle+=dR}}else{let i=pointsNumber;while(i--){p.points[i]=Vec2.createFromAngle(angle,radiusArray);angle-=dR}}return p}}class Ray extends Shape{constructor(origin,radians){super(origin);this.angle=radians}get perimeter(){return Infinity}rotate(radians){this.angle+=
radians;return this}mirrorVertically(axisY=this.center.y){super.mirrorVertically(axisY);this.angle=-this.angle;return this}mirrorHorizontally(axisX=this.center.x){super.mirrorHorizontally(axisX);this.angle=Math.PI-this.angle;return this}endPoint(length){return this.center.clone().addXY(Math.cos(this.angle)*length,Math.sin(this.angle)*length)}getLine(length){return Line.createFromPointVector(this.center,Vec2.createFromAngle(this.angle,length))}pushPath(context){const p=this.endPoint(context.canvas.clientWidth+
context.canvas.clientHeight);context.moveTo(this.center.x,this.center.y);context.moveTo(this.center.x,this.center.y);context.lineTo(p.x,p.y)}getVertices(verticesArray,vOffset,indicesArray,iOffset){const o=offset/2,t=this.endPoint(Number.MAX_SAFE_INTEGER);verticesArray[vOffset++]=this.center.x;verticesArray[vOffset++]=this.center.y;verticesArray[vOffset++]=t.x;verticesArray[vOffset++]=t.y;indicesArray[iOffset++]=o;indicesArray[iOffset++]=o+1;indicesArray[iOffset++]=o}intersect(shape){const rect=shape.getRect();
return(new Line(this.center,this.endPoint(Vec2.distance(this.center,shape.center)+rect.width+rect.height))).intersect(shape)}getIntersectionPoints(shape){const rect=shape.getRect();return this.getLine(Vec2.distance(this.center,shape.center)+rect.width+rect.height).getIntersectionPoints(shape)}contains(point){return this.endPoint(Vec2.distance(this.center,point)).equals(point)}getRect(){const endPoint=this.endPoint(Infinity);return new Rect(Math.min(endPoint.x,this.center.x),Math.min(endPoint.y,this.center.y),
Math.max(endPoint.x,this.center.x),Math.max(endPoint.y,this.center.y))}get directorVect(){return Vec2.createFromAngle(this.angle)}closestpointTo(p){let A=this.center,AC=Vec2.translation(A,p),u=this.directorVect,d=Vec2.dotProd(u,AC);return d<0?u.set(A):u.mul(d).add(A)}getRadius(){return Infinity}clone(){return new Ray(this.center,this.angle)}}Ray.prototype.glPointsNumber=2;Ray.prototype.glTrinagles=1;let asm={};let wasmCode=new Uint8Array([0,97,115,109,1,0,0,0,1,189,128,128,128,0,7,96,1,125,1,125,
96,6,125,125,125,125,125,125,1,127,96,4,125,125,125,125,1,127,96,2,125,125,1,125,96,4,125,125,125,125,1,125,96,7,125,125,125,125,125,125,125,1,127,96,8,125,125,125,125,125,125,125,125,1,125,3,142,128,128,128,0,13,1,2,3,3,4,4,4,4,4,4,1,5,6,4,132,128,128,128,0,1,112,0,0,5,131,128,128,128,0,1,0,1,6,129,128,128,128,0,0,7,225,129,128,128,0,14,6,109,101,109,111,114,121,2,0,3,99,99,119,0,0,4,99,99,119,50,0,1,15,115,113,117,97,114,101,77,97,103,110,105,116,117,100,101,0,2,9,109,97,103,110,105,116,117,100,
101,0,3,10,100,111,116,80,114,111,100,117,99,116,0,4,13,118,101,99,116,111,114,80,114,111,100,117,99,116,0,5,23,115,113,117,97,114,101,69,117,99,108,105,100,101,97,110,68,105,115,116,97,110,99,101,0,6,17,101,117,99,108,105,100,101,97,110,68,105,115,116,97,110,99,101,0,7,17,109,97,110,104,97,116,116,97,110,68,105,115,116,97,110,99,101,0,8,16,100,105,97,103,111,110,97,108,68,105,115,116,97,110,99,101,0,9,16,99,105,114,99,108,101,115,73,110,116,101,114,115,101,99,116,0,10,19,99,105,114,99,108,101,76,
105,110,101,73,110,116,101,114,115,101,99,116,0,11,14,108,105,110,101,115,73,110,116,101,114,115,101,99,116,0,12,10,236,132,128,128,0,13,153,128,128,128,0,0,32,2,32,0,147,32,5,32,1,147,148,32,3,32,1,147,32,4,32,0,147,148,94,11,141,128,128,128,0,0,32,0,32,3,148,32,1,32,2,148,94,11,141,128,128,128,0,0,32,0,32,0,148,32,1,32,1,148,146,11,142,128,128,128,0,0,32,0,32,0,148,32,1,32,1,148,146,145,11,141,128,128,128,0,0,32,0,32,2,148,32,1,32,3,148,146,11,141,128,128,128,0,0,32,0,32,3,148,32,1,32,2,148,147,
11,151,128,128,128,0,0,32,2,32,0,147,34,2,32,2,148,32,3,32,1,147,34,2,32,2,148,146,11,152,128,128,128,0,0,32,2,32,0,147,34,2,32,2,148,32,3,32,1,147,34,2,32,2,148,146,145,11,158,128,128,128,0,1,1,127,32,2,32,0,147,32,3,32,1,147,146,168,34,4,32,4,65,31,117,34,4,106,32,4,115,178,11,182,128,128,128,0,1,1,127,32,2,32,0,147,168,34,4,32,4,65,31,117,34,4,106,32,4,115,178,34,2,32,3,32,1,147,168,34,4,32,4,65,31,117,34,4,106,32,4,115,178,34,0,32,2,32,0,94,27,11,178,128,128,128,0,0,32,3,32,0,147,34,3,32,3,148,
32,4,32,1,147,34,3,32,3,148,146,145,34,3,32,2,146,32,5,94,32,3,32,2,32,5,146,93,32,3,32,5,146,32,2,94,113,113,11,173,129,128,128,0,2,3,125,1,127,65,1,33,10,2,64,32,0,32,3,147,34,7,32,7,148,32,1,32,4,147,34,8,32,8,148,146,145,32,2,93,32,0,32,5,147,34,9,32,9,148,32,1,32,6,147,34,9,32,9,148,146,145,32,2,93,115,13,0,65,0,33,10,32,7,32,5,32,3,147,34,5,32,5,32,5,148,32,6,32,4,147,34,5,32,5,148,146,145,34,6,149,34,9,148,32,8,32,5,32,6,149,34,7,148,146,34,5,67,0,0,0,0,93,13,0,32,5,32,6,94,13,0,32,0,32,9,
32,5,148,32,3,146,147,34,0,32,0,148,32,1,32,7,32,5,148,32,4,146,147,34,0,32,0,148,146,32,2,32,2,148,95,33,10,11,32,10,11,237,128,128,128,0,1,4,125,67,0,0,0,0,33,11,2,64,32,4,32,0,147,34,4,32,7,32,1,147,34,10,148,32,5,32,1,147,34,8,32,6,32,0,147,34,9,148,94,32,5,32,2,147,32,7,32,3,147,148,32,5,32,3,147,32,6,32,2,147,148,94,70,13,0,32,2,32,0,147,34,5,32,8,148,32,3,32,1,147,34,1,32,4,148,94,32,5,32,10,148,32,1,32,9,148,94,115,179,33,11,11,32,11,11]);if(WebAssembly)WebAssembly.instantiate(wasmCode,{}).then((wasm)=>
{asm=wasm.instance.exports});if(window){window.utils=window.utils||{};utils.geometry2d={Vec2,Rect,Shape,Circle,Ellipsoid,Line,Point,Polygon,Ray}}else;}
{if(window);else;const KeyState={RELEASED:0,PRESSED:1};const Key={BACKSPACE:8,TAB:9,ENTER:13,SHIFT:16,CTRL:17,ALT:18,CAPS_LOCK:20,ESCAPE:27,SPACE:32,PAGE_UP:33,PAGE_DOWN:34,END:35,HOME:36,LEFT:37,UP:38,RIGHT:39,DOWN:40,PRINT_SCR:44,INSERT:45,DELETE:46,ZERO:48,ONE:49,TWO:50,THREE:51,FOUR:52,FIVE:53,SIX:54,SEVEN:55,EIGHT:56,NINE:57,A:65,B:66,C:67,D:68,E:69,F:70,G:71,H:72,I:73,J:74,K:75,L:76,M:77,N:78,O:79,P:80,Q:81,R:82,S:83,T:84,U:85,V:86,W:87,X:88,Y:89,Z:90,LEFT_WIN:91,RIGH_WIN:92,SELECT:93,NUM_0:96,
NUM_1:97,NUM_2:98,NUM_3:99,NUM_4:100,NUM_5:101,NUM_6:102,NUM_7:103,NUM_8:104,NUM_9:105,MULTIPLY:106,ADD:107,SUBTRACT:109,DECIMAL_POINT:110,DIVIDE:111,F1:112,F2:113,F3:114,F4:115,F5:116,F6:117,F7:118,F8:119,F9:120,F10:121,F11:122,F12:123,NUM_LOCK:144,SCROLL_LOCK:145,SEMI_COLON:186,EQUAL:187,COMMA:188,DASH:189,PERIOD:190,FORWARD_SLASH:191,GRAVE_ACCENT:192,OPEN_BRACKET:219,BACK_SLASH:220,CLOSE_BRACKET:221,SINGLE_QUOTE:222,FN:255,number:256};const MouseEvent={UP:"onmouseup",DOWN:"onmousedown",CLICK:"onclick",
DBCLICK:"ondbclick",MOVE:"onmousemove",ENTER:"onmouseover",EXIT:"onmouseout",CTX_MENU:"oncontextmenu"};const MouseButton={UNKNOWN:0,LEFT:1,MIDDLE:2,RIGHT:3};const KEYS_NUMBER=Key.number;const KEY_STATE=KeyState;const MOUSE_BTN=MouseButton;const fixMouseWhich=(evt)=>{if(!evt.which&&evt.button)evt.which=evt.button%8-evt.button%4===4?MOUSE_BTN.MIDDLE:evt.button%4-evt.button%2===2?MOUSE_BTN.RIGHT:evt.button%2===1?MOUSE_BTN.LEFT:MOUSE_BTN.UNKNOWN};const onKeyEvt=(keyStates,callbacks,state,evt)=>{if(keyStates[evt.keyCode]!==
state){keyStates[evt.keyCode]=state;let len=callbacks.length;for(let i=0;i<len;i++)if(callbacks[i](evt.keyCode,state))evt.preventDefault()}};class InputManager{constructor(element){this.element=element;let keyStates=new Uint8Array(KEYS_NUMBER);for(let i=KEYS_NUMBER-1;i>=0;i--)keyStates[i]=KEY_STATE.RELEASED;let keyboardCallbacks=[];const onKeyUp=onKeyEvt.bind(this,keyStates,keyboardCallbacks,KEY_STATE.RELEASED);const onKeyDown=onKeyEvt.bind(this,keyStates,keyboardCallbacks,KEY_STATE.PRESSED);const getVec=
(evt)=>{let elmtRect=this.element.getBoundingClientRect();return new Vec2(evt.pageX-elmtRect.left,evt.pageY-elmtRect.top)};const onMouseEvt=(callback,evtType,evt)=>{fixMouseWhich(evt);if(callback(evt,evtType,evt.which,getVec(evt)))evt.preventDefault()};this.enableKeyboardListener=function(enable,capturingMode=true){if(enable){if(this.element!=document&&!this.element.hasAttribute("tabindex"))this.element.setAttribute("tabindex",-1);this.element.addEventListener("keydown",onKeyDown,capturingMode);this.element.addEventListener("keyup",
onKeyUp,capturingMode)}else{this.element.removeEventListener("keydown",onKeyDown);this.element.removeEventListener("keyup",onKeyUp)}};this.addKeyCallback=(callback)=>{keyboardCallbacks.push(callback)};this.removeKeyCallback=(callback)=>{keyboardCallbacks.remove(callback)};this.getKeyState=(keyCode)=>keyStates[keyCode];this.setMouseEventsCallback=function(callback){if(callback){let e;for(let evtType in MouseEvent)if(MouseEvent.hasOwnProperty(evtType)){e=MouseEvent[evtType];this.element[e]=onMouseEvt.bind(this,
callback,e)}}else for(let evtType in MouseEvent)if(MouseEvent.hasOwnProperty(evtType))this.element[MouseEvent[evtType]]=null};this.setFocusCallback=(callback)=>{if(callback){this.element.onfocus=(_)=>callback(true);this.element.onblur=(_)=>callback(false)}else{this.element.onfocus=null;this.element.onblur=null}};this.pointerLock=(eventListener)=>{if(eventListener){if(eventListener.pointerLockChange){document.addEventListener("pointerlockchange",eventListener.pointerLockChange,false);document.addEventListener("mozpointerlockchange",
eventListener.pointerLockChange,false);document.addEventListener("webkitpointerlockchange",eventListener.pointerLockChange,false)}if(eventListener.pointerLockError){document.addEventListener("pointerlockerror",eventListener.pointerLockError,false);document.addEventListener("mozpointerlockerror",eventListener.pointerLockError,false);document.addEventListener("webkitpointerlockerror",eventListener.pointerLockError,false)}}if(document.webkitFullscreenElement===this.element||document.mozFullscreenElement===
this.element||document.fullscreenElement===this.element){this.element.requestPointerLock=this.element.requestPointerLock||this.element.mozRequestPointerLock||this.element.webkitRequestPointerLock;this.element.requestPointerLock()}};this.fullScreen=(callback)=>{element.requestFullscreen=element.requestFullscreen||element.mozRequestFullscreen||element.mozRequestFullScreen||element.webkitRequestFullscreen;element.requestFullscreen();if(callback){document.addEventListener("fullscreenchange",callback,
false);document.addEventListener("mozfullscreenchange",callback,false);document.addEventListener("webkitfullscreenchange",callback,false)}}}}class KeyMap{constructor(){let actions=new Array(Key.number);let cb=undefined;const callback=(keyCode,keyState)=>{if(cb){let a=this.getAction(keyCode);return a&&cb(a,keyState)||false}};this.setAction=(keyCode,action)=>{if(keyCode.length)for(let i=0;i<keyCode.length;i++)this.setAction(keyCode[i],action);else if(action==undefined){if(actions[keyCode]!=undefined)actions[keyCode]=
undefined}else actions[keyCode]=action};this.getAction=(keyCode)=>{return actions[keyCode]};this.isKeyDown=(inputManager,action)=>{let code=-1;do{code=actions.indexOf(action,code+1);if(code!==-1)if(inputManager.getKeyState(code)===InputManager.KeyState.DOWN)return true}while(code!==-1);return false};this.getKeys=(action)=>{let codes=[],i=actions.indexOf(action);while(i!==-1){codes.push(i);i=actions.indexOf(action,i+1)}return codes};this.setCallback=(callback)=>{cb=callback};this.enable=function(inputManager){inputManager.addKeyCallback(callback)};
this.disable=function(inputManager){inputManager.removeKeyCallback(callback)}}}if(window){window.utils=window.utils||{};utils.input={KeyState,Key,MouseEvent,MouseButton,InputManager,KeyMap}}else;}
{class PeerConnection{constructor({pcConfig,chName,txConfig}){this.pc=new RTCPeerConnection(pcConfig)}createDataChannel(name,config){return this.pc.createDataChannel(name||"",config)}addTrack(track,...streams){return this.pc.addTrack(track,...streams)}waitDataChannel(){return new Promise((resolve)=>{this.pc.ondatachannel=({channel})=>{this.pc.ondatachannel=null;resolve(channel)}})}waitTrack(){return new Promise((resolve)=>{this.pc.ontrack=(evt)=>{this.ontrack=null;resolve(evt)}})}createOffer(options){return new Promise((resolve,
reject)=>{this.pc.onicecandidate=(evt)=>{if(!evt.candidate)return;this.candidate=evt.candidate;resolve({description:this.pc.localDescription,candidate:this.candidate})};this.pc.createOffer(options).then((desc)=>{this.pc.setLocalDescription(desc)},reject)})}onOfferAnswer({candidate,description}){this.pc.setRemoteDescription(description);this.pc.addIceCandidate(candidate)}createAnswer({candidate,description},options){this.pc.setRemoteDescription(description);this.pc.addIceCandidate(candidate);return new Promise((resolve,
reject)=>{let a=false;this.pc.onicecandidate=(evt)=>{if(!evt.candidate)return;this.candidate=evt.candidate;resolve({description:this.pc.localDescription,candidate:this.candidate})};this.pc.createAnswer(options).then((desc)=>{this.pc.setLocalDescription(desc)},reject)})}}function test3(){var peer1=new PeerConnection;peer1.tx=peer1.createDataChannel("peer 1 -> 2");var peer2=new PeerConnection;peer2.tx=peer2.createDataChannel("peer 2 -> 1");const onMsg=function({data}){alert(`${this.label} >> ${data}`)};
peer1.createOffer().then((desc_cand)=>peer2.createAnswer(desc_cand)).then((desc_cand)=>peer1.onOfferAnswer(desc_cand)).then(()=>peer1.waitDataChannel()).then((channel)=>channel.onmessage=onMsg).then(()=>peer2.waitDataChannel()).then((channel)=>channel.onmessage=onMsg).then((_)=>console.log("finish")).then((_)=>peer1.tx.readyState=="open"||utils.tools.waitForEvent(peer1.tx,"open")).then(peer1.tx.send("Hello"))}window.utils=window.utils||{};window.utils.p2p={PeerConnection}}
utils.tools.polyfill(window,"AudioContext",["webkit"]);
utils.audio={loadSound(audioContext,onResult,onError,url){const request=new XMLHttpRequest;request.open("GET",url,true);request.responseType="arraybuffer";request.onload=function(){context.decodeAudioData(request.response,onResult,onError)};request.send()},getNoteFreq(semitones){return 440*Math.pow(2,noteId-69)},createSinusOscillator(audioContext,freq){let o=audioContext.createOscillator();o.type="sine";o.frequency.value=freq;return o},createSquareOscillator(audioContext,freq){let o=audioContext.createOscillator();
o.type="square";o.frequency.value=freq;return o},createTriangleOscillator(audioContext,freq){let o=audioContext.createOscillator();o.type="triangle";o.frequency.value=freq;return o},createSawToothOscillator(audioContext,freq){let o=audioContext.createOscillator();o.type="sawtooth";o.frequency.value=freq;return o},createCustomOscillator(audioContext,freq,periodicWave){let o=audioContext.createOscillator();o.type="custom";o.frequency.value=freq;o.setPeriodicWave(periodicWave);return o},connectNodes(nodes){let i,
n=nodes.length;for(i=0;i<n-1;i++)nodes[i].connect(nodes[i+1])}};
window["webgl"]={getContext(canvas){return canvas.getContext("webgl2")||canvas.getContext("webgl")||canvas.getContext("experimental-webgl")},initContext(gl){gl.clearColor(0,0,0,1);gl.enable(gl.CULL_FACE);gl.enable(gl.DEPTH_TEST);gl.depthFunc(gl.LEQUAL);gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT)},setAlphaEnabled(gl,enable){gl.blendFunc(gl.SRC_ALPHA,gl.ONE_MINUS_SRC_ALPHA);if(enable)gl.enable(gl.BLEND);else gl.disable(gl.BLEND)},createShader(gl,shaderScript,type){let shader;if(type!=WebGLRenderingContext.VERTEX_SHADER||
type!=WebGLRenderingContext.FRAGMENT_SHADER)switch(type){case "vertex":type=WebGLRenderingContext.VERTEX_SHADER;break;case "fragment":type=WebGLRenderingContext.FRAGMENT_SHADER;break;default:console.error((new Error(`'${type}' is not a valid shader type. only 'vertex' and 'fragment' are accepted as shader type.\n\t\t\t\t\t\tyou can also use VERTEX_SHADER or FRAGMENT_SHADER constants of the WebGLRenderingContext class`)).stack);return}shader=gl.createShader(type);gl.shaderSource(shader,shaderScript);
gl.compileShader(shader);if(!gl.getShaderParameter(shader,gl.COMPILE_STATUS)){console.error((new Error(gl.getShaderInfoLog(shader))).stack);gl.deleteShader(shader);return null}return shader},createProgram(gl,vertexShader,fragmentShader){const prog=gl.createProgram();if(vertexShader.substr)gl.attachShader(prog,webgl.createShader(gl,vertexShader,"vertex"));else gl.attachShader(prog,vertexShader);if(fragmentShader.substr)gl.attachShader(prog,webgl.createShader(gl,fragmentShader,"fragment"));else gl.attachShader(prog,
fragmentShader);gl.linkProgram(prog);if(!gl.getProgramParameter(prog,gl.LINK_STATUS)){console.error((new Error(gl.getProgramInfoLog(prog))).stack);gl.deleteProgram(prog);return}return prog},getAttribLocations(gl,program,names){let result=new Array(names.length);for(let i=0;i<names.length;i++)result[i]=gl.getAttribLocation(program,names[i]);return result},getUniformLocations(gl,program,names){let result=new Array(names.length);for(let i=0;i<names.length;i++)result[i]=gl.getUniformLocation(program,
names[i]);return result},createAttribBuffer(gl,target,srcData,usage=WebGLRenderingContext.STATIC_DRAW,srcOffset=0,length=0){const buffer=gl.createBuffer();gl.bindBuffer(target,buffer);gl.bufferData(target,srcData,usage,srcOffset,length);return buffer},standardFragmentShader:`#version 300 es\nprecision mediump float;\nin vec4 v_color;\nout vec4 outColor;\nvoid main() { outColor = v_color; }\n\t`,createMVMat3:function(tx,ty,rad,scaleX,scaleY){let cos=Math.cos(rad),sin=Math.sin(rad);return[cos*scaleX,
-sin*scaleY,0,sin*scaleX,cos*scaleY,0,tx,ty,1]},translationMat3:function(dX,dY){return[1,0,0,0,1,0,dX,dY,1]},rotationMat3:function(rad){return[cos,-sin,0,sin,cos,0,0,0,1]},scaleMat3:function(scaleX,scaleY){return[scaleX,0,0,0,scaleY,0,0,0,1]},perspectiveMat4:function(fov,aspect,zNear,zFar){const f=Math.tan(Math.PI*.5-.5*fov),rangeInv=1/(zNear-zFar);return[f/aspect,0,0,0,0,f,0,0,0,0,(zNear+zFar)*rangeInv,-1,0,0,zNear*zFar*rangeInv*2,1]},projectionMat4:function(xmin,xmax,ymin,ymax,zNear,zFar){const w=
xmax-xmin,h=ymax-ymin,d=zFar-zNear;return[2/w,0,0,-(xmax+xmin)/w,0,2/h,0,-(ymax+ymin)/h,0,0,-2/d,-(zFar+zNear)/d,0,0,0,1]},identityMat4:function(){return[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]}};
