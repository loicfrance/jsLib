'use strict';import{merge}from"../utils/tools";import{randomColor,HSVtoRGB,RGBToHex}from"../utils/colors";import{Vec2,Point,Line,PI2}from"../utils/geometry2d";import GameObject from"./object";class Particle extends GameObject{constructor(position,renderer,lifeTime=2){super(position);if(renderer)this.renderer=renderer;this.lifeTime=lifeTime}getRect(){return this.getRenderRect()}onFrame(gameManager,dT){super.onFrame(gameManager,dT);if(!gameManager.viewer.visibleRect.overlap(this.getRenderRect().addMargin(10))||
this.lifeTime<=0){this.lifeTime=0;this.kill(gameManager)}else this.lifeTime-=dT}}Particle.prototype.bodyLayer=-1;Particle.prototype.collisionPriority=-1;Particle.prototype.collisionLayers=[];Particle.prototype.living=true;Particle.prototype.renderLayer=0;class ShapedParticle extends Particle{constructor(lifeTime,shape,color){if(!shape)console.log(shape);super();this.shape=shape;this.color=color;this.lifeTime=lifeTime}get position(){return this.shape.center}set position(p){this.shape.center.set(p)}rotate(radians){this.shape.rotate(radians)}scale(factor){this.shape.scale(factor)}getPosition(){return this.shape.center}moveXY(x,
y){this.shape.moveXY(x,y);return this}getRect(){return this.shape.getRect()}getRenderRect(){return this.shape.getRect()}render(ctx){if(this.fill){ctx.fillStyle!==this.color&&(ctx.fillStyle=this.color);this.shape.draw(ctx,true,false)}else{ctx.strokeStyle!==this.color&&(ctx.strokeStyle=this.color);this.shape.draw(ctx,false,true)}}renderGL(handler){handler.gl.uniform1i(handler.colorUniform,this.color);this.shape.glDraw(handler.gl,handler.vertices,handler.glBuffer,handler.positionAttrib,this.stroke)}}
ShapedParticle.prototype.fill=true;class ImageParticle extends Particle{constructor(position,image,lifeTime=2){super(position,null,lifeTime);this.image=image;this.imgW=this.image.width;this.imgH=this.image.height}render(ctx){const w=this.imgW*this.scaleX;h=this.imgH*this.scaleY;if(this.angle){ctx.translate(this.position.x,this.position.y);ctx.rotate(this.angle);ctx.drawImage(this.image,0,0,this.imgW,this.imgH,-w*.5,-h*.5,w,h);ctx.rotate(-this.angle);ctx.translate(-this.position.x,-this.position.y)}else ctx.drawImage(this.image,
0,0,this.imgW,this.imgH,this.position.x-w*.5,this.position.y-h*.5,w,h)}}merge(ImageParticle.prototype,{scaleX:1,scaleY:1,angle:0},true);class ParticleCreator extends GameObject{constructor(rate,max=0){super();this.rate=rate;this.created=0;this.max=max;this.particles=[]}setRate(rate){this.rate=rate}getRate(){return this.rate}setParticlesLifeTime(min,max=min){this.setMinLifeTime(min);this.setMaxLifeTime(max<min?min:max)}setParticlesMinLifeTime(mlt){this.minLifeTime=mlt}setParticlesMaxLifeTime(mlt){this.maxLifeTime=
mlt}getParticlesMinLifeTime(){return this.minLifeTime}getParticlesMaxLifeTime(){return this.maxLifeTime}restart(){this.created=0}stop(){this.created=-1}isRunning(){return this.emited>=0&&(max===0||this.emited<max)}manageParticleOnFrame(particle,dT){}createParticles(gameManager,number){let res=new Array(number);while(number--)res[number]=this.createParticle(gameManager);return res}createParticle(gameManager){let r=gameManager.viewer.visibleRect;return new ShapedParticle(Math.random()*(this.maxLifeTime-
this.minLifeTime)+this.minLifeTime,new Point(new Vec2(r.xMin+Math.random()*r.width,r.yMin+Math.random()*r.height)),randomColor(24))}onFrame(gameManager,dT){super.onFrame(gameManager,dT);let len=this.particles.length,i=len,p;while(i--)if((p=this.particles[i]).lifeTime<=0)this.particles.splice(i,1);else this.manageParticleOnFrame(p,dT);if(this.created>=0){let next=this.created+dT*this.rate,n;if(this.max){if(this.created>=this.max&&len==0)this.kill(gameManager);if(next>this.max)next=this.max;n=Math.floor(next)-
Math.floor(this.created)}else n=Math.floor(next);if(n){let p=this.createParticles(gameManager,n);if(p&&p.length){Array.prototype.push.apply(this.particles,p);gameManager.addObjects(p,false)}}this.created=next;if(!this.max)this.created%=1}}canCollide(object){return false}}ParticleCreator.prototype.minLifeTime=.75;ParticleCreator.prototype.maxLifeTime=1.2;ParticleCreator.prototype.renderLayer=-1;ParticleCreator.prototype.bodyLayer=-1;ParticleCreator.prototype.collisionPriority=-1;ParticleCreator.prototype.collisionLayers=
[];ParticleCreator.prototype.living=true;class ParticleEmitter extends ParticleCreator{constructor(position,rate,max=0){super(rate,max);this.setPosition(position)}setAngles(min,max=min){this.setMinAngle(min);this.setMaxAngle(max)}setMinAngle(min){this.minAngle=min}setMaxAngle(max){this.maxAngle=max}getMinAngle(){return this.minAngle}getMaxAngle(){return this.maxAngle}setEmitDistance(emitDistance){this.emitDistance=emitDistance}getEmitDistance(){return this.emitDistance}setSpeedDampFactor(factor){this.speedDampFactor=
factor}getSpeedDampFactor(){return this.speedDampFactor}setSizeReduceFactor(factor){this.reduceSizeFactor=factor}getSizeReduceFactor(){return this.reduceSizeFactor}rotate(radians){super.rotate(radians);this.minAngle+=radians;this.maxAngle+=radians}getParticleGenerator(){return this.particleGenerator}setParticleGenerator(generator){this.particleGenerator=generator}createParticle(gameManager){let lifeTime=this.maxLifeTime===this.minLifeTime?this.minLifeTime:Math.random()*(this.maxLifeTime-this.minLifeTime)+
this.minLifeTime,spd=this.maxSpeed===this.minSpeed?this.minSpeed:Math.random()*(this.maxSpeed-this.minSpeed)+this.minSpeed,pos=this.getPosition(),angle=this.minAngle===this.maxAngle?this.minAngle:Math.random()*(this.minAngle-this.maxAngle)+this.minAngle,p=this.particleGenerator(lifeTime,pos,angle,spd);if(p)if(spd){let unit=Vec2.createFromAngle(angle);this.emitDistance&&p.move(unit.clone().mul(this.emitDistance));p.speed=unit.mul(spd)}else if(this.emitDistance)p.move(Vec2.createFromAngle(angle,this.emitDistance));
return p}manageParticleOnFrame(particle,dT){let speedFactor=Math.max(0,1-this.speedDampFactor*dT),sizeFactor=Math.max(0,1-this.reduceSizeFactor*dT);speedFactor!==1&&particle.speed&&particle.speed.mul(speedFactor);sizeFactor!==1&&particle.scale(sizeFactor);if(this.particlePositionRelative){let spd=this.getSpeed();if(!spd.isZero())particle.move(spd.clone().mul(dT))}}static standardGenerator(lifeTime,initialPosition,angle,speed){let sv=.5+(speed-this.minSpeed)/(2*(this.maxSpeed-this.minSpeed)),rgb=HSVtoRGB(angle*
180/Math.PI,sv,sv),shape=new Point(initialPosition);if(!shape)console.log("error : shape is null");else return new ShapedParticle(lifeTime,shape,RGBToHex(rgb.r,rgb.g,rgb.b))}}merge(ParticleEmitter.prototype,{minAngle:0,maxAngle:2*Math.PI,minSpeed:300,maxSpeed:400,speedDampFactor:2.5,reduceSizeFactor:1.2,emitDistance:0,particleGenerator:ParticleEmitter.standardGenerator},true);class ParticleExplosion extends ParticleEmitter{constructor(position,number){super(position,number*1E3,number)}}merge(ParticleExplosion.prototype,
{minLifeTime:.1,maxLifeTime:.5,minSpeed:500,maxSpeed:1500,speedDampFactor:2,reduceSizeFactor:3},true);class TraceDrawer{constructor(color,lifeTime){if(color)this.color=color;if(lifeTime)this.particleLifeTime=lifeTime}createParticlesForMovement(obj,from,to){let p=new ShapedParticle(this.particleLifeTime,new Line(from,to),this.color||"#FFF");p.fill=false;return[p]}onMovement(gameManager,obj,from,to){let p=this.createParticlesForMovement(obj,from,to);if(p&&p.length)gameManager.addObjects(p,false)}}export{Particle,
ShapedParticle,ImageParticle,ParticleCreator,ParticleEmitter,ParticleExplosion,TraceDrawer};
