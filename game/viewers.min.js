'use strict';import{Vec2,Rect}from"../utils/geometry2d";import{RenderEvent,renderLayerSort,renderableFilter}from"./manager";class UIElement{constructor(elmt,position,staticPos=false){this.elmt=elmt;this.elmt.className=this.elmt.className+" game_ui";this.position=position?position.clone():null;this.staticPos=!!staticPos}update(viewer){let scaleX=1/viewer.scaleX,scaleY=1/viewer.scaleY;if(this.position&&!isNaN(this.position.x)&&!isNaN(this.position.y)){let pos=this.position.clone();if(!this.staticPos)pos.addXY(-viewer.visibleRect.xMin,
-viewer.visibleRect.yMin);pos.x*=scaleX;pos.y*=scaleY;const canvasStyle=viewer.getCanvasStyle();pos.x+=parseFloat(canvasStyle.left)||0;pos.y+=parseFloat(canvasStyle.top)||0;this.elmt.style.transform=`scale(${scaleX}, ${scaleY}) translate(-50%, -50%)`;this.elmt.style.transformOrigin="left top";this.elmt.style.left=`${Math.round(pos.x)}px`;this.elmt.style.top=`${Math.round(pos.y)}px`}}}const defaultResizeFunction=(viewer,maxW,maxH)=>{const ratio=viewer.visibleRect.ratio;if(maxH*ratio>maxW)maxH=Math.floor(maxW/
ratio);else if(maxH*ratio<maxW)maxW=Math.floor(maxH*ratio);return new Vec2(maxW,maxH)};class Viewer{constructor({context,visibleRect}){let autoResize=false;let onWindowResize=null;let resizeMargin=1;let callback=null;let uiDiv=null;let uiElmts=[];let resizeFunction=defaultResizeFunction;this.context=context||null;this.visibleRect=visibleRect?visibleRect.clone():this.context&&this.context.canvas?new Rect(0,0,this.context.canvas.width,this.context.canvas.height):new Rect(0,0,0,0);this.useAutoResize=
function(use=true,borderMargin=resizeMargin){resizeMargin=borderMargin;if(autoResize&&!use){window.removeEventListener("resize",onWindowResize,false);window.removeEventListener("fullscreenchange",onWindowResize,false);autoResize=false}else if(!autoResize&&use){autoResize=true;if(!onWindowResize)onWindowResize=function(event){const canvas=this.context.canvas,parent=canvas.parentNode,display=getComputedStyle(parent).display;parent.style.display="none";const container=parent.parentNode||parent,containerW=
container.clientWidth,containerH=container.clientHeight;let w=containerW-borderMargin*2,h=containerH-borderMargin*2;const wh=resizeFunction(this,w,h);w=wh.x;h=wh.y;parent.style.display=display;w-=Math.ceil(canvas.offsetWidth-canvas.clientWidth);h-=Math.ceil(canvas.offsetHeight-canvas.clientHeight);this.setCanvasSize(w,h)}.bind(this);window.addEventListener("resize",onWindowResize,false);window.addEventListener("fullscreenchange",onWindowResize,false);onWindowResize(null)}else if(use)onWindowResize(null)};
this.setCallback=function(cb){callback=cb};this.getCallback=function(){return callback};this.setResizeFunction=function(func){resizeFunction=func||defaultResizeFunction};this.setUIDiv=function(divElement){uiDiv=divElement};this.getUIDiv=function(){return uiDiv};this.addUIElement=function(elmt){uiDiv.appendChild(elmt.elmt);uiElmts.push(elmt)};this.removeUIElement=function(elmt){let i=uiElmts.indexOf(elmt);if(i>=0){uiElmts.splice(i,1);uiDiv.removeChild(elmt.elmt)}};this.updateUI=function(){let i=uiElmts.length;
while(i--)uiElmts[i].update(this)};if(context)this.setUIDiv(context.canvas.parentNode)}setCanvasSize(width,height){const canvas=this.context.canvas,parent=canvas.parentNode;canvas.style.width=`${width}px`;canvas.style.height=`${height}px`;parent.style.width=`${canvas.offsetWidth}px`;parent.style.height=`${canvas.offsetHeight}px`;this.updateTransform();if(this.getCallback())this.getCallback()(RenderEvent.CANVAS_RESIZE,this.context)}setCanvasResolution(width,height){this.context.canvas.width=width;
this.context.canvas.height=height;this.updateTransform()}getCanvasStyle(){return getComputedStyle(this.context.canvas)}get scaleX(){return this.visibleRect.width/parseInt(this.getCanvasStyle().width)}get scaleY(){return this.visibleRect.height/parseInt(this.getCanvasStyle().height)}updateTransform(){this.context.setTransform(this.context.canvas.width/this.visibleRect.width,0,0,this.context.canvas.height/this.visibleRect.height,this.visibleRect.xMin,this.visibleRect.yMin);this.updateUI()}pixelToGameCoordinatesTransform(pixelCoords,
out=Vec2.zero){return out.setXY(pixelCoords.x*this.scaleX+this.visibleRect.xMin,pixelCoords.y*this.scaleY+this.visibleRect.yMin)}gameToPixelCoordinatesTransform(gameCoords,out=Vec2.zero){return out.setXY((gameCoords.x-this.visibleRect.xMin)/this.scaleX,(gameCoords.y-this.visibleRect.yMin)/this.scaleY)}setVisibleRect(rect){this.visibleRect.setRect(rect);this.updateTransform()}render(gameManager,objects){}}class StandardViewer extends Viewer{constructor(parameters){if(!parameters.context&&parameters.canvas)parameters.context=
parameters.canvas.getContext("2d");super(parameters)}render(gameManager,objects){let rect=this.visibleRect,objs,ctx=this.context,l,i,callback=this.getCallback();ctx.clearRect(rect.xMin,rect.yMin,rect.xMax,rect.yMax);if(callback){ctx.save();callback(RenderEvent.RENDER_BEGIN,ctx)}objs=objects.sort(renderLayerSort);if(!(i=objs.length))return;while(i&&objs[--i].renderLayer<0);if(i>=0){do if(!objs[i].isOutOfRect(rect))objs[i].render(ctx);while(i--)}if(callback){callback(RenderEvent.RENDER_END,ctx);ctx.restore()}}setImageSmoothingEnabled(enabled){this.context.imageSmoothingEnabled=
enabled}}class StandardDifferedViewer extends StandardViewer{constructor(parameters){super(parameters);this.hidden_canvas=this.context.canvas.cloneNode(false);this.hidden_context=this.hidden_canvas.getContext("2d")}setCanvasSize(width,height){this.hidden_canvas.style.width=width;this.hidden_canvas.style.height=height;super.setCanvasSize(width,height);if(this.getCallback())this.getCallback()(RenderEvent.CANVAS_RESIZE,this.context)}updateTransform(){const temp=this.context;this.context=this.hidden_context;
super.updateTransform();this.context=temp}setCanvasResolution(width,height){this.context.canvas.width=width;this.context.canvas.height=height;this.hidden_canvas.width=width;this.hidden_canvas.height=height}render(gameManager,objects){const temp=this.context,w=this.context.canvas.clientWidth,h=this.context.canvas.clientHeight;this.context=this.hidden_context;super.render(gameManager,objects);this.context=temp;let rect=this.visibleRect;this.context.clearRect(rect.xMin,rect.yMin,rect.xMax,rect.yMax);
this.context.drawImage(this.hidden_canvas,0,0,w,h,0,0,w,h)}setImageSmoothingEnabled(enabled){super.setImageSmoothingEnabled(enabled);const temp=this.context;this.context=this.hidden_context;super.setImageSmoothingEnabled(enabled);this.context=temp}}class WebGLViewer extends Viewer{constructor(parameters){if(!parameters.context&&parameters.canvas)parameters.context=webgl.getContext(parameters.canvas);super(parameters);const gl=this.gl;webgl.initContext(gl);this.bgColor=[0,0,0,1]}updateTransform(){this.context.viewport(0,
0,this.context.canvas.width,this.context.canvas.height);this.updateUI()}get gl(){return this.context}setBgColor(red,green,blue,alpha){this.bgColor[0]=red;this.bgColor[1]=green;this.bgColor[2]=blue;this.bgColor[3]=alpha}useFrameBuffer(frameBufferShaderProgram,samplersLocations){this.frameBuffer=this.context.createFramebuffer();this.context.bindFramebuffer(this.context.FRAMEBUFFER,this.frameBuffer);this.frameProgram=frameBufferShaderProgram;this.frameSamplersLocs=samplersLocations}render(gameManager,
objects){const obj=objects.filter(renderableFilter),gl=this.context;let n=obj.length;gl.clearColor(this.bgColor[0],this.bgColor[1],this.bgColor[2],this.bgColor[3]);gl.clear(this.context.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);if(this.callback)this.callback(RenderEvent.RENDER_BEGIN,gl);if(this.frameBuffer)gl.bindFramebuffer(gl.FRAMEBUFFER,this.frameBuffer);while(n--)obj[n].render(gl);if(this.frameBuffer){gl.useProgram(this.frameProgram);gl.uniform1i(this.frameSamplersLocs[0],gl.COLOR)}if(this.callback)this.callback(RenderEvent.RENDER_END,
gl)}}export{UIElement,Viewer,StandardViewer,StandardDifferedViewer,WebGLViewer};
