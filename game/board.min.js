'use strict';import{Vec2,Rect}from"../utils/geometry2d";import GameObject from"./object";class Board extends GameObject{constructor(position,columns,lines,cellWidth,cellHeight){super(position);this.lines=lines;this.columns=columns;this.cellWidth=cellWidth;this.cellHeight=cellHeight;this.occupationMap=new Array(lines);let i,j;for(i=0;i<lines;i++){this.occupationMap[i]=new Array(columns);for(j=0;j<columns;j++)this.occupationMap[i][j]=0}this.boardObjects=[]}get boardRect(){return Rect.createFromCenterWidthHeight(this.position,
this.boardWidth,this.boardHeight)}get boardWidth(){return this.cellWidth*this.columns}get boardHeight(){return this.cellHeight*this.lines}getRect(){return Rect.getUnion([this.boardRect,super.getRect()])}getCellRect(column,line){let left=this.position.x+(column-this.columns*.5)*this.cellWidth,top=this.position.y+(line-this.lines*.5)*this.cellHeight;return new Rect(left,top,left+this.cellWidth,top+this.cellHeight)}getCellCenter(column,line){let dX=(this.columns*.5-.5-column)*this.cellWidth,dY=(this.lines*
.5-.5-line)*this.cellHeight;return this.position.clone().addXY(-dX,-dY)}getColumn(gameX){return Math.floor(this.columns*.5+(gameX-this.position.x)/this.cellWidth)}getLine(gameY){return Math.floor(this.lines*.5+(gameY-this.position.y)/this.cellHeight)}getCellIndices(gamePos){return new Vec2(this.getColumn(gamePos.x),this.getLine(gamePos.y))}renderGrid(context,color){context.strokeStyle=color;let r=this.boardRect;let t=r.xMin;context.beginPath();while(t<=r.xMax){context.moveTo(t,r.yMin);context.lineTo(t,
r.yMax);t+=this.cellWidth}t=r.yMin;while(t<=r.yMax){context.moveTo(r.xMin,t);context.lineTo(r.xMax,t);t+=this.cellHeight}context.stroke()}scale(factor){super.scale(factor);this.cellWidth*=factor;this.cellHeight*=factor}addBoardObject(obj){if(this.boardObjects.indexOf(obj)>=0)return;this.boardObjects.push(obj)}removeBoardObject(obj){const i=this.boardObjects.indexOf(obj);if(i>=0)this.boardObjects.remove(obj)}clearOccupationObjects(){this.boardObjects=[]}getObjectsOnCell(column,line){return this.boardObjects.filter((o)=>
this.getCellIndices(o.position).equalsXY(column,line))}isOccupied(column,line){if(this.isNativeOccupied(column,line))return true;else return this.getOccupationMap()[line][column]==1}isNativeOccupied(column,line){return column<this.columns&&line<this.lines&&this.occupationMap[line][column]==1}getNativeOccupationMap(){let i=this.lines,j;const map=new Array(i);while(i--){j=this.columns;map[i]=new Array(j);while(j--)map[i][j]=this.occupationMap[i][j]}return map}getOccupationMap(){const map=this.getNativeOccupationMap();
let m=this.occupationMap;this.occupationMap=map;let i=this.boardObjects.length,obj,cell;while(i--){obj=this.boardObjects[i];if(!obj.occupationSubMap)continue;cell=this.getCellIndices(obj.position);this.addOccupation(cell.x,cell.y,obj.occupationSubMap)}this.occupationMap=m;return map}setOccupation(column,line,occupated){if(column<0&&column>=this.columns&&line<0&&line>=this.lines)return false;this.occupationMap[line][column]=occupated?1:0;return true}addOccupation(column,line,occupationSubMap){let subH=
occupationSubMap.length,subW;let top=line-Math.floor((subH-1)/2),left;let i,j;for(i=0;i<subH;i++){subW=occupationSubMap[i].length;left=column-Math.floor((subW-1)/2);for(j=0;j<subW;j++){if(top+i<0||top+1>=this.rows||left+j<0||left+j>=this.columns)continue;this.occupationMap[top+i][left+j]=occupationSubMap[i][j]?1:0}}}addOccupations(columns,lines,occupationSubMaps){let i=Math.min(columns.length,lines.length,occupationSubMaps.length);while(i--)this.addOccupation(columns[i],lines[i],occupationSubMaps[i])}clearOccupation(){for(let i=
0,j;i<this.lines;i++)for(j=0;j<this.columns;j++)this.occupationMap[i][j]=0}onDimensionsChange(){let newMap=new Array(this.lines);let oldHeight=this.occupationMap.length,oldWidth;let i,j;for(i=Math.min(oldHeight,this.lines)-1;i>=0;i--){newMap=new Array(this.columns);oldWidth=this.occupationMap[i].length;for(j=Math.min(oldWidth,this.columns)-1;j>=0;j--)newMap[i][j]=this.occupationMap[i][j];for(j=oldWidth;j<this.columns;j++)newMap[i][j]=0}for(i=oldHeight;i<this.lines;i++)for(j=0;j<this.columns;j++)newMap[i][j]=
0}heatMap(start,heatStart){const map=this.getOccupationMap();const m=this.occupationMap;this.occupationMap=map;const heatMap=this.nativeHeatMap(start,heatStart);this.occupationMap=m;return heatMap}nativeHeatMap(start,heatStart){const map=this.occupationMap;let i=this.lines,j,list,newFifo,p,len;const heatMap=new Array(i);while(i--){j=this.columns;heatMap[i]=new Array(j);while(j--)heatMap[i][j]=map[i][j]?-1:0}list=[];newFifo=[start];heatMap[start.y][start.x]=heatStart;while(newFifo.length){list=newFifo;
newFifo=[];len=list.length;i=-1;while(++i<len){p=list[i];if(p.y>0&&map[p.y-1][p.x]===0&&heatMap[p.y-1][p.x]===0){heatMap[p.y-1][p.x]=heatMap[p.y][p.x]-1;if(heatMap[p.y][p.x]>2)newFifo.push(p.clone().addXY(0,-1))}if(p.y<this.lines-1&&map[p.y+1][p.x]===0&&heatMap[p.y+1][p.x]===0){heatMap[p.y+1][p.x]=heatMap[p.y][p.x]-1;if(heatMap[p.y][p.x]>2)newFifo.push(p.clone().addXY(0,1))}if(p.x>0&&map[p.y][p.x-1]===0&&heatMap[p.y][p.x-1]===0){heatMap[p.y][p.x-1]=heatMap[p.y][p.x]-1;if(heatMap[p.y][p.x]>2)newFifo.push(p.clone().addXY(-1,
0))}if(p.x<this.columns-1&&map[p.y][p.x+1]===0&&heatMap[p.y][p.x+1]===0){heatMap[p.y][p.x+1]=heatMap[p.y][p.x]-1;if(heatMap[p.y][p.x]>2)newFifo.push(p.clone().addXY(1,0))}}}return heatMap}leePath(start,end){const map=this.getOccupationMap();if(map[end.y][end.x])return[];let heatMap=new Array(this.lines),i,j,list,newFifo,p,len;for(i=0;i<this.lines;i++){heatMap[i]=new Array(this.columns);for(j=0;j<this.columns;j++)heatMap[i][j]=map[i][j]?-1:0}list=[];newFifo=[start];heatMap[start.y][start.x]=1;while(newFifo.length&&
heatMap[end.y][end.x]==0){list=newFifo;newFifo=[];len=list.length;i=-1;while(++i<len){p=list[i];if(p.y>0&&map[p.y-1][p.x]==0&&heatMap[p.y-1][p.x]==0){heatMap[p.y-1][p.x]=heatMap[p.y][p.x]+1;newFifo.push(p.clone().addXY(0,-1))}if(p.y<this.lines-1&&map[p.y+1][p.x]==0&&heatMap[p.y+1][p.x]==0){heatMap[p.y+1][p.x]=heatMap[p.y][p.x]+1;newFifo.push(p.clone().addXY(0,1))}if(p.x>0&&map[p.y][p.x-1]==0&&heatMap[p.y][p.x-1]==0){heatMap[p.y][p.x-1]=heatMap[p.y][p.x]+1;newFifo.push(p.clone().addXY(-1,0))}if(p.x<
this.columns-1&&map[p.y][p.x+1]==0&&heatMap[p.y][p.x+1]==0){heatMap[p.y][p.x+1]=heatMap[p.y][p.x]+1;newFifo.push(p.clone().addXY(1,0))}}}let heat=heatMap[end.y][end.x];if(heat!=0){let path=new Array(heat-1);p=end.clone();let lastDir=0;let nextDir=0;while(heat!=1){path[--heat-1]=p.clone();if(p.y>0&&heatMap[p.y-1][p.x]==heat)nextDir=1;if(p.y<this.lines-1&&heatMap[p.y+1][p.x]==heat)if(lastDir==0||nextDir==lastDir)nextDir=2;if(p.x>0&&heatMap[p.y][p.x-1]==heat)if(lastDir==0||nextDir==lastDir)nextDir=3;
if(p.x<this.columns-1&&heatMap[p.y][p.x+1]==heat)if(lastDir==0||nextDir==lastDir)nextDir=4;switch(nextDir){case 1:p.addXY(0,-1);break;case 2:p.addXY(0,1);break;case 3:p.addXY(-1,0);break;case 4:p.addXY(1,0);break}lastDir=nextDir}return path}else return[]}aStarPath(start,end,allowDiagonals=true){const map=this.getOccupationMap();let openList=[],openListFG=[],closeList=[],closeListF=[],n,i,j,minF,minI,q,successors,f,g,q_fg,skip,finish=false,distance=Vec2.squareDistance;openList.push(start);openListFG.push(new Vec2(0,
0));while((n=openList.length)>0&&!finish){minF=openListFG[0].x;minI=0;i=n;while(--i)if(openListFG[i].x<minF){minI=i;minF=openListFG[i].x}q=openList.splice(minI,1)[0];q_fg=openListFG.splice(minI,1)[0];successors=[];i=0;if(q.y>0&&map[q.y-1][q.x]==0){i+=1;successors.push(new Vec2(q.x,q.y-1))}if(q.x>0&&map[q.y][q.x-1]==0){i+=2;successors.push(new Vec2(q.x-1,q.y))}if(q.y<this.lines-1&&map[q.y+1][q.x]==0){i+=4;successors.push(new Vec2(q.x,q.y+1))}if(q.x<this.columns-1&&map[q.y][q.x+1]==0){i+=8;successors.push(new Vec2(q.x+
1,q.y))}if(allowDiagonals){if(i%4==3&&map[q.y-1][q.x-1]==0)successors.push(new Vec2(q.x-1,q.y-1));if(i%2==1&&i>8&&map[q.y-1][q.x+1]==0)successors.push(new Vec2(q.x+1,q.y-1));if((i>>1)%4==3&&map[q.y+1][q.x-1]==0)successors.push(new Vec2(q.x-1,q.y+1));if(i>>2==3&&map[q.y+1][q.x+1]==0)successors.push(new Vec2(q.x+1,q.y+1))}i=successors.length;while(i--){if(successors[i].x<0||successors[i].x>=this.columns||successors[i].y<0||successors[i].y>=this.rows)continue;if(map[successors[i].y][successors[i].x]!=
0)continue;if(successors[i].equals(end)){closeList.push(q);closeList.push(end);finish=true;break}j=n-1;g=q_fg.y+distance(q,successors[i]);f=g+distance(successors[i],end);while(j--)if(openList[j].equals(successors[i]))if(f>openListFG[j].x)skip=true;if(skip){skip=false;continue}j=closeList.length;while(j--)if(closeList[j].equals(successors[i]))if(f>closeListF[i])skip=true;if(skip){skip=false;continue}openList.push(successors[i]);openListFG.push(new Vec2(f,g))}if(!finish){closeList.push(q);closeListF.push(q_fg.x)}}return closeList}}
Board.prototype.renderLayer=0;Board.prototype.bodyLayer=-1;Board.prototype.collisionPriority=-1;Board.prototype.collisionLayers=[];Board.prototype.living=false;export default Board;
