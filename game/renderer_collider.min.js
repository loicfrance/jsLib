'use strict';import{Rect,Vec2}from"../utils/geometry2d";import{merge}from"../utils/tools";class ObjectRenderer{constructor(){}setPosition(pos){return this}rotate(radians){}scale(factor){}render(context2d){}getRect(){return null}getRadius(){return 0}}class ShapedObjectRenderer extends ObjectRenderer{constructor(shape,color="#FFF"){super();this.shape=shape.clone();this.color=color}setPosition(pos){this.shape.setCenter(pos);return this}rotate(radians){this.shape.rotate(radians)}scale(factor){this.shape.scale(factor)}getColor(){return this.color}setColor(color){this.color=
color}getShape(){return this.shape}setShape(shape){this.shape=shape.clone()}render(context2d){if(!this.color.substr){let c=this.color.toString(16);if(c.length<6)c="0".repeat(6-c.length)+c;this.color="#"+c}this.fill&&(context2d.fillStyle=this.color);this.stroke&&(context2d.strokeStyle=this.color);this.shape.draw(context2d,this.fill,this.stroke)}renderGL(handler){if(this.color.substr){let c=0;switch(this.color.length){case 4:c=255;case 5:c+=parseInt(this.color.substr(1,1),16)*17<<24+parseInt(this.color.substr(2,
1),16)*17<<16+parseInt(this.color.substr(3,1),16)*17<<8+parseInt(this.color.substr(4,1),16)*17;break;case 7:c=255;case 9:c+=parseInt(this.color.substr(1,1),16)<<24+parseInt(this.color.substr(3,1),16)<<16+parseInt(this.color.substr(5,1),16)<<8+parseInt(this.color.substr(7,1),16);break;default:console.stack(this.color+" is not a valid color")}}handler.gl.uniform1i(handler.colorUniform,this.color);handler.gl.bindBuffer(handler.glBuffer);let points=this.shape.glSetVertices(handler.vertices);handler.gl.bufferData(handler.glBuffer,
handler.vertices,handler.gl.STATIC_DRAW);gl.vertexAttribPointer(handler.positionAttrib,2,gl.FLOAT,false,0,0);gl.drawArrays(this.stroke?gl.LINE_LOOP:gl.TRIANGLE_FAN,0,points)}getRect(){return this.shape.getRect()}getRadius(){return this.shape.getRadius()}}ShapedObjectRenderer.prototype.fill=true;ShapedObjectRenderer.prototype.stroke=false;class ImageObjectRenderer extends ObjectRenderer{constructor(image,clipRect=new Rect(0,0,image.width,image.height)){super();this.image=image;this.position=Vec2.zero;
this.clipRect=clipRect}setPosition(pos){this.position.set(pos);return this}rotate(radians){this.angle+=radians}scale(factor){this.scaleX*=factor;this.scaleY*=factor}getImage(){return this.image}setImage(image){this.image=image}setImageClipRect(clipRect){this.clipRect.setRect(clipRect)}render(context2d){if(!this.image.complete)return;const w=this.clipRect.width,h=this.clipRect.height,ws=w*this.scaleX,hs=h*this.scaleY;if(this.angle){context2d.translate(this.position.x,this.position.y);context2d.rotate(this.angle);
context2d.drawImage(this.image,this.clipRect.xMin,this.clipRect.yMin,w,h,-ws*.5,-hs*.5,ws,hs);context2d.rotate(-this.angle);context2d.translate(-this.position.x,-this.position.y)}else context2d.drawImage(this.image,this.clipRect.xMin,this.clipRect.yMin,w,h,this.position.x-ws*.5,this.position.y-hs*.5,ws,hs)}renderGL(handler){}getRect(){return Rect.createFromCenterWidthHeight(this.position,this.clipRect.width*this.scaleX,this.clipRect.height*this.scaleY)}getRadius(){const r=this.getRect();return Math.max(r.width,
r.height)}}merge(ImageObjectRenderer.prototype,{angle:0,scaleX:1,scaleY:1});class WebGLObjectRenderer extends ObjectRenderer{constructor(shaderProgram){super();this.shaderProgram=shaderProgram}setPosition(pos){return this}rotate(radians){}scale(factor){}render(glContext){glContext.useProgram(this.shaderProgram)}}class WebGL2dTransformableObjectRenderer extends WebGLObjectRenderer{constructor(shaderProgram){super();this.shaderProgram=shaderProgram;this.transformMatrices=[[1,0,0,0,1,0,0,0,1],[1,0,0,
0,1,0,0,0,1],[1,0,0,0,1,0,0,0,1]]}get translationMatrix(){return this.transformMatrices[0]}get rotationMatrix(){return this.transformMatrices[1]}get scaleMatrix(){return this.transformMatrices[2]}setPosition(pos){this.transformMatrices[0][2]=pos.x;this.transformMatrices[0][5]=pos.y;return this}rotate(radians){const c=Math.cos(radians),s=Math.sin(radians);const a=this.transformMatrices[1][0],b=this.transformMatrices[1][3];this.transformMatrices[1][0]=this.transformMatrices[1][4]=a*c-b*s;this.transformMatrices[1][1]=
-(this.transformMatrices[1][3]=a*s+b*c)}scale(factor){this.transformMatrices[2][0]*=factor;this.transformMatrices[2][4]*=factor}}class MultiRenderersObjectRenderer extends ObjectRenderer{constructor(renderers){super();this.renderers=renderers;this.renderersNumber=renderers.length;this.position=Vec2.zero}setPosition(pos){this.position.set(pos);let i=this.renderersNumber;while(i--)this.renderers[i].setPosition(pos);return this}updateRenderersNumber(){this.renderersNumber=this.renderers.length}rotate(radians){let i=
this.renderersNumber;while(i--)this.renderers[i].rotate(radians)}scale(factor){let i=this.renderersNumber;while(i--)this.renderers[i].scale(factor)}render(context2d){let i=-1,n=this.renderersNumber;while(++i<n)this.renderers[i].render(context2d)}renderGL(handler){let i=-1,n=this.renderersNumber;while(++i<n)this.renderers[i].renderGL(handler)}getRect(){if(this.renderersNumber==0)return Rect.createFromPoint(this.position);let rects=[],i=this.renderersNumber,r;while(i--){r=this.renderers[i].getRect();
if(r)rects.push(r)}return Rect.getUnion(rects)}getRadius(){if(this.renderersNumber==0)return 0;let max=0,i=this.renderersNumber,r;while(i--){r=this.renderers[i].getRadius();if(r>max)max=r}return max}addRenderer(renderer){this.renderers.push(renderer);this.updateRenderersNumber()}removeRenderer(renderer){const i=this.renderers.indexOf(renderer);if(i>=0){this.renderers.splice(i,i+1);this.updateRenderersNumber()}}}class ObjectCollider{constructor(){}setPosition(pos){return this}scale(factor){}collidesInside(collider){return false}prepareCollision(position){this.setPosition(position)}finishCollision(){}collides(collider){return false}render(context){}}
ObjectCollider.prototype.activated=true;ObjectCollider.prototype.physic=false;class Object2dCollider extends ObjectCollider{constructor(rect){super();this.rect=rect.clone()}setPosition(pos){this.rect.setCenter(pos);return this}rotate(radians){}getRadius(){return 0}getRect(){return this.rect}render(context2d){this.rect.draw(context2d)}}class ShapedObject2dCollider extends Object2dCollider{constructor(shape){super(shape.getRect());this.shape=shape.clone()}setPosition(pos){this.rect.setRect(this.shape.setCenter(pos).getRect());
return this}rotate(radians){this.shape.rotate(radians)}scale(factor){this.shape.scale(factor)}getShape(){return this.shape}getCollisionShape(){return this.getShape()}setShape(shape){this.shape=shape.clone()}collides(collider){if(collider instanceof ShapedObject2dCollider){if(!collider.rect.overlap(this.rect))return false;const shape=collider.getCollisionShape();return this.collidesInside(collider)&&shape.contains(this.shape.center)||collider.collidesInside(this)&&this.shape.contains(shape.center)||
this.shape.intersect(shape)}else return collider instanceof Object2dCollider&&collider.collides(this)}getRect(){return this.rect.setRect(this.shape.getRect())}getRadius(){return this.shape.getRadius()}render(context2d){super.render(context2d);this.shape.draw(context2d)}}class AABBObject2dCollider extends ShapedObject2dCollider{constructor(shape){super(shape)}getCollisionShape(){return this.rect.getShape()}collides(collider){if(collider instanceof AABBObject2dCollider)return collider.rect.overlap(this.rect)&&
(this.collidesInside(collider)||!collider.rect.containsRect(this.rect))&&(collider.collidesInside(this)||!this.rect.containsRect(collider.rect));else return collider instanceof Object2dCollider&&collider.collides(this)}getRadius(){return Math.sqrt(this.rect.width*this.rect.width+this.rect.height*this.rect.height)*.5}}class CircularObject2dCollider extends ShapedObject2dCollider{constructor(circle){super(circle)}get circle(){return this.shape}set circle(circle){this.shape=circle}getCollisionShape(){return new this.shape.getCircle}collides(collider){if(collider instanceof
CircularObject2dCollider){const d=Vec2.distance(this.shape.center,collider.shape.center);return d<this.shape.radius+collider.shape.radius&&(!this.collidesInside(collider)&&d+this.shape.radius>collider.shape.radius)||!collider.collidesInside(this)&&d+collider.shape.radius>this.shape.radius}else return collider instanceof Object2dCollider&&collider.collides(this)}}export{ObjectRenderer,ShapedObjectRenderer,ImageObjectRenderer,WebGLObjectRenderer,MultiRenderersObjectRenderer,WebGL2dTransformableObjectRenderer,
MultiRenderersObjectRenderer,ObjectCollider,Object2dCollider,ShapedObject2dCollider,AABBObject2dCollider,CircularObject2dCollider};
