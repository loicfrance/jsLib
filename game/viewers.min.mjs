'use strict';import{Vec2,Rect}from"../geometry2d/geometry2d.mjs";import{renderLayerSort,renderableFilter}from"./manager.mjs";const RenderEvent={RENDER_BEGIN:6,RENDER_END:7,CANVAS_RESIZE:8};class UIElement{constructor(elmt,position,staticPos=false){this.elmt=elmt;this.elmt.className=this.elmt.className+" game_ui";this.position=position?position.clone():null;this.staticPos=!!staticPos;this.scale=1;this.anchor=new Vec2(.5,.5)}update(viewer){let scaleX=this.scale/viewer.scaleX,scaleY=this.scale/viewer.scaleY;
if(this.position&&!isNaN(this.position.x)&&!isNaN(this.position.y)){let pos=this.position.clone();if(!this.staticPos)pos.addXY(-viewer.visibleRect.xMin,-viewer.visibleRect.yMin);pos.x*=scaleX;pos.y*=scaleY;const canvasStyle=viewer.getCanvasStyle();pos.x+=parseFloat(canvasStyle.left)||0;pos.y+=parseFloat(canvasStyle.top)||0;const translate=this.anchor.clone().mul(-100).roundedVec(4);this.elmt.style.transform=`scale(${scaleX}, ${scaleY}) translate(${translate.x}%, ${translate.y}%)`;this.elmt.style.transformOrigin=
"left top";this.elmt.style.left=`${Math.round(pos.x)}px`;this.elmt.style.top=`${Math.round(pos.y)}px`}}}const defaultResizeFunction=(viewer,maxW,maxH)=>{const ratio=viewer.visibleRect.ratio;if(maxH*ratio>maxW)maxH=Math.floor(maxW/ratio);else if(maxH*ratio<maxW)maxW=Math.floor(maxH*ratio);return new Vec2(maxW,maxH)};class Viewer{constructor({context,visibleRect,resolution:{width:res_x=0,height:res_y=0},autoResize:{use=false,margin=1},cursor=null}){let autoResize=false;let onWindowResize=null;let resizeMargin=
1;let callback=null;let uiDiv=null;let uiElmts=[];let resizeFunction=defaultResizeFunction;this.context=context||null;this.visibleRect=visibleRect?visibleRect.clone():this.context&&this.context.canvas?new Rect(0,0,this.context.canvas.width,this.context.canvas.height):new Rect(0,0,0,0);this.useAutoResize=function(use=true,borderMargin=resizeMargin){resizeMargin=borderMargin;if(autoResize&&!use){window.removeEventListener("resize",onWindowResize,false);window.removeEventListener("fullscreenchange",
onWindowResize,false);autoResize=false}else if(!autoResize&&use){autoResize=true;if(!onWindowResize)onWindowResize=function(event){const canvas=this.context.canvas,parent=canvas.parentNode,display=getComputedStyle(parent).display;parent.style.display="none";const container=parent.parentNode||parent,containerW=container.clientWidth,containerH=container.clientHeight;let w=containerW-borderMargin*2,h=containerH-borderMargin*2;const wh=resizeFunction(this,w,h);w=wh.x;h=wh.y;parent.style.display=display;
w-=Math.ceil(canvas.offsetWidth-canvas.clientWidth);h-=Math.ceil(canvas.offsetHeight-canvas.clientHeight);this.setCanvasSize(w,h)}.bind(this);window.addEventListener("resize",onWindowResize,false);window.addEventListener("fullscreenchange",onWindowResize,false);onWindowResize(null)}else if(use)onWindowResize(null)};this.setCallback=function(cb){callback=cb};this.getCallback=function(){return callback};this.setResizeFunction=function(func){resizeFunction=func||defaultResizeFunction};this.setUIDiv=
function(divElement){uiDiv=divElement};this.getUIDiv=function(){return uiDiv};this.addUIElement=function(elmt){uiDiv.appendChild(elmt.elmt);uiElmts.push(elmt);elmt.update(this)};this.removeUIElement=function(elmt){let i=uiElmts.indexOf(elmt);if(i>=0){uiElmts.splice(i,1);uiDiv.removeChild(elmt.elmt)}};this.updateUI=function(){let i=uiElmts.length;while(i--)uiElmts[i].update(this)};if(context)this.setUIDiv(context.canvas.parentNode);if(!isNaN(res_x)&&!isNaN(res_y)&&res_x>0&&res_y>0)this.setCanvasResolution(res_x,
res_y);this.useAutoResize(use,margin);if(cursor!=null)this.cursor=cursor}setCanvasSize(width,height){const canvas=this.context.canvas,parent=canvas.parentNode;canvas.style.width=`${width}px`;canvas.style.height=`${height}px`;parent.style.width=`${canvas.offsetWidth}px`;parent.style.height=`${canvas.offsetHeight}px`;this.updateTransform();if(this.getCallback())this.getCallback()(RenderEvent.CANVAS_RESIZE,this.context)}setCanvasResolution(width,height){this.context.canvas.width=width;this.context.canvas.height=
height;this.updateTransform()}getCanvasStyle(){return getComputedStyle(this.context.canvas)}get scaleX(){return this.visibleRect.width/parseInt(this.getCanvasStyle().width)}get scaleY(){return this.visibleRect.height/parseInt(this.getCanvasStyle().height)}updateTransform(){this.context.setTransform(this.context.canvas.width/this.visibleRect.width,0,0,this.context.canvas.height/this.visibleRect.height,this.visibleRect.xMin,this.visibleRect.yMin);this.updateUI()}pixelToGameCoordinatesTransform(pixelCoords,
out=Vec2.zero){return out.setXY(pixelCoords.x*this.scaleX+this.visibleRect.xMin,pixelCoords.y*this.scaleY+this.visibleRect.yMin)}gameToPixelCoordinatesTransform(gameCoords,out=Vec2.zero){return out.setXY((gameCoords.x-this.visibleRect.xMin)/this.scaleX,(gameCoords.y-this.visibleRect.yMin)/this.scaleY)}setVisibleRect(rect){this.visibleRect.setRect(rect);this.updateTransform()}render(gameManager,objects){}get cursor(){return this.context.canvas.getComputedStyle().cursor}set cursor(cursor){this.context.canvas.style.cursor=
cursor}}class StandardViewer extends Viewer{constructor(parameters){if(!parameters.context&&parameters.canvas)parameters.context=parameters.canvas.getContext("2d");super(parameters)}render(gameManager,objects){let rect=this.visibleRect,objs,ctx=this.context,l,i,callback=this.getCallback();ctx.clearRect(rect.xMin,rect.yMin,rect.xMax,rect.yMax);if(callback){ctx.save();callback(RenderEvent.RENDER_BEGIN,ctx)}objs=objects.sort(renderLayerSort);if(!(i=objs.length))return;while(i&&objs[--i].renderLayer<
0);if(i>=0){do if(!objs[i].isOutOfRect(rect))objs[i].render(ctx);while(i--)}if(callback){callback(RenderEvent.RENDER_END,ctx);ctx.restore()}}setImageSmoothingEnabled(enabled){this.context.imageSmoothingEnabled=enabled}}class StandardDifferedViewer extends StandardViewer{constructor(parameters){super(parameters);this.hidden_canvas=this.context.canvas.cloneNode(false);this.hidden_context=this.hidden_canvas.getContext("2d")}setCanvasSize(width,height){this.hidden_canvas.style.width=width;this.hidden_canvas.style.height=
height;super.setCanvasSize(width,height);if(this.getCallback())this.getCallback()(RenderEvent.CANVAS_RESIZE,this.context)}updateTransform(){const temp=this.context;this.context=this.hidden_context;super.updateTransform();this.context=temp}setCanvasResolution(width,height){this.context.canvas.width=width;this.context.canvas.height=height;this.hidden_canvas.width=width;this.hidden_canvas.height=height}render(gameManager,objects){const temp=this.context,w=this.context.canvas.clientWidth,h=this.context.canvas.clientHeight;
this.context=this.hidden_context;super.render(gameManager,objects);this.context=temp;let rect=this.visibleRect;this.context.clearRect(rect.xMin,rect.yMin,rect.xMax,rect.yMax);this.context.drawImage(this.hidden_canvas,0,0,w,h,0,0,w,h)}setImageSmoothingEnabled(enabled){super.setImageSmoothingEnabled(enabled);const temp=this.context;this.context=this.hidden_context;super.setImageSmoothingEnabled(enabled);this.context=temp}}class WebGLViewer extends Viewer{constructor(parameters){if(!parameters.context&&
parameters.canvas)parameters.context=webgl.getContext(parameters.canvas);super(parameters);const gl=this.gl;webgl.initContext(gl);this.bgColor=[0,0,0,1]}updateTransform(){this.context.viewport(0,0,this.context.canvas.width,this.context.canvas.height);this.updateUI()}get gl(){return this.context}setBgColor(red,green,blue,alpha){this.bgColor[0]=red;this.bgColor[1]=green;this.bgColor[2]=blue;this.bgColor[3]=alpha}useFrameBuffer(frameBufferShaderProgram,samplersLocations){this.frameBuffer=this.context.createFramebuffer();
this.context.bindFramebuffer(this.context.FRAMEBUFFER,this.frameBuffer);this.frameProgram=frameBufferShaderProgram;this.frameSamplersLocs=samplersLocations}render(gameManager,objects){const obj=objects.filter(renderableFilter),gl=this.context;let n=obj.length;gl.clearColor(this.bgColor[0],this.bgColor[1],this.bgColor[2],this.bgColor[3]);gl.clear(this.context.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);if(this.callback)this.callback(RenderEvent.RENDER_BEGIN,gl);if(this.frameBuffer)gl.bindFramebuffer(gl.FRAMEBUFFER,
this.frameBuffer);while(n--)obj[n].render(gl);if(this.frameBuffer){gl.useProgram(this.frameProgram);gl.uniform1i(this.frameSamplersLocs[0],gl.COLOR)}if(this.callback)this.callback(RenderEvent.RENDER_END,gl)}}export{RenderEvent,UIElement,Viewer,StandardViewer,StandardDifferedViewer,WebGLViewer};
