<!doctype html>
<html>

<head>
  <meta name="generator" content="JSDoc 3.4.3">
  <meta charset="utf-8">
  <title>Source: game/board.js</title>
  <link rel="stylesheet" href="https://brick.a.ssl.fastly.net/Karla:400,400i,700,700i" type="text/css">
  <link rel="stylesheet" href="https://brick.a.ssl.fastly.net/Noto+Serif:400,400i,700,700i" type="text/css">
  <link rel="stylesheet" href="https://brick.a.ssl.fastly.net/Inconsolata:500" type="text/css">
  <link href="css/baseline.css" rel="stylesheet">
</head>

<body onload="prettyPrint()">
  <nav id="jsdoc-navbar" role="navigation" class="jsdoc-navbar">
    <div id="jsdoc-navbar-container">
      <div id="jsdoc-navbar-content">
        <a href="index.html" class="jsdoc-navbar-package-name">Home</a>
      </div>
    </div>
  </nav>
  <div id="jsdoc-body-container">
    <div id="jsdoc-content">
      <div id="jsdoc-content-container">
        <div id="jsdoc-banner" role="banner">
        </div>
        <div id="jsdoc-main" role="main">
          <header class="page-header">
            <h1>Source: game/board.js</h1>
          </header>
          <article>
            <pre class="prettyprint linenums"><code>/**
 * Created by rfrance on 1/21/2017.
 */
window.game.Board &#x3D; (function(){
	&quot;use strict&quot;;
	const Vec2 &#x3D; utils.geometry2d.Vec2,
		  Rect &#x3D; utils.geometry2d.Rect;
	/**
	 * @memberOf game
	 * @class game.Board
	 * @augments game.Object
	 * @classdesc An object defining a board on the field.
	 */
	class Board extends game.Object {
		/**
		 * @constructor
		 * @param {utils.geometry2d.Vec2} position
		 * @param {number} columns
		 * @param {number} lines
		 * @param {number} cellWidth
		 * @param {number} cellHeight
		 */
		constructor(position, columns, lines, cellWidth, cellHeight) {
			super(position);
			/**
			 * @name game.Board#lines
			 * @type {number}
			 */
			this.lines &#x3D; lines;
			/**
			 * @name game.Board#columns
			 * @type {number}
			 */
			this.columns &#x3D; columns;
			/**
			 * @name game.Board#cellWidth
			 * @type {number}
			 */
			this.cellWidth &#x3D; cellWidth;
			/**
			 * @name game.Board#cellHeight
			 * @type {number}
			 */
			this.cellHeight &#x3D; cellHeight;
			/**
			 * @name game.Board#occupationMap
			 * @type {Array.&amp;lt;Array.&amp;lt;number&gt;&gt;}
			 */
			this.occupationMap &#x3D; new Array(lines);
			let i, j;
			for(i&#x3D;0; i&amp;lt;lines; i++) {
				this.occupationMap[i] &#x3D; new Array(columns);
				for(j&#x3D;0; j&amp;lt;columns; j++) {
					this.occupationMap[i][j] &#x3D; 0;
				}
			}
		}
//______________________________________________________________________________________________________________________
// - - - - - - - - - - - - - - - - - - - - - - - - - -board getters - - - - - - - - - - - - - - - - - - - - - - - - - -
//**********************************************************************************************************************
		/**
		 * @name game.Board#boardRect
		 * @type {utils.geometry2d.Rect}
		 * @readonly
		 */
		get boardRect() {
			return Rect.createFromCenterWidthHeight(this.position, this.boardWidth, this.boardHeight);
		}
		/**
		 * @name game.Board#boardWidth
		 * @type {number}
		 * @readonly
		 */
		get boardWidth() {
			return this.cellWidth * this.columns;
		}
		/**
		 * @name game.Board#boardHeight
		 * @type {number}
		 * @readonly
		 */
		get boardHeight() {
			return this.cellHeight * this.lines;
		}
//______________________________________________________________________________________________________________________
// - - - - - - - - - - - - - - - - - - - - - - - - - - cell getters - - - - - - - - - - - - - - - - - - - - - - - - - -
//**********************************************************************************************************************
		/**
		 * returns the Rect corresponding to the selected cell of the board
		 * @param {number} line
		 * @param {number} column
		 * @returns {utils.geometry2d.Rect}
		 */
		getCellRect(column, line) {
			let left &#x3D; this.position.x + (column - this.columns*0.5)*this.cellWidth,
				top  &#x3D; this.position.y + (line - this.lines*0.5)*this.cellHeight;
			return new Rect(left, top, left+this.cellWidth, top+this.cellHeight);
		}
		/**
		 * returns the center of the selected cell
		 * @param {number} column
		 * @param {number} line
		 * @returns {utils.geometry2d.Vec2}
		 */
		getCellCenter(column, line) {
			let dX &#x3D; (this.columns*0.5 - 0.5 - column)*this.cellWidth,
				dY &#x3D; (this.lines*0.5 - 0.5 - line)*this.cellHeight;
			return this.position.clone().addXY(-dX, -dY);
		}
		/**
		 * returns the index of the board column containing the specified x coordinate
		 * @param {number} gameX
		 * @returns {number}
		 */
		getColumn( gameX ) {
			//return Math.floor((gameX - this.position.x + this.boardWidth/2)/this.cellWidth)
			return Math.floor(this.columns*0.5 + (gameX - this.position.x)/this.cellWidth);
		}
		/**
		 * returns the index of the board line containing the specified y coordinate
		 * @param {number} gameY
		 * @returns {number}
		 */
		getLine( gameY ) {
			return Math.floor(this.lines*0.5 + (gameY - this.position.y)/this.cellHeight);
		}

		/**
		 * convert a game position to a board indices position
		 * @param {utils.geometry2d.Vec2} gamePos - the position you want to convert
		 * @returns {utils.geometry2d.Vec2} - the converted position : x &#x3D; column index, y &#x3D; row index
		 */
		getCellIndices( gamePos ) {
			return new Vec2(this.getColumn(gamePos.x), this.getLine(gamePos.y));
		}

//______________________________________________________________________________________________________________________
// - - - - - - - - - - - - - - - - - - - - - - - - - - -grid render - - - - - - - - - - - - - - - - - - - - - - - - - -
//**********************************************************************************************************************
		/**
		 * draws the grid on the canvas with the specified color
		 * @param {CanvasRenderingContext2D}context
		 * @param {string} color
		 */
		renderGrid(context, color) {
			context.strokeStyle &#x3D; color;
			let r &#x3D; this.boardRect;
			let t &#x3D; r.xMin;
			context.beginPath();
			while(t &amp;lt;&#x3D; r.xMax) {
				context.moveTo(t, r.yMin);
				context.lineTo(t, r.yMax);
				t +&#x3D; this.cellWidth;
			}
			t &#x3D; r.yMin;
			while(t &amp;lt;&#x3D; r.yMax) {
				context.moveTo(r.xMin, t);
				context.lineTo(r.xMax, t);
				t +&#x3D; this.cellHeight;
			}
			context.stroke();
		}

		/**
		 * multiply the dimension of the cells, and keep the center of the board at the same position
		 * @param {number} factor
		 */
		scale(factor) {
			super.scale(factor);
			this.cellWidth *&#x3D; factor;
			this.cellHeight *&#x3D; factor;
		}
//______________________________________________________________________________________________________________________
// - - - - - - - - - - - - - - - - - - - - - - - - -occupation methods- - - - - - - - - - - - - - - - - - - - - - - - -
//**********************************************************************************************************************
		/**
		 * test if the selected cell is occupied, according to the occupation map
		 * @param {number} column - column index of the cell to test
		 * @param {number} line - row index of the cell to test
		 * @returns {boolean} true if the cell is occupied
		 */
		isOccupated(column, line) {
			return column &amp;lt; this.columns &amp;amp;&amp;amp; line &amp;lt; this.lines &amp;amp;&amp;amp; this.occupationMap[line][column] &#x3D;&#x3D; 1;
		}

		/**
		 * sets the occupation of the selected cell
		 * @param {number} column
		 * @param {number} line
		 * @param {boolean} occupated
		 * @returns {boolean} true if the given coordinates are valid
		 */
		setOccupated(column, line, occupated) {
			if(column &amp;lt; 0 &amp;amp;&amp;amp; column &gt;&#x3D; this.columns &amp;amp;&amp;amp; line &amp;lt; 0 &amp;amp;&amp;amp; line &gt;&#x3D; this.lines)
				return false
			this.occupationMap[line][column] &#x3D; occupated ? 1 : 0;
			return true;

		}

		/**
		 * sets the occupation of a portion of the board. If the given map has an odd number of rows/columns, &amp;lt;!--
		 * --&gt;the given line/column index will be the line/column index of the center cell of the modified portion &amp;lt;!--
		 * --&gt;of the map. If the given map has an even number of rows/columns, the given line/column index will be &amp;lt;!--
		 * --&gt;the index of of the cell just before (above/on the left of) the center cell of the modified portion
		 * @param {number} column - column index of the center of the submap
		 * @param {number} line - row index of the center of the submap
		 * @param {Array&amp;lt;Array&amp;lt;boolean&gt;&gt;} occupationSubMap - the map to place on the global occupation map
		 */
		addOccupation(column, line, occupationSubMap) {
			let subH &#x3D; occupationSubMap.length, subW;
			let top &#x3D; line - Math.floor((subH-1)/2), left;
			let i, j;
			for(i &#x3D; 0; i &amp;lt; subH; i++) {
				subW &#x3D; occupationSubMap[i].length;
				left &#x3D; column - Math.floor((subW-1)/2);
				for(j &#x3D; 0; j &amp;lt; subW; j++) {
					if(top+i &amp;lt; 0 || top+1 &gt;&#x3D; this.rows || left+j &amp;lt; 0 || left+j &gt;&#x3D; this.columns) continue;
					this.occupationMap[top+i][left+j] &#x3D; occupationSubMap[i][j] ? 1 : 0;
				}
			}
		}

		/**
		 * adds an occupation submap to the occupation map
		 * @param columns
		 * @param lines
		 * @param occupationSubMaps
		 */
		addOccupations(columns, lines, occupationSubMaps) {
			let i&#x3D;Math.min(columns.length, lines.length, occupationSubMaps.length);
			while(i--) {
				this.addOccupation(columns[i], lines[i], occupationSubMaps[i]);
			}
		}
		/**
		 * reset the occupation map by filling it with 0
		 */
		clearOccupation() {
			for(i&#x3D;0; i&amp;lt;this.lines; i++) {
				for(j&#x3D;0; j&amp;lt;this.columns; j++) {
					this.occupationMap[i][j] &#x3D; 0;
				}
			}
		}

		/**
		 * Must be called when you change the board dimension for the occupation map to be changed too.
		 * The right column and bottom lines will be changed (added or removed, not the left and top :
		 * @example
		 * .________.......__________
		 * |.#....# |.....|.#....#...|
		 * |...#...#| --&gt; |...#...#..|
		 * |....#...|.....|____#_____|
		 * |_#______|.......(10 x 3)
		 * .(8 x 4)
		 */
		onDimensionsChange() {
			let newMap &#x3D; new Array(this.lines);
			let oldHeight &#x3D; this.occupationMap.length, oldWidth;
			let i, j;
			for(i &#x3D; Math.min(oldHeight, this.lines)-1; i &gt;&#x3D; 0; i--) {
				newMap &#x3D; new Array(this.columns);
				oldWidth &#x3D; this.occupationMap[i].length;
				for(j &#x3D; Math.min(oldWidth, this.columns)-1; j &gt;&#x3D; 0; j--) {
					newMap[i][j] &#x3D; this.occupationMap[i][j];
				}
				for(j &#x3D; oldWidth; j&amp;lt; this.columns; j++) {
					newMap[i][j] &#x3D; 0;
				}
			}
			for(i &#x3D; oldHeight; i &amp;lt; this.lines; i++) {
				for(j&#x3D;0; j&amp;lt; this.columns; j++) {
					newMap[i][j] &#x3D; 0;
				}
			}
		}
		/**
		 * returns an optimized path from the start point (given in index coordinates) to the end point &amp;lt;!--
		 * --&gt;(given in index coordinates) using the Lee algorithm. The result is an array of &amp;lt;!--
		 * --&gt;{@link utils.geometry2d.Vec2|Vec2} in index coordinates describing the path from the start point &amp;lt;!--
		 * --&gt;to the end point, including the end point but excluding the start point.
		 * @param {utils.geometry2d.Vec2} start - x &#x3D; column index, y &#x3D; row index
		 * @param {utils.geometry2d.Vec2} end   - x &#x3D; column index, y &#x3D; row index
		 * @returns {utils.geometry2d.Vec2[]} the path of {@link utils.geometry2d.Vec2 Vec2} &amp;lt;!--
		 * --&gt;in index coordinates[(i,j), (i,j), (i,j)]
		 */
		leePath(start, end) {

			if(this.occupationMap[start.y][start.x] || this.occupationMap[end.y][end.x]) return [];
			let heatMap &#x3D; new Array(this.lines),
				i, j, list, newFifo, p, len;

			for(i &#x3D; 0; i &amp;lt; this.lines; i++) {
				heatMap[i] &#x3D; new Array(this.columns);
				for(j &#x3D; 0; j &amp;lt; this.columns; j++) {
					heatMap[i][j] &#x3D; this.occupationMap[i][j]? -1 : 0;
				}
			}

			list &#x3D; [];
			newFifo &#x3D; [start];
			heatMap[start.y][start.x] &#x3D; 1;
			while(newFifo.length &amp;amp;&amp;amp; heatMap[end.y][end.x] &#x3D;&#x3D; 0) {
				list &#x3D; newFifo;
				newFifo &#x3D; [];
				len &#x3D; list.length;
				i &#x3D; -1;
				while(++i &amp;lt; len) { p &#x3D; list[i];
					if (p.y &gt; 0 &amp;amp;&amp;amp; this.occupationMap[p.y - 1][p.x] &#x3D;&#x3D; 0 &amp;amp;&amp;amp; heatMap[p.y - 1][p.x] &#x3D;&#x3D; 0) {
						heatMap[p.y-1][p.x] &#x3D; heatMap[p.y][p.x] + 1;
						newFifo.push(p.clone().addXY(0, -1));
					}
					if (p.y &amp;lt; this.lines-1 &amp;amp;&amp;amp; this.occupationMap[p.y + 1][p.x] &#x3D;&#x3D; 0 &amp;amp;&amp;amp; heatMap[p.y + 1][p.x] &#x3D;&#x3D; 0) {
						heatMap[p.y+1][p.x] &#x3D; heatMap[p.y][p.x] + 1;
						newFifo.push(p.clone().addXY(0, 1));
					}
					if (p.x &gt; 0 &amp;amp;&amp;amp; this.occupationMap[p.y][p.x - 1] &#x3D;&#x3D; 0 &amp;amp;&amp;amp; heatMap[p.y][p.x - 1] &#x3D;&#x3D; 0) {
						heatMap[p.y][p.x-1] &#x3D; heatMap[p.y][p.x] + 1;
						newFifo.push(p.clone().addXY(-1, 0));
					}
					if (p.x &amp;lt; this.columns-1 &amp;amp;&amp;amp; this.occupationMap[p.y][p.x + 1] &#x3D;&#x3D; 0 &amp;amp;&amp;amp; heatMap[p.y][p.x + 1] &#x3D;&#x3D; 0) {
						heatMap[p.y][p.x+1] &#x3D; heatMap[p.y][p.x] + 1;
						newFifo.push(p.clone().addXY(1, 0));
					}
				}
			}
			let heat &#x3D; heatMap[end.y][end.x];
			if(heat !&#x3D; 0) {
				let path &#x3D; new Array(heat-1);
				p &#x3D; end.clone();
				let lastDir &#x3D; 0;
				let nextDir &#x3D; 0;
				while(heat !&#x3D; 1) {
					path[--heat - 1] &#x3D; p.clone();
					if(p.y &gt; 0 &amp;amp;&amp;amp; heatMap[p.y-1][p.x] &#x3D;&#x3D; heat) {
						nextDir &#x3D; 1 // go up
					}
					if(p.y &amp;lt; this.lines-1 &amp;amp;&amp;amp; heatMap[p.y+1][p.x] &#x3D;&#x3D; heat) {
						if(lastDir&#x3D;&#x3D;0 || nextDir &#x3D;&#x3D; lastDir) nextDir &#x3D; 2; // go down
					}
					if(p.x &gt; 0 &amp;amp;&amp;amp; heatMap[p.y][p.x-1] &#x3D;&#x3D; heat) {
						if(lastDir&#x3D;&#x3D;0 || nextDir &#x3D;&#x3D; lastDir) nextDir &#x3D; 3; // go left
					}
					if(p.x &amp;lt; this.columns-1 &amp;amp;&amp;amp; heatMap[p.y][p.x+1] &#x3D;&#x3D; heat) {
						if(lastDir&#x3D;&#x3D;0 || nextDir &#x3D;&#x3D; lastDir) nextDir &#x3D; 4; // go right
					}
					switch(nextDir) {
						case 1 : p.addXY( 0,-1); break;
						case 2 : p.addXY( 0, 1); break;
						case 3 : p.addXY(-1, 0); break;
						case 4 : p.addXY( 1, 0); break;
					}
					lastDir &#x3D; nextDir;
				}
				return path;
			}
			else return [];
		}
		/**
		 * returns an optimized path from the start point (given in index coordinates) to the end point &amp;lt;!--
		 * --&gt;(given in index coordinates) using the A* algorithm. The result is an array of &amp;lt;!--
		 * --&gt;{@link utils.geometry2d.Vec2|Vec2} in index coordinates describing the path from the start point &amp;lt;!--
		 * --&gt;to the end point, including the end point but excluding the start point.
		 * @param {utils.geometry2d.Vec2} start - x &#x3D; column index, y &#x3D; row index
		 * @param {utils.geometry2d.Vec2} end   - x &#x3D; column index, y &#x3D; row index
		 * @parame {boolean} [allowDiagonals&#x3D;true] - whether or not you allow diagonals to be used
		 * @returns {utils.geometry2d.Vec2[]} the path of {@link utils.geometry2d.Vec2 Vec2} &amp;lt;!--
		 * --&gt;in index coordinates[(i,j), (i,j), (i,j)]
		 */
		aStarPath(start, end, allowDiagonals &#x3D; true) {
			let openList &#x3D; [], openListFG &#x3D; [], closeList &#x3D; [], closeListF &#x3D; [],
				n, i, j, minF, minI, q, successors, f, g, q_fg, skip, finish &#x3D; false,
				distance &#x3D; Vec2.squareDistance;
			openList.push(start);
			openListFG.push(new Vec2(0, 0));
			while((n &#x3D; openList.length) &gt; 0 &amp;amp;&amp;amp; !finish) {
				minF &#x3D; openListFG[0].x, minI &#x3D; 0, i &#x3D; n;
				while(--i) {
					if(openListFG[i].x &amp;lt; minF) {
						minI &#x3D; i;
						minF &#x3D; openListFG[i].x;
					}
				}
				q &#x3D; openList.splice(minI, 1)[0];
				q_fg &#x3D; openListFG.splice(minI, 1)[0];
				successors &#x3D; [];
				i &#x3D; 0;
				if(q.y &gt; 0 &amp;amp;&amp;amp; this.occupationMap[q.y-1][q.x] &#x3D;&#x3D; 0) { i +&#x3D; 1; successors.push(new Vec2(q.x, q.y-1)); }
				if(q.x &gt; 0 &amp;amp;&amp;amp; this.occupationMap[q.y][q.x-1] &#x3D;&#x3D; 0) { i +&#x3D; 2; successors.push(new Vec2(q.x-1, q.y)); }
				if(q.y &amp;lt; this.lines-1 &amp;amp;&amp;amp; this.occupationMap[q.y+1][q.x] &#x3D;&#x3D; 0)
					{ i +&#x3D; 4; successors.push(new Vec2(q.x, q.y+1)); }
				if(q.x &amp;lt; this.columns-1 &amp;amp;&amp;amp; this.occupationMap[q.y][q.x+1] &#x3D;&#x3D; 0)
					{ i +&#x3D; 8; successors.push(new Vec2(q.x+1, q.y)); }
				if(allowDiagonals) {
					if(i%4 &#x3D;&#x3D; 3 &amp;amp;&amp;amp; this.occupationMap[q.y-1][q.x-1] &#x3D;&#x3D; 0) successors.push(new Vec2(q.x-1, q.y-1));
					if(i%2 &#x3D;&#x3D; 1 &amp;amp;&amp;amp; i &gt; 8 &amp;amp;&amp;amp; this.occupationMap[q.y-1][q.x+1] &#x3D;&#x3D; 0)
						successors.push(new Vec2(q.x+1, q.y-1));
					if((i&gt;&gt;1)%4 &#x3D;&#x3D; 3 &amp;amp;&amp;amp; this.occupationMap[q.y+1][q.x-1] &#x3D;&#x3D; 0) successors.push(new Vec2(q.x-1, q.y+1));
					if((i&gt;&gt;2) &#x3D;&#x3D; 3 &amp;amp;&amp;amp; this.occupationMap[q.y+1][q.x+1] &#x3D;&#x3D; 0) successors.push(new Vec2(q.x+1, q.y+1));
				}
				i &#x3D; successors.length;
				while(i--) {
					if( successors[i].x &amp;lt; 0 || successors[i].x &gt;&#x3D; this.columns ||
						successors[i].y &amp;lt; 0 || successors[i].y &gt;&#x3D; this.rows)
						continue;
					if(this.occupationMap[successors[i].y][successors[i].x] !&#x3D; 0)
						continue;
					if(successors[i].equals(end)) {
						closeList.push(q);
						closeList.push(end);
						finish &#x3D; true;
						break;
					}
					j &#x3D; n - 1;
					g &#x3D; q_fg.y + distance(q, successors[i]);
					f &#x3D; g + distance(successors[i], end);
					while(j--) {
						if(openList[j].equals(successors[i])) {
							if(f &gt; openListFG[j].x) {
								skip &#x3D; true;
							}
						}
					}
					if(skip) { skip &#x3D; false; continue; }
					j &#x3D; closeList.length;
					while(j--) {
						if(closeList[j].equals(successors[i])) {
							if(f &gt; closeListF[i]) {
								skip &#x3D; true;
							}
						}
					}
					if(skip) { skip &#x3D; false; continue; }
					openList.push(successors[i]);
					openListFG.push(new Vec2(f, g));
				}
				if(!finish) {
					closeList.push(q);
					closeListF.push(q_fg.x);
				}
			}
			return closeList;
		}
	}
	return Board;
})();</code></pre>
          </article>
        </div>
      </div>
      <nav id="jsdoc-toc-nav" role="navigation"></nav>
    </div>
  </div>
  <footer id="jsdoc-footer" class="jsdoc-footer">
    <div id="jsdoc-footer-container">
      <p>
        Generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc</a> 3.4.3 on October 7, 2017.
      </p>
    </div>
  </footer>
  <script src="scripts/jquery.min.js"></script>
  <script src="scripts/jquery.cookie.js"></script>
  <script src="scripts/tree.jquery.js"></script>
  <script src="scripts/prettify.js"></script>
  <script src="scripts/jsdoc-toc.js"></script>
  <script src="scripts/linenumber.js"></script>
  <script src="scripts/scrollanchor.js"></script>
</body>

</html>