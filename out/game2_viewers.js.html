<!doctype html>
<html>

<head>
  <meta name="generator" content="JSDoc 3.4.3">
  <meta charset="utf-8">
  <title>Source: game2/viewers.js</title>
  <link rel="stylesheet" href="https://brick.a.ssl.fastly.net/Karla:400,400i,700,700i" type="text/css">
  <link rel="stylesheet" href="https://brick.a.ssl.fastly.net/Noto+Serif:400,400i,700,700i" type="text/css">
  <link rel="stylesheet" href="https://brick.a.ssl.fastly.net/Inconsolata:500" type="text/css">
  <link href="css/baseline.css" rel="stylesheet">
</head>

<body onload="prettyPrint()">
  <nav id="jsdoc-navbar" role="navigation" class="jsdoc-navbar">
    <div id="jsdoc-navbar-container">
      <div id="jsdoc-navbar-content">
        <a href="index.html" class="jsdoc-navbar-package-name">Home</a>
      </div>
    </div>
  </nav>
  <div id="jsdoc-body-container">
    <div id="jsdoc-content">
      <div id="jsdoc-content-container">
        <div id="jsdoc-banner" role="banner">
        </div>
        <div id="jsdoc-main" role="main">
          <header class="page-header">
            <h1>Source: game2/viewers.js</h1>
          </header>
          <article>
            <pre class="prettyprint linenums"><code>/**
 * Created by Loic France on 12/25/2016.
 */
&quot;use strict&quot;;
window.game.UIElement &#x3D; (function(){
	class UIElement {
		/**
		 * @constructor
		 *
		 * @param {HTMLElement} elmt
		 * @param {utils.geometry2d.Vec2} position
		 * @param {boolean} staticPos
		 */
		constructor(elmt, position, staticPos &#x3D; false) {
			/**
			 * @type {HTMLElement}
			 * @name game.UIElement#elmt
			 */
			this.elmt &#x3D; elmt;
			this.elmt.className &#x3D; &#x27;game_ui&#x27;;
			/**
			 * @type {utils.geometry2d.Vec2}
			 * @name game.UIElement#position
			 */
			this.position &#x3D; position.clone();
			/**
			 * @type {boolean}
			 * @name game.UIElement#staticPos
			 */
			this.staticPos &#x3D; !!staticPos;
		}

		/**
		 * called by the {@link game.Viewer} instace attached to the {@link game.GameManager} when the window
		 * gets resized or the visible rect is modified.
		 * @param viewer
		 */
		update(viewer) {
			let scaleX &#x3D; 1/viewer.scaleX, scaleY &#x3D; 1/viewer.scaleY;
			if(this.position &amp;amp;&amp;amp; !isNaN(this.position.x) &amp;amp;&amp;amp; !isNaN(this.position.y)) {
				let pos &#x3D; this.position.clone();
				if(!this.staticPos) {
					pos.addXY(- viewer.visibleRect.left, - viewer.visibleRect.top);
				}
				pos.x *&#x3D; scaleX;
				pos.y *&#x3D; scaleY;
				pos.x +&#x3D; (parseFloat(viewer.context.canvas.style.left) || 0) - (this.elmt.clientWidth  * scaleX)/2;
				pos.y +&#x3D; (parseFloat(viewer.context.canvas.style.top ) || 0) - (this.elmt.clientHeight * scaleY)/2;
				this.elmt.style.transform &#x3D; &#x60;scale(${scaleX}, ${scaleY})&#x60;;
				this.elmt.style.transformOrigin &#x3D; &#x27;left top&#x27;;
				this.elmt.style.left &#x3D; &#x60;${Math.round(pos.x)}px&#x60;;
				this.elmt.style.top  &#x3D; &#x60;${Math.round(pos.y)}px&#x60;;
			}
		}
	}
	return UIElement;
})();
window.game.Viewer &#x3D; (function() {
	let Rect &#x3D; utils.geometry2d.Rect;
	/**
	 * The class used by the game manager for the rendering.
	 * @class game.Viewer
	 * @memberOf game
	 */
    class Viewer {
    	constructor(drawingContext) {
		    //private variables used for resize
		    let autoResize &#x3D; false;
		    let onWindowResize &#x3D; null;
		    let resizeMargin &#x3D; 0;
		    let callback &#x3D; null;
		    let uiDiv &#x3D; null;
		    let uiElmts &#x3D; [];
		    /**
		     * @name game.Viewer#context
		     * @type {CanvasRenderingContext2D|WebGLRenderingContext}
		     */
		    this.context &#x3D; drawingContext;
		    /**
		     * @name game.Viewer#visibleRect
		     * @type {utils.geometry2d.Rect}
		     */
		    this.visibleRect &#x3D; new Rect(0, 0, this.context.canvas.width, this.context.canvas.height);

		    /**
		     * allows the canvas to resize automatically when the window size changes.
		     * The callback function is called after the resize with the first parameter equal to &amp;lt;!--
		     * --&gt;{@link game.RenderEvent.CANVAS_RESIZE} and the second one equal to the rendering context.
		     * @method
		     * @name game.Viewer#useAutoResize
		     * @param {boolean} use
		     * @param {number} [borderMargin]. first use : default to 4. next uses : default to previous values.
		     */
		    this.useAutoResize &#x3D; function (use &#x3D; true, borderMargin &#x3D; resizeMargin) {
			    resizeMargin &#x3D; borderMargin;
			    if (autoResize &amp;amp;&amp;amp; !use) {
				    window.removeEventListener(&#x27;resize&#x27;, onWindowResize, false);
				    window.removeEventListener(&#x27;fullscreenchange&#x27;, onWindowResize, false);
			    }
			    else if (!autoResize &amp;amp;&amp;amp; use) {
				    autoResize &#x3D; true;
				    if (!onWindowResize) {
					    onWindowResize &#x3D; function (event) {
						    let parent &#x3D; this.context.canvas.parentNode,
							    parentW &#x3D; parent.offsetWidth,
							    parentH &#x3D; parent.offsetHeight,
							    ratio &#x3D; this.visibleRect.ratio,
							    w &#x3D; parentW - (borderMargin * 2),
							    h &#x3D; Math.min(parentH - (borderMargin * 2), w / ratio);
						    w &#x3D; h * ratio;
						    let left &#x3D; (parentW - w) * 0.5,
							    top &#x3D; (parentH - h) * 0.5;
						    this.setCanvasSize(w, h, left, top);
					    }.bind(this);
				    }
				    window.addEventListener(&#x27;resize&#x27;, onWindowResize, false);
				    window.addEventListener(&#x27;fullscreenchange&#x27;, onWindowResize, false);
				    onWindowResize(null);
			    }
		    };
		    /**
		     * manually changes the size of the canvas, and modifies the scale for the visible rectangle &amp;lt;!--
		     * --&gt;to fit the canvas without the visible rectangle to change. you can change the visible rect and &amp;lt;!--
		     * --&gt;the {@link game.Viewer#updateScale} method to change the scale.
		     * The callback function is then with the first parameter equal to &amp;lt;!--
		     * --&gt;{@link game.RenderEvent.CANVAS_RESIZE} and the second one equal to the rendering context.
		     * @method
		     * @name game.Viewer#setCanvasSize
		     * @param {number} width
		     * @param {number} height
		     * @param {number} marginX
		     * @param {number} marginY
		     */
		    this.setCanvasSize &#x3D; function (width, height, marginX, marginY) {
			    let canvas &#x3D; this.context.canvas;
			    canvas.width &#x3D; canvas.style.width &#x3D; width;
			    canvas.height &#x3D; canvas.style.height &#x3D; height;
			    if(getComputedStyle(canvas).getPropertyValue(&#x27;position&#x27;) &#x3D;&#x3D;&#x3D; &#x27;absolute&#x27;) {
				    canvas.style.left &#x3D; marginX.toString() + &quot;px&quot;;
				    canvas.style.top &#x3D; marginY.toString() + &quot;px&quot;;
			    } else {
				    canvas.style.marginLeft &#x3D; marginX.toString() + &quot;px&quot;;
				    canvas.style.marginTop &#x3D; marginY.toString() + &quot;px&quot;;
			    }
			    this.updateTransform();
			    if (callback) callback(game.RenderEvent.CANVAS_RESIZE, this.context);
		    };
		    /**
		     * sets the callback function called for rendering events. See {@link game.RenderEvent} &amp;lt;!--
		     * --&gt;for a list of all possible events
		     * @method
		     * @name game.Viewer#setCallback
		     * @param {?game.renderEventCallback} cb
		     */
		    this.setCallback &#x3D; function (cb) {
			    callback &#x3D; cb;
		    };
		    /**
		     * returns the callback function called for rendering events. See {@link game.RenderEvent} &amp;lt;!--
		     * --&gt;for a list of all possible events
		     * @method
		     * @name game.Viewer#getCallback
		     * @returns {?game.renderEventCallback}
		     */
		    this.getCallback &#x3D; function() {
		    	return callback;
		    };
		    /**
		     * sets the {@link HTMLDivElement } used to place UI elements. &amp;lt;!--
		     * --&gt;this div will be maintained the same size as the canvas element
		     * @method
		     * @param {HTMLDivElement} divElement
		     */
		    this.setUIDiv &#x3D; function(divElement) {
			    uiDiv &#x3D; divElement;
		    };
		    /**
		     * @method
		     * @returns {!HTMLDivElement} the div used to place ui elements
		     */
		    this.getUIDiv &#x3D; function() {
		    	return uiDiv;
		    };
		    /**
		     * adds a {@link game.UIElement} to the user interface
		     * @method
		     * @param {game.UIElement} elmt - the element to add to the UI
		     */
		    this.addUIElement &#x3D; function(elmt) {
			    uiDiv.appendChild(elmt.elmt);
			    uiElmts.push(elmt);
		    };
		    /**
		     * remove the {@link game.UIElement} from the user interface
		     * @param {game.UIElement} elmt
		     */
		    this.removeUIElement &#x3D; function(elmt) {
		    	let i &#x3D; uiElmts.indexOf(elmt);
		    	if(i &gt;&#x3D; 0) {
				    uiElmts.splice(i, 1);
		    		uiDiv.removeChild(elmt.elmt);
			    }

		    };
		    /**
		     * called after the window has been resized or the visible game rect modified.
		     * calls the {@link game.UIElement#update update(viewer)} method of every element to transform it.
		     */
		    this.updateUI &#x3D; function() {
		    	let i &#x3D; uiElmts.length;
		    	while(i--) {
		    		uiElmts[i].update(this);
			    }
		    }
	    }
		/**
		 * number of game units by pixel (&#x3D;(visible game width)/(canvas width))
		 * @name game.Viewer#scaleX
		 * @type {number}
		 * @readonly
		 */
	    get scaleX() { return this.visibleRect.width/this.context.canvas.width; }
	    /**
	     * number of game units by pixel (&#x3D;(visible game height)/(canvas height))
	     * @name game.Viewer#scaleY
	     * @type {number}
	     * @readonly
	     */
	    get scaleY() { return this.visibleRect.height/this.context.canvas.height; }
	    /**
	     * changes the scale for the visible rect size to fit the canvas. Don&#x27;t forget to call this method after &amp;lt;!--
	     * --&gt; you made manual modifications on the visible rect to avoid errors.
	     * Be aware that the game may look stretched if the aspect of the canvas is not the same &amp;lt;!--
	     * --&gt;as the rectangle&#x27;s {@link utils.geometry2d.Rect#ratio|ratio}
	     */
	    updateTransform() {
		    this.context.setTransform(
			    this.context.canvas.width/this.visibleRect.width, 0, 0,
			    this.context.canvas.height/this.visibleRect.height, this.visibleRect.left, this.visibleRect.top);
			this.updateUI();
	    }
		/**
		 * gives you the game coordinates of a point given in pixel coordinates relative to the canvas.
		 * @param {utils.geometry2d.Vec2} pixelCoords
		 * @param {utils.geometry2d.Vec2} out
		 * @returns {utils.geometry2d.Vec2} out
		 */
		pixelToGameCoordinatesTransform(pixelCoords, out &#x3D; Vec2.zero) {
			return out.setXY(
				pixelCoords.x*this.scaleX+this.visibleRect.left,
				pixelCoords.y*this.scaleY+this.visibleRect.top);
		}
		/**
		 * gives you the pixel coordinates, relative to the canvas, of a point in the game.
		 * @param {utils.geometry2d.Vec2} gameCoords
		 * @param {utils.geometry2d.Vec2} out
		 * @returns {utils.geometry2d.Vec2} out
		 */
		gameToPixelCoordinatesTransform(gameCoords, out &#x3D; Vec2.zero) {
			return out.setXY(
				(gameCoords.x-this.visibleRect.left)/this.scaleX,
				(gameCoords.y-this.visibleRect.top)/this.scaleY);
		}
		/**
		 * called by the game manager after a frame to draw objects on the canvas.
		 * The callback function is called at the beginning and at the end of the function, and at the &amp;lt;!--
		 * --&gt;beginning and the end of the drawing of every layer, with the first parameter equal to &amp;lt;!--
		 * --&gt;{@link game.RenderEvent.RENDER_BEGIN}, {@link game.RenderEvent.RENDER_END}, &amp;lt;!--
		 * --&gt;{@link game.RenderEvent.RENDER_LAYER_BEGIN} or {@link game.RenderEvent.RENDER_LAYER_END} &amp;lt;!--
		 * and the second one equal to the rendering context.
		 * @name game.Viewer#render
		 * @param {game.GameManager} gameManager
		 * @param {game.Object[]} objects
		 * @abstract
		 */
		render( gameManager, objects) { }

    }
    return Viewer;
})();
window.game.StandardViewer &#x3D; (function() {
	/**
	 * @class game.StandardViewer
	 * @memberOf game
	 * @augments game.Viewer
	 */
    class StandardViewer extends window.game.Viewer {
    	constructor(canvas) {
    		super(canvas.getContext(&#x27;2d&#x27;));
	    }
	    render(gameManager, objects) {
		    let rect &#x3D; this.visibleRect, objs, ctx &#x3D; this.context, l, i, callback &#x3D; this.getCallback();
		    ctx.clearRect(rect.left, rect.top, rect.right, rect.bottom);
		    if(callback) {
			    ctx.save();
			    callback(game.RenderEvent.RENDER_BEGIN, ctx);
		    }
		    objs &#x3D; objects.sort(game.renderLayerSort);
		    if(!(i &#x3D; objs.length))
		    	return;
		    //noinspection StatementWithEmptyBodyJS
		    while(i &amp;amp;&amp;amp; objs[--i].renderLayer &amp;lt; 0);
		    if(i&gt;&#x3D;0) {
			    if(callback) {
				    callback(game.RenderEvent.RENDER_LAYER_BEGIN, ctx);
			    }
			    l &#x3D; objs[i].renderLayer;
			    do {
				    if(objs[i].renderLayer &amp;lt; l) {
					    if(objs[i].renderLayer &amp;lt; 0) {
						    if(callback) callback(game.RenderEvent.RENDER_LAYER_END, ctx);
						    ctx.restore();
					    }
					    if(callback) {
						    callback(game.RenderEvent.RENDER_LAYER_END, ctx);
						    callback(game.RenderEvent.RENDER_LAYER_BEGIN, ctx);
					    }
					    ctx.restore();
					    ctx.save();
					    l &#x3D; Math.ceil(objs[i].renderLayer);
				    }
				    if(!objs[i].isOutOfRect(rect)) objs[i].render(ctx);

			    } while(i--);
			    if(callback) {
				    callback(game.RenderEvent.RENDER_LAYER_END, ctx);
			    }
		    }
		    if(callback) {
			    callback(game.RenderEvent.RENDER_END, ctx);
			    ctx.restore();
		    }
	    }

		/**
		 * enables or disables image smoothing for the {@link CanvasRenderingContext2D context}
		 * @param {boolean} enabled
		 */
		setImageSmoothingEnabled(enabled) {
            this.context.imageSmoothingEnabled &#x3D; enabled;
	    }
    }
    return StandardViewer;
})();
window.game.WebGLViewer &#x3D; (function() {
	let vertexShader &#x3D;&#x60;
		uniform int u_color;
		uniform int u_useTexture;
		uniform mat3 uMVMatrix;
		uniform float u_depth;
		
		attribute vec2 a_position;
		
		varying vec4 f_color;
		void main(void) {
            int r &#x3D; a_color / 256 / 256;
            int g &#x3D; a_color / 256 - 256*r;
            int b &#x3D; a_color - 256*(256*r+g);
            f_color &#x3D; vec4(float(r)/255.0, float(g)/255.0, float(b)/255.0, 1.0);
			gl_Position &#x3D; vec4(uMVMatrix * vec3(a_position, -1.0), depth);
		}&#x60;;
	/**
	 * @class game.WebGLViewer
	 * @memberOf game
	 * @augments game.Viewer
	 */
	class WebGLViewer extends window.game.Viewer {
		constructor(canvas, maxObjectPoints&#x3D;100) {
			super(window.webgl.getGLContext(canvas));
			window.webgl.initGLContext(this.context);
			let vs &#x3D; webgl.createGLShader(this.context, webgl.standard2dVertexShader, &#x27;vertex&#x27;);
			let fs &#x3D; webgl.createGLShader(this.context, webgl.standardFragmentShader, &#x27;fragment&#x27;);
			this.shaderProgram &#x3D; webgl.addGLShaderProgram(this.context, vs, fs);
			this.vertices &#x3D; new Float32Array(maxObjectPoints*2);
			this.colors &#x3D; new Uint32Array(maxObjectPoints);
			this.positionAttrib &#x3D; this.context.getAttribLocation(this.shaderProgram, &#x27;a_position&#x27;);
			this.colorAttrib &#x3D; this.context.getAttribLocation(this.shaderProgram, &#x27;a_color&#x27;);
		}
		get scaleX() {
			return this.context.getParameter(this.context.VIEWPORT);
		}
		updateScale() {
			this.context.viewport(this.visibleRect.left , this.visibleRect.top,
								  this.visibleRect.width, this.visibleRect.height);
		}
		render(gameManager, objects) {
			let obj &#x3D; objects.splice().filter(game.renderableFilter), n &#x3D; obj.length,
				drawHandler &#x3D; new webgl.GlBufferHandler(this.context);
			utils.tools.merge(drawHandler, {
				vertices: this.vertices,
				colors: this.colors,
				glBuffer: this.context.createBuffer(),
				positionAttrib: this.positionAttrib,
				colorAttrib: this.colorAttrib
			});
			gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
			while(n--) {
				obj[n].renderGL(drawHandler);
			}
		}
	}
	return WebGLViewer;
})();</code></pre>
          </article>
        </div>
      </div>
      <nav id="jsdoc-toc-nav" role="navigation"></nav>
    </div>
  </div>
  <footer id="jsdoc-footer" class="jsdoc-footer">
    <div id="jsdoc-footer-container">
      <p>
        Generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc</a> 3.4.3 on September 2, 2017.
      </p>
    </div>
  </footer>
  <script src="scripts/jquery.min.js"></script>
  <script src="scripts/jquery.cookie.js"></script>
  <script src="scripts/tree.jquery.js"></script>
  <script src="scripts/prettify.js"></script>
  <script src="scripts/jsdoc-toc.js"></script>
  <script src="scripts/linenumber.js"></script>
  <script src="scripts/scrollanchor.js"></script>
</body>

</html>