<!doctype html>
<html>

<head>
  <meta name="generator" content="JSDoc 3.4.3">
  <meta charset="utf-8">
  <title>Source: utils/tools.js</title>
  <link rel="stylesheet" href="https://brick.a.ssl.fastly.net/Karla:400,400i,700,700i" type="text/css">
  <link rel="stylesheet" href="https://brick.a.ssl.fastly.net/Noto+Serif:400,400i,700,700i" type="text/css">
  <link rel="stylesheet" href="https://brick.a.ssl.fastly.net/Inconsolata:500" type="text/css">
  <link href="css/baseline.css" rel="stylesheet">
</head>

<body onload="prettyPrint()">
  <nav id="jsdoc-navbar" role="navigation" class="jsdoc-navbar">
    <div id="jsdoc-navbar-container">
      <div id="jsdoc-navbar-content">
        <a href="index.html" class="jsdoc-navbar-package-name">Home</a>
      </div>
    </div>
  </nav>
  <div id="jsdoc-body-container">
    <div id="jsdoc-content">
      <div id="jsdoc-content-container">
        <div id="jsdoc-banner" role="banner">
        </div>
        <div id="jsdoc-main" role="main">
          <header class="page-header">
            <h1>Source: utils/tools.js</h1>
          </header>
          <article>
            <pre class="prettyprint linenums"><code>/**
 * @typedef {Object} utils.tools.rgb
 * @property {number} r - integer in [0;255]
 * @property {number} g - integer in [0;255]
 * @property {number} b - integer in [0;255]
 */
/**
 * @typedef {Object} utils.tools.hsv
 * @memberOf utils.tools
 * @property {number} h - integer in [0;359]
 * @property {number} s - integer in [0;255]
 * @property {number} v - integer in [0;255]
 */
/**
 * @namespace utils
 */
window.utils &#x3D; window.utils || {};
/**
 * @memberOf utils
 * @namespace tools
 */
utils.tools &#x3D; {
//######################################################################################################################
//#                                                    LayoutGravity                                                   #
//######################################################################################################################

	LayoutGravity: (function() {
		const LayoutGravity &#x3D; G &#x3D; {
			LEFT: 1, TOP: 2, RIGHT: 4, BOTTOM: 8, CENTER: 16,
			getRect: (gravity, availableRect, width, height, marginX&#x3D;0, marginY&#x3D;marginX)&#x3D;&gt; {
				availableRect &#x3D; availableRect.clone().addMarginsXY(-marginX, -marginY);
				if (!(gravity &amp;amp; G.CENTER)) {
					if (gravity) {
						if (!(gravity &amp;amp; G.LEFT) &amp;amp;&amp;amp; !(gravity &amp;amp; G.RIGHT)) gravity |&#x3D; G.LEFT;
						if (!(gravity &amp;amp; G.TOP) &amp;amp;&amp;amp; (gravity &amp;amp; G.BOTTOM)) gravity |&#x3D; G.TOP;
					} else gravity &#x3D; G.LEFT | G.TOP;
				}
				var left &#x3D; NaN, top &#x3D; NaN, right &#x3D; NaN, bottom &#x3D; NaN;
				if (gravity &amp;amp; G.CENTER) {
					let w &#x3D; (availableRect.width - width)/2, h &#x3D; (availableRect.h.height-height)/2;
					left &#x3D; availableRect.left + w; right &#x3D; availableRect.right - w;
					top &#x3D; availableRect.top + h; bottom &#x3D; availableRect.bottom - h;
				}
				if (gravity &amp;amp; G.LEFT !&#x3D;&#x3D; 0) left &#x3D; availableRect.left;
				if (gravity &amp;amp; G.TOP !&#x3D;&#x3D; 0) top &#x3D; availableRect.top;
				if (gravity &amp;amp; G.RIGHT !&#x3D;&#x3D; 0) right &#x3D; availableRect.right;
				if (gravity &amp;amp; G.BOTTOM !&#x3D;&#x3D; 0) bottom &#x3D; availableRect.bottom;
				if (isNaN(left)) left &#x3D; right - width;
				else if (isNaN(right)) right &#x3D; left + width;
				if (isNaN(top)) top &#x3D; bottom - height;
				else if (isNaN(bottom)) bottom &#x3D; top + height;
				return new Rect(left, top, right, bottom);
			},
			getHorizontalGravity: (g, defaultG &#x3D; null) &#x3D;&gt;
				(g &amp;amp; G.LEFT) ? G.LEFT : (g &amp;amp; G.RIGHT) ? G.RIGHT :
						(g &amp;amp; G.CENTER) ? G.CENTER :
							defaultG ? defaultG : G.LEFT,
			getVerticalGravity: (g, defaultG &#x3D; null) &#x3D;&gt;
				(g &amp;amp; G.TOP) ? G.TOP : (g &amp;amp; G.BOTTOM) ? G.BOTTOM :
						(g &amp;amp; G.CENTER) ? G.CENTER :
							defaultG ? defaultG : G.TOP
		};
		return LayoutGravity;
	})(),
//######################################################################################################################
//#                                                       filters                                                      #
//######################################################################################################################
	/**
	 * a filter to use with Array.prototype.filter function, by binding the first argument &amp;lt;!--
	 * --&gt;to the array elements you want to keep.
	 * @memberOf utils.tools
	 * @example [1,2,3,4].filter(utils.tools.intersectionFilter.bind(undefined, [1,4,5,6])); //[1,4]
	 * @param {Array} array
	 * @param {object} x
	 */
	intersectionFilter: (array, x) &#x3D;&gt; array.indexOf(x) !&#x3D;&#x3D; -1,
	/**
	 * a filter to use with Array.prototype.filter function, by binding the first argument &amp;lt;!--
	 * --&gt;to the array of element you want to exclude.
	 * @memberOf utils.tools
	 * @example [1,2,3,4].filter(utils.tools.exclusionFilter.bind(undefined, [1,4,5,6])); //[2,3]
	 * @param {Array} array
	 * @param {object} x
	 */
	exclusionFilter: (array, x) &#x3D;&gt; array.indexOf(x) &#x3D;&#x3D;&#x3D; -1,
	/**
	 * a filter to use with Array.prototype.filter function, by binding the first argument &amp;lt;!--
	 * --&gt;to the class you want your objects to be instances of.
	 * @memberOf utils.tools
	 * @param {class} _class
	 * @param {object} x
	 */
	instanceFilter : (_class, x) &#x3D;&gt; x instanceof _class,

//######################################################################################################################
//#                                                  color conversion                                                  #
//######################################################################################################################
	/**
	 * generates a random hex color
	 * @memberOf utils.tools
	 * @param {number} [octets&#x3D;3] - number of bytes this color will be on (4 3 or 1.5) (not checked)
	 * @returns {string}
	 */
	randomColor: (octets&#x3D;3) &#x3D;&gt; &#x27;#&#x27;+Math.random().toString(16).substr(2,2*octets),
	/**
	 * convert hsv color to rgb
	 * @memberOf utils.tools
	 * @param {number} h - integer in [0;359]
	 * @param {number} s - integer in [0;255]
	 * @param {number} v - integer in [0;255]
	 * @returns {utils.tools.rgb}
	 */
	HSVtoRGB: (h, s, v)&#x3D;&gt; {
		const i &#x3D; Math.floor(h * 6),
			f &#x3D; h * 6 - i,
			p &#x3D; Math.round((v * (1 - s))*255),
			q &#x3D; Math.round((v * (1 - f * s))*255),
			t &#x3D; Math.round((v * (1 - (1 - f) * s))*255);
		v &#x3D; Math.round(v*255);
		switch (i % 6) {
			case 0: return {r: v, g: t, b: p};
			case 1: return {r: q, g: v, b: p};
			case 2: return {r: p, g: v, b: t};
			case 3: return {r: p, g: q, b: v};
			case 4: return {r: t, g: p, b: v};
			case 5: return {r: v, g: p, b: q};
			default : return {r: 0, g: 0, b: 0};
		}
	},
	/**
	 * convert rgb color to hsv
	 * @memberOf utils.tools
	 * @param {number} r - integer in [0;255]
	 * @param {number} g - integer in [0;255]
	 * @param {number} b - integer in [0;255]
	 * @returns {utils.tools.hsv}
	 */
	RBGtoHSV : (r, g, b)&#x3D;&gt; {
		const max &#x3D; Math.max(r, g, b), min &#x3D; Math.min(r, g, b),
			d &#x3D; max - min,
			s &#x3D; (max &#x3D;&#x3D;&#x3D; 0 ? 0 : d / max),
			v &#x3D; max / 255;

		switch (max) {
			case min: return {h: 0, s: s, v: v};
			case r: return { h: ((g - b) + d * (g &amp;lt; b ? 6: 0))/(6*d), s: s, v: v};
			case g: return { h: ((b - r) + d * 2)/(6*d), s: s, v: v};
			case b: return { h: ((r - g) + d * 4)/(6*d), s: s, v: v};
			default : return {h: 0, s: 0, s: 0};
		}
	},
	/**
	 * convert rgb color to hexadecimal string formated color
	 * @memberOf utils.tools
	 * @param {number} r
	 * @param {number} g
	 * @param {number} b
	 * @returns {string}
	 */
	RGBToHex : (r, g, b)&#x3D;&gt; (r&gt;15?&#x27;#&#x27;:&#x27;#0&#x27;)+((r&amp;lt;&amp;lt;16)+(g&amp;lt;&amp;lt;8)+b).toString(16),
//######################################################################################################################
//#                                                    other methods                                                   #
//######################################################################################################################
	/**
	 * creates a mix of a superclass and several mixins to make a class extend a class and implements mixins.
	 * @memberOf utils.tools
	 * @example
	 * class A {
	 * 	 constructor(x) {
	 * 	   this.x &#x3D; x;
	 * 	 }
	 *   hello() {
	 *     alert(&#x27;hello &#x27; + this.x);
	 * 	 }
	 * };
	 * var B &#x3D; {
	 *   howRU() {
	 *     alert(&#x27;How are you ?&#x27;);
	 *   }
	 * };
	 * class C extends utils.tools.mix(A, B) {
	 *   constructor(x) {
	 *     super(x);
	 *	 }
	 *	 hello() {
	 *	   super.hello();
	 *	   this.howRU();
	 *	 }
	 * }
	 *
	 * var d &#x3D; new D(&#x27;John&#x27;);
	 * d.hello(); // alert(&#x27;Hi John !&#x27;); alert(&#x27;how are you ?&#x27;);
	 * @param {class} superclass
	 * @param {Object} mixins
	 * @returns {class}
	 */
	mix: (superclass, ...mixins) &#x3D;&gt; {
		class C extends superclass { }
		let len &#x3D; mixins.length, i &#x3D; -1;
		while (++i &amp;lt; len) utils.tools.merge(C.prototype, mixins[i], true);
		return C;
	},
	/**
	 * puts all properties of src in out. if override is false or not set, if a property, &amp;lt;!--
	 * --&gt;of src already exist in the parameter out, they are not overridden.
	 * @memberOf utils.tools
	 * @param {object} out
	 * @param {object} src
	 * @param {boolean} [override&#x3D;false]
	 */
	merge: (out, src, override &#x3D; false) &#x3D;&gt; {
		for (let p in src) if (src.hasOwnProperty(p) &amp;amp;&amp;amp; (override || !out.hasOwnProperty(p))) out[p] &#x3D; src[p];
	},
	/**
	 * gets a string returned by a specified url by calling the callback function with the returned &amp;lt;!--
	 * --&gt;text as argument.
	 * @memberOf utils.tools
	 * @param {string} url
	 * @param {function(string)} callback
	 */
	getStringFromUrl: (url, callback) &#x3D;&gt; {
		let client &#x3D; new XMLHttpRequest();
		client.open(&#x27;GET&#x27;, url);
		client.onreadystatechange &#x3D; _ &#x3D;&gt; callback(client.responseText);
		client.send();
	},
	/**
	 * creates a worker running the specified script
	 * @memberOf utils.tools
	 * @param {string} script
	 * @returns {Worker} newly created web worker runnning the script
	 */
	createScriptWorker: (script) &#x3D;&gt; {
		let blob &#x3D; new Blob([script],
			{type: &#x27;application/javascript&#x27;});
		let url &#x3D; URL.createObjectURL(blob)
		let worker &#x3D; new Worker(url);
		URL.revokeObjectURL(url)
		return worker;
	},
	/**
	 * replaces a function that does not exists by the same function with the vendor prefixes.
	 * @example
	 * polyfill(window, &#x27;requestAnimationFrame&#x27;, [&#x27;ms&#x27;, &#x27;moz&#x27;, &#x27;webkit&#x27;, &#x27;o&#x27;]);
	 * window.reaquestAnimationFrame(frameFunction);
	 * @param {Object} container
	 * @param {string} name
	 * @param {string[]} vendors
	 */
	polyfill: (container, name, vendors) &#x3D;&gt; {
		for(let i &#x3D; 0; i &amp;lt; vendors.length &amp;amp;&amp;amp; !container[name]; i++) {
			container[name] &#x3D; container[vendors[i] + name] ||
							  container[vendors[i] + name[0].toUpperCase() + name.substr(1)];
		}
	},
	textFileUserDownload(text, fileName) {
		var element &#x3D; document.createElement(&#x27;a&#x27;);
		element.setAttribute(&#x27;href&#x27;, &#x27;data:text/plain;charset&#x3D;utf-8,&#x27; + encodeURIComponent(text));
		element.setAttribute(&#x27;download&#x27;, fileName);
		element.style.display &#x3D; &#x27;none&#x27;;
		document.body.appendChild(element);
		element.click();
		document.body.removeChild(element);
	},
	/**
	 * convert text with BBcode to html text with equivalent balises
	 * @param {string} bbcode
	 * @returns {*}
	 * @constructor
	 */
	BBCodeToHTML(bbcode) {
		let str &#x3D; bbcode;
		str &#x3D; str.replace(/\[b](.+?)\[\/b]/g, &quot;&amp;lt;b&gt;$1&amp;lt;/b&gt;&quot;);

		str &#x3D; str.replace(/\[br\/]/g, &quot;&quot;);
		str &#x3D; str.replace(/\[br]/g, &quot;&quot;);

		str &#x3D; str.replace(/\[i](.+?)\[\/i]/g, &quot;&amp;lt;i&gt;$1&amp;lt;/i&gt;&quot;);

		str &#x3D; str.replace(/\[u](.+?)\[\/u]/g, &quot;&amp;lt;u&gt;$1&amp;lt;/u&gt;&quot;);

		str &#x3D; str.replace(/\[s](.+?)\[\/s]/g, &quot;&amp;lt;s&gt;$1&amp;lt;/s&gt;&quot;);

		str &#x3D; str.replace(/\[code](.+?)\[\/code]/g, &quot;&amp;lt;code&gt;$1&amp;lt;/code&gt;&quot;);
		str &#x3D; str.replace(/\[pre](.+?)\[\/pre]/g, &quot;&amp;lt;code&gt;$1&amp;lt;/code&gt;&quot;);

		str &#x3D; str.replace(/\[style (.+?)](.+?)\[\/style]/g, &#x27;&amp;lt;font $1&gt;$2&amp;lt;/font&gt;&#x27;);

		//str.replace(/#\[u](.+?)\[\/u]#si/g,&#x27;&amp;lt;span style&#x3D;&quot;text-decoration:underline;&quot;&gt;$1&amp;lt;/span&gt;&#x27;,$chaine );
		str &#x3D; str.replace(/\[size&#x3D;(.+?)](.+?)\[\/size]/g, &#x27;&amp;lt;span style&#x3D;&quot;font-size:$1px;&quot;&gt;$2&amp;lt;/span&gt;&#x27;);
		str &#x3D; str.replace(/\[color&#x3D;(.+?)](.+?)\[\/color]/g, &#x27;&amp;lt;span style&#x3D;&quot;color:$1;&quot;&gt;$2&amp;lt;/span&gt;&#x27;);


		str &#x3D; str.replace(/\[url&#x3D;([^]+)](.+?)\[\/url]/g,&#x27;&amp;lt;a href&#x3D;&quot;$1&quot;&gt;$2&amp;lt;/a&gt;&#x27;);
		str &#x3D; str.replace(/\[url](.+?)\[\/url]/g, &#x27;&amp;lt;a href&#x3D;&quot;$1&quot; target&#x3D;&quot;_blank&quot;&gt;$1&amp;lt;/a&gt;&#x27;);
		str &#x3D; str.replace(/\[img](.+?)\[\/img]/g, &#x27;&amp;lt;img src&#x3D;&quot;$1&quot; border&#x3D;&quot;0&quot;&gt;&#x27;);


		return str;
	},
	/**
	 *
	 * @param {string} wasmUrl - url to WebAssembly file.
	 * @param {object} importObject - objects to import in wasm
	 * @param {function({module, instance})} callback - called once the wasm module is loaded
	 */
	loadWASM(wasmUrl, imports) {
		return fetch(wasmUrl).then(response &#x3D;&gt;
			response.arrayBuffer()
		).then(bytes &#x3D;&gt;
			WebAssembly.instantiate(bytes, imports)
		);
	},
	instanciateWASM(wasmUrl, imports) {
		return utils.tools.loadWASM(wasmUrl, imports).then(results &#x3D;&gt; results.instance);
	}
};
console.stack &#x3D; ( str ) &#x3D;&gt;{
	console.error(new Error(str).stack);
};
console.deprecated &#x3D; ( str ) &#x3D;&gt;{
	console.stack(&#x27;deprecated : &#x27; + str);
};
/**
 *
 * @param {number} min
 * @param {number} max
 * @return {number} random number between min and max
 */
Math.rangedRandom &#x3D; ( min, max ) &#x3D;&gt; Math.random()*(max-min)+min;
/**
 * generate a pseudo-gaussian random number in ]-1;1[
 * @return {number}
 */
Math.gaussianRandom &#x3D; () &#x3D;&gt; (Math.random()+Math.random()+Math.random()
							+Math.random()+Math.random()+Math.random()-3)/3;

CanvasRenderingContext2D.prototype.wrapText &#x3D; function (text, rect, lineHeight, textGravity, fill &#x3D; true, stroke &#x3D; false) {
	let paragraphs &#x3D; text.split(&#x27;\n&#x27;);
	let parLen &#x3D; paragraphs.length;
	let lines &#x3D; [], line;
	let linesX &#x3D; [], lineX &#x3D; 0;
	let words, len;
	let testLine;
	let metrics;
	let width &#x3D; 0;
	let rectWidth &#x3D; rect.width;
	let n;
	for (let i &#x3D; 0; i &amp;lt; parLen; i++) {
		words &#x3D; paragraphs[i].split(&#x27; &#x27;);
		len &#x3D; words.length;
		if (!len) {
			lines.push(paragraphs[i]);
			linesX.push(0);
			continue;
		}
		line &#x3D; words[0];
		for (n &#x3D; 1; n &amp;lt; len; n++) {
			testLine &#x3D; line + &#x27; &#x27; + words[n];
			metrics &#x3D; this.measureText(testLine);
			width &#x3D; metrics.width;
			if (width &gt; rectWidth &amp;amp;&amp;amp; n &gt; 0) {
				lineX &#x3D; rect.left;
				if (!(textGravity &amp;amp; Gravity.LEFT)) {
					if (textGravity &amp;amp; Gravity.RIGHT) lineX +&#x3D; this.measureText(line).width - width;
					else if (textGravity &amp;amp; Gravity.CENTER) lineX +&#x3D; (this.measureText(line).width - width) / 2;
				}
				lines.push(line);
				line &#x3D; words[n];
				linesX.push(lineX);
			}
			else {
				line &#x3D; testLine;
			}
		}
		lineX &#x3D; rect.left;
		if (!(textGravity &amp;amp; Gravity.LEFT)) {
			metrics &#x3D; this.measureText(line);
			width &#x3D; metrics.width;
			if (textGravity &amp;amp; Gravity.RIGHT) lineX +&#x3D; rectWidth - width;
			else if (textGravity &amp;amp; Gravity.CENTER) lineX +&#x3D; (rectWidth - width) / 2;
		}
		lines.push(line);
		linesX.push(lineX);
	}
	len &#x3D; lines.length;
	var y &#x3D; rect.top + lineHeight;
	if (!(textGravity &amp;amp; Gravity.TOP)) {
		if (textGravity &amp;amp; Gravity.BOTTOM) y &#x3D; rect.bottom - lineHeight * (len - 1);
		else if (textGravity &amp;amp; Gravity.CENTER) y +&#x3D; (rect.height - lineHeight * len) / 2;
	}
	for (n &#x3D; 0; n &amp;lt; len; n++) {
		if (fill)   this.fillText(lines[n], linesX[n], y);
		if (stroke) this.strokeText(lines[n], linesX[n], y);
		y +&#x3D; lineHeight;
	}
};
let asm &#x3D; {};
var wasmImports &#x3D; {
	env: {
		rand: Math.random
	}
};
let wasmCode &#x3D; new Uint8Array([
	0,97,115,109,1,0,0,0,1,139,128,128,128,0,2,96,0,1,125,96,2,125,125,1,125,2,140,128,128,128,0,1,3,101,110,118,4,114,
	97,110,100,0,0,3,130,128,128,128,0,1,1,4,132,128,128,128,0,1,112,0,0,5,131,128,128,128,0,1,0,1,6,129,128,128,128,0,
	0,7,151,128,128,128,0,2,6,109,101,109,111,114,121,2,0,10,114,97,110,103,101,100,82,97,110,100,0,1,10,147,128,128,
	128,0,1,141,128,128,128,0,0,32,1,32,0,147,16,0,148,32,0,146,11
]);
WebAssembly.instantiate(wasmCode, wasmImports).then(wasm&#x3D;&gt;{
	asm &#x3D; wasm.instance.exports;
	//Math.rangedRandom &#x3D; asm.rangedRand;
});
</code></pre>
          </article>
        </div>
      </div>
      <nav id="jsdoc-toc-nav" role="navigation"></nav>
    </div>
  </div>
  <footer id="jsdoc-footer" class="jsdoc-footer">
    <div id="jsdoc-footer-container">
      <p>
        Generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc</a> 3.4.3 on September 2, 2017.
      </p>
    </div>
  </footer>
  <script src="scripts/jquery.min.js"></script>
  <script src="scripts/jquery.cookie.js"></script>
  <script src="scripts/tree.jquery.js"></script>
  <script src="scripts/prettify.js"></script>
  <script src="scripts/jsdoc-toc.js"></script>
  <script src="scripts/linenumber.js"></script>
  <script src="scripts/scrollanchor.js"></script>
</body>

</html>