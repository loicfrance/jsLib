<!doctype html>
<html>

<head>
  <meta name="generator" content="JSDoc 3.4.3">
  <meta charset="utf-8">
  <title>Source: game2/bullets.js</title>
  <link rel="stylesheet" href="https://brick.a.ssl.fastly.net/Karla:400,400i,700,700i" type="text/css">
  <link rel="stylesheet" href="https://brick.a.ssl.fastly.net/Noto+Serif:400,400i,700,700i" type="text/css">
  <link rel="stylesheet" href="https://brick.a.ssl.fastly.net/Inconsolata:500" type="text/css">
  <link href="css/baseline.css" rel="stylesheet">
</head>

<body onload="prettyPrint()">
  <nav id="jsdoc-navbar" role="navigation" class="jsdoc-navbar">
    <div id="jsdoc-navbar-container">
      <div id="jsdoc-navbar-content">
        <a href="index.html" class="jsdoc-navbar-package-name">Home</a>
      </div>
    </div>
  </nav>
  <div id="jsdoc-body-container">
    <div id="jsdoc-content">
      <div id="jsdoc-content-container">
        <div id="jsdoc-banner" role="banner">
        </div>
        <div id="jsdoc-main" role="main">
          <header class="page-header">
            <h1>Source: game2/bullets.js</h1>
          </header>
          <article>
            <pre class="prettyprint linenums"><code>/**
 * Created by rfrance on 12/20/2016.
 */
//######################################################################################################################
//#                                                       Bullet                                                       #
//######################################################################################################################
window.game.Bullet &#x3D; (function() {
	/**
	 * @class game.Bullet
	 * @memberOf game
	 * @augments game.Object
	 * @classdesc a simple object defining a bullet, i.e an object that deals damages to the first object &amp;lt;!--
	 * --&gt;it touches (if the object can receive damages), and die when it happens.
	 */
	class Bullet extends game.Object {
		/**
		 * @constructor
		 * @param {game.Object} launcher
		 * @param {utils.geometry2d.Vec2} position
		 * @param {utils.geometry2d.Vec2} speed
		 * @param {number} damages
		 * @param {number} [lifeTime&#x3D;0]
		 */
		constructor(launcher, position, speed, damages, lifeTime&#x3D;0) {
			super(position, speed);
			/**
			 * @name game.Bullet#damages
			 * @type {number}
			 */
			this.damages &#x3D; damages;
			if(lifeTime)
				/**
				 * @name game.Bullet#lifeTime
				 * @type {number}
				 */
				this.lifeTime &#x3D; lifeTime;
			/**
			 * @name game.Bullet#launcher
			 * @type {game.Object}
			 */
			this.launcher &#x3D; launcher;

		}
		/**
		 * sets the launcher of the bullet
		 * @param {game.Object} object
		 */
		setLauncher( object ) { this.launcher &#x3D; object; }

		/**
		 * returns the launcher of the bullet
		 * @returns {game.Object}
		 */
		getLauncher() { return this.launcher; }
		/**
		 * sets the damages dealt by the bullet on the impact
		 * @param {number} value
		 */
		setDamages( value ) { this.damages &#x3D; value; }
		/**
		 * returns the damages dealt by the bullet on the impact
		 * @returns {number}
		 */
		getDamages() { return this.damages; }
		/**
		 * called by the game manager every frame. moves the bullet.
		 * @param {game.GameManager} gameManager
		 * @param {number} dT
		 */
		onFrame( gameManager, dT ) {
			super.onFrame(gameManager, dT);
			if(this.lifeTime !&#x3D;&#x3D; undefined) {
				if(this.lifeTime &amp;lt;&#x3D;0) this.kill(gameManager);
				this.lifeTime -&#x3D; dT;
			}
		}
		/**
		 * called once a frame. moves the bullet according to its speed. if the bullet goes out &amp;lt;!--
		 * --&gt;of the game rectangle, is is destroyed.
		 * @param {game.GameManager} gameManager
		 * @param {number} dT
		 */
		moveOnFrame( gameManager, dT ) {
			super.moveOnFrame(gameManager, dT);
			if(this.isOutOfRect(gameManager.gameRect)) {
				this.kill(gameManager);
			}
		}
		/**
		 * tells if the bullet can collide withe the specified object. returns true if the object is not its launcher
		 * @param {?game.Object} object
		 * @returns {boolean}
		 */
		canCollide( object ) { return this.collider !&#x3D;&#x3D; undefined &amp;amp;&amp;amp; object !&#x3D;&#x3D; this.launcher; }

		/**
		 * called when the collision is confirmed between the bullet and the specified object
		 * @param {game.GameManager} gameManager
		 * @param {game.Object} object
		 */
		onCollision( gameManager, object ) {
			if(this.damages &amp;amp;&amp;amp; object.receiveDamages) {
				object.receiveDamages(gameManager, this.damages);
				if(this.killOnCollision) {
					this.damages &#x3D; 0;
					this.kill(gameManager);
				}
			} else if(this.killOnCollision &amp;amp;&amp;amp; this.damages) {
				this.kill(gameManager);
			}
		}
	}
	Bullet.defaultShape &#x3D; utils.geometry2d.Polygon.Absolute(utils.geometry2d.Vec2.createVec2Array([
		-10,2,   5,2,   7,1,   8,0,   7,1,   5,-2,   -10,-2
	]));
	Bullet.prototype.renderLayer &#x3D; game.RenderLayer.OBJ3;
	Bullet.prototype.killOnCollision &#x3D; true;
    return Bullet;
})();
//######################################################################################################################
//#                                                   BulletCollider                                                   #
//######################################################################################################################
window.game.BulletCollider &#x3D; (function() {
	/**
	 * @class game.BulletCollider
	 * @memberOf game
	 * @augments game.ShapedObjectCollider
	 * @classdesc the collider to use with bullets. the difference with a standard shaped collider is that &amp;lt;!--
	 * --&gt;it can collide when it is inside an object but not touching the outline. it allows bullets to go faster &amp;lt;!--
	 * --&gt;than normal objects even if they are small, because the collision will happen event if the the object moves &amp;lt;!--
	 * --&gt;too fast to intersect with the outline of the opposite object&#x27;s collider.
	 */
    class BulletCollider extends game.ShapedObjectCollider {
		/**
		 * @constructor
		 * @param {utils.geometry2d.Shape} shape
		 */
		constructor(shape) {
			super(shape);
		}
		/**
		 * returns true because bullets collide when they are inside other objects.
		 * @param {game.ObjectCollider} collider
		 * @returns {boolean}
		 */
		collidesInside( collider ) { return true; }
    }

	return BulletCollider;
})();
//######################################################################################################################
//#                                                   BulletCollider                                                   #
//######################################################################################################################
window.game.HomingBullet &#x3D; (function() {
	let Vec2 &#x3D; utils.geometry2d.Vec2;
	let getSteeringForce &#x3D; ( objPos,maxSpd,maxForce,currentSpd,targetPos )&#x3D;&gt;
		Vec2.translation(objPos, targetPos).setMagnitude(maxSpd)
			.remove(currentSpeed).clampMagnitude(0, maxForce);// maxSpeed&#x3D;0, steerForce&#x3D;0, getTarget&#x3D;0
	/**
	 * @class HomingBullet
	 * @memberOf game
	 * @augments game.Bullet
	 * @classdesc a type of bullet that has a homing property : it searches for the best target to avoid &amp;lt;!--
	 * --&gt;direction changes, and changes it&#x27;s direction to touch it.
	 */
    class HomingBullet extends game.Bullet {
		/**
		 * @constructor
		 * @param {game.Object} launcher
		 * @param {number} damages
		 * @param {utils.geometry2d.Vec2} position
		 * @param {utils.geometry2d.Vec2} speed
		 * @param {number} lifeTime
		 * @param {number} steerForce
		 * @param {number} maxAngle
		 */
		constructor(launcher, damages, position, speed, lifeTime, steerForce, maxAngle) {
			super(launcher, position, speed, damages, lifeTime);
			/**
			 * @name game.HomingBullet#steerForce
			 * @type {number}
			 */
			this.steerForce &#x3D; steerForce;
			/**
			 * @name game.HomingBullet#maxSpeed
			 * @type {number}
			 */
			this.maxSpeed &#x3D; speed.magnitude;
			/**
			 * @name game.HomingBullet#maxAngle
			 * @type {number}
			 */
			this.maxAngle &#x3D; maxAngle;
			this.angle &#x3D; 0;
			this.setAccelerationXY(0,0);
		}
		/**
		 * return the maximum speed the bullet can reach depending on the distance to the target.
		 * @param {number} distance
		 * @returns {number}
		 */
		getMaxSpeed( distance ) {
			return this.maxSpeed*(1-Math.sqrt(this.maxSpeed/(150*distance)));
		}
		/**
		 * a method for private use only. returns the appropriate steer force the bullet have to use &amp;lt;!--
		 * --&gt;to aim to its target, depending on its maximum speed and the distance to its target.
		 * @param {number} maxSpeed - result  of the {@link game.HomingBullet#getMaxSpeed|getMaxSpeed} method.
		 * @param {number} distance
		 * @returns {number}
		 */
		getSteerForce( maxSpeed, distance) {
			return this.steerForce*(maxSpeed/Math.pow(distance, 1.2));
		}
		/**
		 * method for private use only. returns the target position to aim to, or null if no target was found.
		 * @param {game.GameManager} gameManager
		 * @returns {?utils.geometry2d.Vec2}
		 */
		getTargetPosition( gameManager ) {
			let res, angle,
				maxAngle &#x3D; this.maxAngle,
				pos &#x3D; this.getPosition(),
				//dist &#x3D; 0,
				targets &#x3D; gameManager.getObjects(game.Object.collisionLayersFilter.bind(undefined, this.bodyLayer)),
				i &#x3D; targets.length;
			while(i--) {
				if(targets[i] !&#x3D;&#x3D; this.launcher) {
					angle &#x3D; (Vec2.translation(pos, targets[i].getPosition()).angle-this.radians) % (Math.PI*2);
					if(angle &gt; Math.PI) angle &#x3D; Circle.PI2-angle;
					if(angle &amp;lt; maxAngle) {
						maxAngle &#x3D; angle;
						res &#x3D; targets[i];
					}   }   }
			return res? res.getPosition() : null;
		}

		/**
		 * called every frame by the game manager. does the usual frame work, calculate the target position, &amp;lt;!--
		 * --&gt;and set the acceleration to hit it. makes sure the speed do not exceed the maximum.
		 * @param {game.GameManager} gameManager
		 * @param {number} dT
		 */
		onFrame( gameManager, dT ) {
			let t &#x3D; this.getTargetPosition(gameManager);
			if(t) {
				let p &#x3D; this.getPosition(), accel &#x3D; Vec2.translation(p, t),
					d &#x3D; accel.magnitude, ms &#x3D; this.getMaxSpeed(dist), steer &#x3D; this.getSteerForce(ms, d);
				accel.magnitude &#x3D; steer;
				accel.add(Game.objects.properties.Homing.getSteeringForce(
					pos, maxSpeed, steer,
					this.getSpeed(), target)).magnitude &#x3D; steer;
				this.setAcceleration(accel);
				super.onFrame(gameManager, dT);
				this.setSpeed(this.getSpeed().clampMagnitude(0, maxSpeed));
			} else {
				this.setAccelerationXY(0,0);
				super.onFrame(gameManager, dT);
			}
			this.setRadians(this.getSpeed().angle);
		}
    }
    return HomingBullet;
})();</code></pre>
          </article>
        </div>
      </div>
      <nav id="jsdoc-toc-nav" role="navigation"></nav>
    </div>
  </div>
  <footer id="jsdoc-footer" class="jsdoc-footer">
    <div id="jsdoc-footer-container">
      <p>
        Generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc</a> 3.4.3 on September 2, 2017.
      </p>
    </div>
  </footer>
  <script src="scripts/jquery.min.js"></script>
  <script src="scripts/jquery.cookie.js"></script>
  <script src="scripts/tree.jquery.js"></script>
  <script src="scripts/prettify.js"></script>
  <script src="scripts/jsdoc-toc.js"></script>
  <script src="scripts/linenumber.js"></script>
  <script src="scripts/scrollanchor.js"></script>
</body>

</html>