<!doctype html>
<html>

<head>
  <meta name="generator" content="JSDoc 3.4.3">
  <meta charset="utf-8">
  <title>Source: game2/manager.js</title>
  <link rel="stylesheet" href="https://brick.a.ssl.fastly.net/Karla:400,400i,700,700i" type="text/css">
  <link rel="stylesheet" href="https://brick.a.ssl.fastly.net/Noto+Serif:400,400i,700,700i" type="text/css">
  <link rel="stylesheet" href="https://brick.a.ssl.fastly.net/Inconsolata:500" type="text/css">
  <link href="css/baseline.css" rel="stylesheet">
</head>

<body onload="prettyPrint()">
  <nav id="jsdoc-navbar" role="navigation" class="jsdoc-navbar">
    <div id="jsdoc-navbar-container">
      <div id="jsdoc-navbar-content">
        <a href="index.html" class="jsdoc-navbar-package-name">Home</a>
      </div>
    </div>
  </nav>
  <div id="jsdoc-body-container">
    <div id="jsdoc-content">
      <div id="jsdoc-content-container">
        <div id="jsdoc-banner" role="banner">
        </div>
        <div id="jsdoc-main" role="main">
          <header class="page-header">
            <h1>Source: game2/manager.js</h1>
          </header>
          <article>
            <pre class="prettyprint linenums"><code>/**
 * Created by rfrance on 12/25/2016.
 */
/**
 * @namespace game
 */
window.game &#x3D; {
//######################################################################################################################
//#                                             enumerations and callbacks                                             #
//######################################################################################################################
	/**
	 * @callback game.gameEventCallback
	 * @param {game.GameEvent} event
	 * @param {number} dT - time since last frame (0 if not necessary).
	 * @param {game.Object} object - object related to the event (null if not necessary)
	 */
	/**
	 * @callback game.renderEventCallback
	 * @param {game.RenderEvent} event
	 * @param {CanvasRenderingContext2D} context
	 */
	/**
	 * an enumeration for game events. Some values are never used by the game engine itself, &amp;lt;!--
	 * --&gt;but you can use them yourself
	 * @readonly
	 * @enum {number}
	 * @memberOf game
	 */
	GameEvent: {
		/** a frame just began */
		GAME_FRAME 		 : 1,
		/** the game just resumed/started */
		GAME_START 		 : 2,
		/** the game just stopped/paused */
		GAME_STOP  		 : 3,
		/**
		 * an object as been created (never called automatically).
		 * @see game.GameManager#fireObjectCreatedEvent
		 */
		OBJECT_CREATED   : 4,
		/**
		 * an object as been destroyed (never called automatically)
		 * @see game.GameManager#fireObjectDestroyedEvent
		 */
		OBJECT_DESTROYED : 5
	},
	/**
	 * @memberOf game
	 * @enum {number}
	 */
	RenderEvent: {
		RENDER_BEGIN : 6,
		RENDER_END : 7,
		RENDER_LAYER_BEGIN : 8,
		RENDER_LAYER_END : 9,
		CANVAS_RESIZE : 10
	},
	/**
	 * @memberOf game
	 * @enum {number}
	 */
	RenderLayer: {
		NONE : -1,
		BG1 : 0,
		BG2 : 1,
		BG3 : 2,
		OBJ1 : 3,
		OBJ2 : 4,
		OBJ3 : 5,
		PARTICLES : 6,
		UI : 7
	},
//######################################################################################################################
//#                                                       filters                                                      #
//######################################################################################################################
	/**
	 * a filter used by the game manager by binding the first argument to a&amp;lt;!--
	 * --&gt;rendering layer to get all objects of the same render layer. Feel free to use this filter.
	 * @static
	 * @param {number} layer
	 * @param {game.Object} obj
	 * @returns {boolean}
	 */
	renderLayerFilter: (layer, obj) &#x3D;&gt; obj.renderLayer &#x3D;&#x3D;&#x3D; layer,
	/**
	 * a filter used by the viewer to remove from the array all objects that are not renderable (renderLayer &amp;lt; 0). &amp;lt;!--
	 * --&gt;Feel free to use this filter.
	 * @static
	 * @param {game.Object} obj
	 * @returns {boolean}
	 */
	renderableFilter: (obj)&#x3D;&gt; obj.renderLayer &gt;&#x3D; 0,
	/**
	 * a comparison function used by the game map to sort the objects in the reverse rendering order, &amp;lt;!--
	 * --&gt;because the function starts by the end of the array
	 * @param {game.Object} obj1
	 * @param {game.Object} obj2
	 * @returns {number}
	 */
	renderLayerSort: (obj1, obj2) &#x3D;&gt; obj1.renderLayer - obj2.renderLayer,
	/**
	 * a filter used by the game manager by binding the first argument to layers to get all objects &amp;lt;!--
	 * --&gt;with a {@link game.Object#bodyLayer|bodyLayer} inside one of those layers. Feel free to use this filter.
	 * @static
	 * @param {number[]}layers
	 * @param {game.Object} obj
	 * @returns {boolean}
	 */
	bodyLayerFilter: (layers, obj) &#x3D;&gt; layers.indexOf(obj.bodyLayer) &gt;&#x3D; 0,
	/**
	 * a filter used by the game manager by binding the first argument to a layer to get all objects &amp;lt;!--
	 * --&gt;able to intersect with an object having its {@link game.Object#bodyLayer|bodyLayer} equal to this layer. &amp;lt;!--
	 * --&gt;Feel free to use this filter.
	 * @static
	 * @param {number} layer
	 * @param {game.Object} obj
	 * @returns {boolean}
	 */
	collisionLayersFilter: (layer, obj) &#x3D;&gt; obj.collisionLayers.indexOf(layer) &gt;&#x3D; 0,
	/**
	 * a filter used by the game manager to get all objects able to collide, i.e. with a &amp;lt;!--
	 * --&gt;{@link game.Object#bodyLayer|bodyLayer} &gt;&#x3D; 0. Feel free to use this filter.
	 * @static
	 * @param {game.Object} obj
	 * @returns {boolean}
	 */
	canCollideFilter: (obj) &#x3D;&gt; obj.bodyLayer &gt;&#x3D; 0 &amp;amp;&amp;amp; obj.canCollide(),
	/**
	 * a sort function used by the game manager to sort object by their collision priority.
	 * @static
	 * @param {game.Object} obj1
	 * @param {game.Object} obj2
	 * @returns {number} -1, 0 or 1
	 */
	collisionPrioritySort: (obj1, obj2) &#x3D;&gt; obj1.collisionPriority - obj2.collisionPriority

}
//######################################################################################################################
//#                                                     GameManager                                                    #
//######################################################################################################################
window.game.GameManager &#x3D; (function(){
	/**
	 * @class game.GameManager
	 * @memberOf game
	 * @classdesc the most important class of a game. call the frame, death and collision methods of all objects, &amp;lt;!--
	 * --&gt;call the render method of the viewer, ...
	 * To add an object to the game, you must call the {@link game.GameManager#addObject|addObject} method, and to &amp;lt;!--
	 * --&gt;remove an object, you must call the {@link game.GameManager#removeObject|removeObject} method.
	 * This way, {@link game.Object#onDeath} method of the destroyed objects when they are removed from the game.
	 * To start or resume the game, call the {@link game.GameManager#start|start} method, &amp;lt;!--
	 * --&gt;and to pause or stop the game, call the {@link game.GameManager#stop|stop} method. You can get &amp;lt;!--
	 * --&gt;the current state (running or not) by calling the {@link game.GameManager#isRunning|isRunning} method.
	 * You can apply a {@link game.gameEventCallback|callback} method which will be called when the game &amp;lt;!--
	 * --&gt;is started or resumed, when it is stopped or paused, and when a frame begins.
	 */
	class GameManager {
		constructor() {
//______________________________________________________________________________________________________________________
// - - - - - - - - - - - - - - - - - - - - - - - - - - -attributes- - - - - - - - - - - - - - - - - - - - - - - - - - -
//**********************************************************************************************************************

//------------------------------------------------- private attributes -------------------------------------------------
			let objects &#x3D; [];
			let objectsToAdd &#x3D; [];
			let objectsToRemove &#x3D; [];
			let objects_length &#x3D; 0;
			let lastStamp &#x3D; 0;
			let callback &#x3D; null;
			let running &#x3D; false;
//-------------------------------------------------- public attributes -------------------------------------------------
			/**
			 * @name game.GameManager#viewer
			 * @type {?game.Viewer}
			 */
			this.viewer &#x3D; null;
			/**
			 * @name game.GameManager#gameRect
			 * @type {utils.geometry2d.Rect}
			 */
			this.gameRect &#x3D; new utils.geometry2d.Rect(0,0,1240,720);
			/**
			 * time difference between 2 frames. if &amp;lt; 0, the difference will be the real one, &amp;lt;!--
			 * --&gt;clamped in [0 ; 0.1] sec. default is 1/60 sec
			 * @name game.GameManager#fixedDt
			 * @type {number}
			 */
			this.fixedDt &#x3D; 1/60;
//______________________________________________________________________________________________________________________
// - - - - - - - - - - - - - - - - - - - - - - - - - - - -methods - - - - - - - - - - - - - - - - - - - - - - - - - - -
//**********************************************************************************************************************

//--------------------------------------------------- objects methods --------------------------------------------------
// -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -getters  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -
			/**
			 * get all objects of the game matching the specified filter
			 * @method
			 * @name game.GameManager#getObjects
			 * @param {function(game.Object):boolean} [filter&#x3D;null]
			 * @returns {game.Object[]}
			 */
			this.getObjects &#x3D; function( filter &#x3D; null ) {
				return filter ?  objects.filter(filter) : objects;
			};
			/**
			 * get the index of the object in the game&#x27;s list of objects.
			 * @method
			 * @name game.GameManager#getObjectIndex
			 * @param {game.Object} obj
			 * @returns {number} index of obj
			 */
			this.getObjectIndex &#x3D; function( obj ) {
				return objects.indexOf(obj);
			};
			/**
			 * returns the object located at the specified index.
			 * @method
			 * @name game.GameManager#getObjectAt
			 * @param {number} index
			 * @returns {game.Object}
			 */
			this.getObjectAt &#x3D; function( index ) {
				return objects[index];
			};
			/**
			 * returns all instances of the specified gameObject class.
			 * @method
			 * @name game.GameManager#getInstancesOf
			 * @param {class} objClass
			 * @returns {game.Object[]}
			 */
			this.getInstancesOf &#x3D; function( objClass ) {
				return this.getObjects(tools.instanceFilter.bind(undefined, objClass));
			};
// -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -adders-  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -
			/**
			 * adds an object to the game. It will actually be added between the current frame and the next one.
			 * @method
			 * @name game.GameManager#addObject
			 * @param {?game.Object} obj
			 * @param {boolean} [check&#x3D;true] - if true or not set, the method will make sure the object is not &amp;lt;!--
			 * --&gt;already being added to the game
			 */
			this.addObject &#x3D; function( obj, check&#x3D;true ) {
				if(check &amp;amp;&amp;amp; objectsToAdd.indexOf(obj)!&#x3D;&#x3D;-1)
					console.stack(&quot;the object &quot; + obj + &quot; is already being added to the game&quot;);
				else objectsToAdd.push(obj);
			};
			/**
			 * adds several objects to the game. They will be added between the current frame and the next one
			 * @method
			 * @name game.GameManager#addObjects
			 * @param {game.Object[]} objects
			 * @param {boolean} [check&#x3D;true] - if true or not set, the method will only add objects that are not &amp;lt;!--
			 * --&gt;already being added to the game
			 */
			this.addObjects &#x3D; function( objects, check&#x3D;true ) {
				Array.prototype.push.apply(objectsToAdd,
					check ? objects.filter(tools.exclusionFilter.bind(undefined, objectsToAdd))
						: objects);
			};
// -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  removers  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -
			/**
			 * removes an object from the game. It will actually be removed between the current frame &amp;lt;!--
			 * --&gt;and the next one, before new objects are added.
			 * @method
			 * @name game.GameManager#removeObject
			 * @param {game.Object} obj
			 * @param {boolean} [check&#x3D;true] - if true or not set, the method will make sure the object is not &amp;lt;!--
			 * --&gt;already being removed from the game
			 */
			this.removeObject &#x3D; function( obj, check&#x3D;true ) {
				if(check &amp;amp;&amp;amp; objectsToRemove.indexOf(obj) !&#x3D;&#x3D; -1)
					console.stack(&quot;the object &quot; + obj + &quot; is already being removed from the game&quot;);
				else objectsToRemove.push(obj);
			};
			/**
			 * removes several objects from the game. They will be removed between the current frame &amp;lt;!--
			 * --&gt;and the next one, before new objects are added
			 * @method
			 * @name game.GameManager#removeObjects
			 * @param {game.Object[]} objects
			 * @param {boolean} [check&#x3D;true] - if true or not set, the method will only remove objects that are not &amp;lt;!--
			 * --&gt;already being removed to the game
			 */
			this.removeObjects &#x3D; function( objects, check&#x3D;true ) {
				Array.prototype.push.apply(objectsToRemove,
					check ? objects.filter(tools.exclusionFilter.bind(undefined, objectsToRemove))
						: objects);
			};
			/**
			 * removes all current objects from the game. They will be removed between the current frame &amp;lt;!--
			 * --&gt;and the next one, before new objects are added.
			 * This method does not prevent objects that are about to be added to appear.
			 * @method
			 * @name game.GameManager#clearObjects
			 */
			this.clearObjects &#x3D; function() {
				this.removeObjects(objects);
			};
//--------------------------------------------------- events methods ---------------------------------------------------
			/**
			 * starts or resumes the game, and call the callback method with first parameter &amp;lt;!--
			 * equal to {@link game.GameEvent.GAME_START}, and the second one equal to 0.
			 * @method
			 * @name game.GameManager#start
			 */
			this.start &#x3D; function() {
				running &#x3D; true;
				lastStamp &#x3D; 0;
				if(callback) callback(game.GameEvent.GAME_START, 0, null);
				requestAnimationFrame(onFrame.bind(this));
			};
			/**
			 * stops or pauses the game, and call the callback method with first parameter &amp;lt;!--
			 * equal to {@link game.GameEvent.GAME_STOP}, and the second one equal to 0.
			 * @method
			 * @name game.GameManager#stop
			 */
			this.stop &#x3D; function() {
				running &#x3D; false;
				if(callback) callback(game.GameEvent.GAME_STOP, 0, null);
			};
			/**
			 * tells if the game is currently running.
			 * @returns {boolean}
			 * @method
			 * @name game.GameManager#isRunning
			 */
			this.isRunning &#x3D; function () {
				return running;
			};
			/**
			 * sets the callback method called for events.
			 * @method
			 * @name game.GameManager#setEventsCallback
			 * @param {?game.gameEventCallback} cb
			 */
			this.setEventsCallback &#x3D; function( cb ) {
				callback &#x3D; cb;
			};
			/**
			 * returns the callback method called for events, or null if not set
			 * @method
			 * @name game.GameManager#getEventsCallback
			 * @returns {?game.gameEventCallback}
			 */
			this.getEventsCallback &#x3D; function() {
				return callback;
			};
			/**
			 * calls the callback (if present) for the event {@link game.GameEvent.OBJECT_CREATED} with &amp;lt;!--
			 * --&gt;the specified object as the third parameter. (Second parameter &#x3D; 0)
			 * @param {game.Object} object -  the newly created object.
			 */
			this.fireObjectCreatedEvent &#x3D; function(object) {
				if(callback) callback(game.GameEvent.OBJECT_CREATED, 0, object);
			};
			/**
			 * calls the callback (if present) for the event {@link game.GameEvent.OBJECT_DESTROYED} with &amp;lt;!--
			 * --&gt;the specified object as the third parameter. (Second parameter &#x3D; 0)
			 * @param {game.Object} object -  the destroyed object.
			 */
			this.fireObjectDestroyedEvent &#x3D; function(object) {
				if(callback) callback(game.GameEvent.OBJECT_DESTROYED, 0, object);
			};
// -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -onFrame  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -
			let onFrame &#x3D; function(timeStamp) {
				let obj, index &#x3D; -1, i, dT, j, bodies, len, other, collidingObjs;
				if(running) {
					// 1 : remove dead objects
					while (obj &#x3D; objectsToRemove.pop()) {
						index &#x3D; objects.indexOf(obj);
						if (index &gt; -1) {
							obj.onDeath(this);
							objects.splice(index, 1);
							objects_length--;
						}
					}
				}
				// 2 : render all objects on the screen
				if(this.viewer) {
					this.viewer.render(this, objects);
				}
				if(running) {
					// 3 : add new objects
					while(obj&#x3D;objectsToAdd.pop()) {
						objects.push(obj);
						objects_length++;
					}
					// 4 : get dT
					if(this.fixedDt &gt;&#x3D; 0) {
						dT &#x3D; this.fixedDt;
						if(timeStamp &#x3D;&#x3D; lastStamp) return;
					}
					else {
						dT &#x3D; (timeStamp - lastStamp)/1000;
						if(dT &gt; 0.1) dT &#x3D; 0.1;
						if(!dT) return;
					}
					lastStamp &#x3D; timeStamp;
					// 5 : call callback method
					if(callback) callback(game.GameEvent.GAME_FRAME, dT, null);
					// 6 : call onFrame of all objects
					i &#x3D; objects_length;
					while(i--) objects[i].onFrame(this, dT);
					// 7 : get all objects with a collider
					bodies &#x3D; objects.filter(game.canCollideFilter).sort(game.collisionPrioritySort);
					len &#x3D; bodies.length;
					if(len) {
						i &#x3D; len;
						collidingObjs &#x3D; [];
						// 8 : for each object, prepare the collision
						while(i--) bodies[i].prepareCollision();
						while(obj &#x3D; bodies.pop()) {
							if(obj.collisionPriority &amp;lt; 0) break;
							// 9 : get all other objects able to collide with the object
							other &#x3D; bodies.filter(game.collisionLayersFilter.bind(undefined, obj.bodyLayer));
							j &#x3D; other.length;
							while(j--) {
								// 10 : check collision
								if(obj.canCollide(other[j]) &amp;amp;&amp;amp; other[j].canCollide(obj) &amp;amp;&amp;amp; obj.collides(other[j])) {
									// 11 : add the object to the list of colliding objects
									collidingObjs.push(other[j]);
								}
							}
							if(collidingObjs.length) {
								//12 : handle collision
								obj.handleCollision(this, collidingObjs);
								//13 : empty the collisiding objects array
								collidingObjs &#x3D; [];
							}
						}
					}
				}
				// 14 : request next frame
				requestAnimationFrame(onFrame.bind(this));
			};
		}
		getViewer() {
			return this.viewer;
		}
		getGameRect() {
			return this.gameRect;
		}
		setGameRect( rect ) {
			this.gameRect.setRect(rect);
			return this;
		}
	}
	return GameManager;
})();</code></pre>
          </article>
        </div>
      </div>
      <nav id="jsdoc-toc-nav" role="navigation"></nav>
    </div>
  </div>
  <footer id="jsdoc-footer" class="jsdoc-footer">
    <div id="jsdoc-footer-container">
      <p>
        Generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc</a> 3.4.3 on September 2, 2017.
      </p>
    </div>
  </footer>
  <script src="scripts/jquery.min.js"></script>
  <script src="scripts/jquery.cookie.js"></script>
  <script src="scripts/tree.jquery.js"></script>
  <script src="scripts/prettify.js"></script>
  <script src="scripts/jsdoc-toc.js"></script>
  <script src="scripts/linenumber.js"></script>
  <script src="scripts/scrollanchor.js"></script>
</body>

</html>