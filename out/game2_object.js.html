<!doctype html>
<html>

<head>
  <meta name="generator" content="JSDoc 3.4.3">
  <meta charset="utf-8">
  <title>Source: game2/object.js</title>
  <link rel="stylesheet" href="https://brick.a.ssl.fastly.net/Karla:400,400i,700,700i" type="text/css">
  <link rel="stylesheet" href="https://brick.a.ssl.fastly.net/Noto+Serif:400,400i,700,700i" type="text/css">
  <link rel="stylesheet" href="https://brick.a.ssl.fastly.net/Inconsolata:500" type="text/css">
  <link href="css/baseline.css" rel="stylesheet">
</head>

<body onload="prettyPrint()">
  <nav id="jsdoc-navbar" role="navigation" class="jsdoc-navbar">
    <div id="jsdoc-navbar-container">
      <div id="jsdoc-navbar-content">
        <a href="index.html" class="jsdoc-navbar-package-name">Home</a>
      </div>
    </div>
  </nav>
  <div id="jsdoc-body-container">
    <div id="jsdoc-content">
      <div id="jsdoc-content-container">
        <div id="jsdoc-banner" role="banner">
        </div>
        <div id="jsdoc-main" role="main">
          <header class="page-header">
            <h1>Source: game2/object.js</h1>
          </header>
          <article>
            <pre class="prettyprint linenums"><code>/**
 * Created by rfrance on 12/20/2016.
 */
window.game.Object &#x3D; (function() {
	const Vec2 &#x3D; utils.geometry2d.Vec2,
		Rect &#x3D; utils.geometry2d.Rect,
		Circle &#x3D; utils.geometry2d.Circle,
		randomColor &#x3D; utils.tools.randomColor;
	/**
	 * @memberOf game
	 * @class game.Object
	 * @classdesc the base class of all game objects. contains only seven optional attributes : &amp;lt;!--
	 * --&gt;position, speed, accel (for the acceleration), angle, rotationSpeed, collider and renderer, &amp;lt;!--
	 * --&gt;which are not present at the creation, but can be set using setters and direct access. &amp;lt;!--
	 * --&gt;You better should create subclasses of this base class where all needed attributes are created &amp;lt;!--
	 * --&gt;in the constructor.
	 * There are also three attributes that are defined in the prototype because they are generally common &amp;lt;!--
	 * --&gt;to all instances of a class (but you can redefine it  for one object if you want) :
	 * - the {@link game.Object#renderLayer|renderLayer}, used to define the drawing priority in decreasing order &amp;lt;!--
	 * --&gt;(0:max, &amp;lt; 0:not rendered),
	 * - the {@link game.Object#bodyLayer|bodyLayer}, used to define the layer of the object for collision &amp;lt;!--
	 * --&gt;detection. has no impact on other things such as frame or drawing priority.
	 * - the {@link game.Object#collisionLayers|collisionLayers}, used to define the layers this object &amp;lt;!--
	 * --&gt;can collide in.
	 */
	class GameObject {
		/**
		 * @constructor
		 * @param {utils.geometry2d.Vec2} [position&#x3D;null]
		 * @param {utils.geometry2d.Vec2} [speed&#x3D;null]
		 * @param {utils.geometry2d.Vec2} [accel&#x3D;null]
		 */
		constructor(position &#x3D; null, speed &#x3D; null, accel &#x3D; null) {
			if(position) {
				/**
				 * @name game.Object#position
				 * @type {utils.geometry2d.Vec2}
				 */
				this.position &#x3D; position.clone();
				if(speed) {
					/**
					 * @name game.Object#speed
					 * @type {utils.geometry2d.Vec2}
					 */
					this.speed &#x3D; speed.clone();
					if(accel) {
						/**
						 * @name game.Object#accel
						 * @type {utils.geometry2d.Vec2}
						 */
						this.accel &#x3D; accel.clone();
			}   }   }
		}

//______________________________________________________________________________________________________________________
// - - - - - - - - - - - - - - - - - - - - - - - - -transform methods - - - - - - - - - - - - - - - - - - - - - - - - -
//**********************************************************************************************************************
//-------------------------------------------------------position-------------------------------------------------------
		/**
		 * returns the position of the object, or {@link utils.geometry2d.Vec2.ZERO|Vec2.ZERO} &amp;lt;!--
		 * --&gt;if the attribute does not exist.
		 * @returns {Vec2}
		 */
		getPosition() {
			return this.position || Vec2.ZERO;
		}
		/**
		 * returns a copy of the position of the object
		 * @returns {utils.geometry2d.Vec2|Vec2}
		 */
		copyPosition() {
			return this.getPosition().clone();
		}
		/**
		 * sets the position of the object to the specified one if the attribute exists, creates it otherwise
		 * @param {utils.geometry2d.Vec2} pos
		 * @returns {game.Object} &amp;lt;code&gt;this&amp;lt;/code&gt;
		 */
		setPosition(pos) {
			return this.setPositionXY(pos.x, pos.y);
		}
		/**
		 * sets the position of the object to the specified coordinates if the attribute exists, &amp;lt;!--
		 * --&gt;creates it otherwise
		 * @param {number} x
		 * @param {number} y
		 * @returns {game.Object} &amp;lt;code&gt;this&amp;lt;/code&gt;
		 */
		setPositionXY(x, y) {
			if(this.position) this.position.setXY(x, y);
			else this.position &#x3D; new Vec2(x, y);
			return this;
		}

//---------------------------------------------------------speed--------------------------------------------------------
		/**
		 * returns the speed of the object, or {@link utils.geometry2d.Vec2.ZERO|Vec2.ZERO} &amp;lt;!--
		 * --&gt;if the attribute does not exist.
		 * @returns {utils.geometry2d.Vec2}
		 */
		getSpeed() {
			return this.speed || Vec2.ZERO;
		}
		/**
		 * returns a copy of the speed of the object
		 * @returns {utils.geometry2d.Vec2}
		 */
		copySpeed() {
			return this.getSpeed().clone();
		}
		/**
		 * sets the speed of the object to the specified one if the attribute exists, creates it otherwise
		 * @param {utils.geometry2d.Vec2} spd
		 * @returns {game.Object} &amp;lt;code&gt;this&amp;lt;/code&gt;
		 */
		setSpeed(spd) {
			return this.setSpeedXY(spd.x, spd.y);
		}
		/**
		 * sets the speed coordinates of the object to the specified values if the attribute exists, &amp;lt;!--
		 * --&gt;creates it otherwise
		 * @param {number} x
		 * @param {number} y
		 * @returns {game.Object}&amp;lt;code&gt;this&amp;lt;/code&gt;
		 */
		setSpeedXY(x, y) {
			if (this.speed) this.speed.setXY(x, y);
			else this.speed &#x3D; new Vec2(x,y);
			return this;
		}

//-----------------------------------------------------acceleration-----------------------------------------------------
		/**
		 * returns the acceleration of the object, or {@link utils.geometry2d.Vec2.ZERO|Vec2.ZERO} &amp;lt;!--
		 * --&gt;if the attrbute does not exist.
		 * @returns {Vec2|utils.geometry2d.Vec2}
		 */
		getAcceleration() {
			return this.accel || Vec2.ZERO;
		}
		/**
		 * returns a copy of the acceleration of the object.
		 * @returns {utils.geometry2d.Vec2|Vec2}
		 */
		copyAcceleration() {
			return this.getAcceleration().clone();
		}
		/**
		 * sets the acceleration of the object to the specified one if the attribute exists, useless otherwise
		 * @param {utils.geometry2d.Vec2} acc
		 * @returns {game.Object} &amp;lt;code&gt;this&amp;lt;/code&gt;
		 */
		setAcceleration(acc) {
			this.setAccelerationXY(acc.x, acc.y);
			return this;
		}
		/**
		 * sets the acceleration coordinates of the object to the specified values if the attribute exists, &amp;lt;!--
		 * --&gt;useless otherwise
		 * @param {number} x
		 * @param {number} y
		 */
		setAccelerationXY(x, y) {
			if (this.accel) this.accel.setXY(x, y);
			else this.accel &#x3D; new Vec2(x,y);
			return this;
		}

//-------------------------------------------------------rotation-------------------------------------------------------
		/**
		 * returns the rotation speed (in radians per second) of the object if it exists, or 0.
		 * @returns {number}
		 */
		getRotationSpeed() {
			return this.rotationSpeed || 0;
		}
		/**
		 * set the rotation speed of the object to the specified value in radians per seconds.
		 * @param radPerSec
		 */
		setRotationSpeed(radPerSec) {
			this.rotationSpeed &#x3D; radPerSec;
		}
		/**
		 * rotate the object according to the specified angle in radians
		 * @param {number} radians
		 * @returns {game.Object} &amp;lt;code&gt;this&amp;lt;/code&gt;
		 */
		rotate(radians) {
			if (this.renderer) this.renderer.rotate(radians);
			if (this.collider) this.collider.rotate(radians);
			return this;
		}

//-------------------------------------------------high-level transforms------------------------------------------------
		/**
		 * moves the object of the specified translation.
		 * @param {utils.geometry2d.Vec2} delta
		 * @returns {game.Object} &amp;lt;code&gt;this&amp;lt;/code&gt;
		 */
		move(delta) {
			return this.moveXY(delta.x, delta.y);
		}
		/**
		 * moves the object according to the specified translation coordinates
		 * @param {number} x
		 * @param {number} y
		 * @returns {game.Object} &amp;lt;code&gt;this&amp;lt;/code&gt;
		 */
		moveXY(x, y) {
			this.getPosition().addXY(x, y);
			return this;
		}
		/**
		 * increase the object&#x27;s speed according to the parameter
		 * @param deltaSpd
		 * @returns {game.Object} &amp;lt;code&gt;this&amp;lt;/code&gt;
		 */
		accelerate(deltaSpd) {
			return this.accelerateXY(deltaSpd.x, deltaSpd.y);
		}
		/**
		 * increase the object&#x27;s speed according to the parameters
		 * @param {number} x
		 * @param {number} y
		 * @returns {game.Object} &amp;lt;code&gt;this&amp;lt;/code&gt;
		 */
		accelerateXY(x, y) {
			this.getSpeed().addXY(x, y);
			return this;
		}
		/**
		 * change the object size by multiplying it&#x27;s dimensions by the given factor
		 * @param {number} factor
		 * @returns {game.Object} &amp;lt;code&gt;this&amp;lt;/code&gt;
		 */
		scale(factor) {
			if (this.renderer) this.renderer.scale(factor);
			if (this.collider) this.collider.scale(factor);
			return this;
		}

//______________________________________________________________________________________________________________________
// - - - - - - - - - - - - - - - - - - - - - - - -Rect &amp;amp; Radius getters - - - - - - - - - - - - - - - - - - - - - - - -
//**********************************************************************************************************************
		/**
		 * returns the Rect containing the object, ie the collider and the renderer if they exists, &amp;lt;!--
		 * --&gt;and the position point.
		 * @returns {utils.geometry2d.Rect}
		 */
		getRect() {
			return Rect.getUnion([this.getRenderRect(), this.getColliderRect()]);
		}
		/**
		 * returns the Rect containing the object&#x27;s renderer, or at least the position.
		 * @returns {utils.geometry2d.Rect}
		 */
		getRenderRect() {
			return this.renderer ? this.renderer.setPosition(this.getPosition()).getRect()
				: Rect.createFromPoint(this.getPosition());
		}
		/**
		 * returns the Rect containing the object&#x27;s collider, or at least the position.
		 * @returns {utils.geometry2d.Rect}
		 */
		getColliderRect() {
			return this.collider ? this.collider.setPosition(this.getPosition()).getRect()
				: Rect.createFromPoint(this.getPosition());
		}
		/**
		 * returns the radius of the object, ie the maximum between the radius of the collider and the one of the &amp;lt;!--
		 * --&gt;renderer if they exists, or 0.
		 * @returns {number}
		 */
		getRadius() {
			return Math.max(this.getRenderRadius(), this.getColliderRadius());
		}
		/**
		 * returns the radius of the renderer or 0 if it doesn&#x27;t exist.
		 * @returns {number}
		 */
		getRenderRadius() {
			return this.renderer ? this.renderer.getRadius() : 0;
		}
		/**
		 * returns the radius of the collider or 0 if it doesn&#x27;t exist.
		 * @returns {number}
		 */
		getColliderRadius() {
			return this.collider ? this.collider.getRadius() : 0;
		}

//______________________________________________________________________________________________________________________
// - - - - - - - - - - - - - - - - - - - - - - - - - -frame methods - - - - - - - - - - - - - - - - - - - - - - - - - -
//**********************************************************************************************************************
		/**
		 * called once every frame by the game manager
		 * @param {game.GameManager} gameManager
		 * @param {number} dT
		 */
		onFrame(gameManager, dT) {
			this.moveOnFrame(gameManager, dT);
			this.accelerateOnFrame(gameManager, dT);
			this.rotateOnFrame(gameManager, dT);
		}
		/**
		 * called by the {@link game.Object#onFrame|onFrame} method. moves according speed.
		 * @param {game.GameManager} gameManager
		 * @param {number} dT
		 */
		moveOnFrame(gameManager, dT) {
			let spd &#x3D; this.getSpeed();
			if (!spd.isZero()) this.move(spd.clone().mul(dT));
		}
		/**
		 * called by the {@link game.Object#onFrame|onFrame} method. increase speed according acceleration.
		 * @param {game.GameManager} gameManager
		 * @param {number} dT
		 */
		accelerateOnFrame(gameManager, dT) {
			let acc &#x3D; this.getAcceleration();
			if (!acc.isZero()) this.accelerate(acc.clone().mul(dT));
		}
		/**
		 * called by the {@link game.Object#onFrame|onFrame} method. rotate according to rotation speed if exists.
		 * @param {game.GameManager} gameManager
		 * @param {number} dT
		 */
		rotateOnFrame(gameManager, dT) {
			if (this.rotationSpeed) this.rotate(this.rotationSpeed * dT);
		}

//______________________________________________________________________________________________________________________
// - - - - - - - - - - - - - - - - - - - - - - - - -collision methods - - - - - - - - - - - - - - - - - - - - - - - - -
//**********************************************************************************************************************
		/**
		 * sets the &amp;lt;code&gt;collider&amp;lt;/code&gt; attribute of the object.
		 * @param {game.ObjectCollider} collider
		 */
		setCollider( collider ) {
			/**
			 * @name game.Object#collider
			 * @type {game.ObjectCollider}
			 */
			this.collider &#x3D; collider;
		}
		/**
		 * tells if the object is able to collide with the specified object, or if the object can collide &amp;lt;!--
		 * --&gt;with any object if the parameter is null
		 * @param {?game.Object} [object&#x3D;null]
		 * @returns {boolean}
		 */
		canCollide(object &#x3D; null) {
			return this.collider!&#x3D;&#x3D;undefined;
		}
		/**
		 * called at the beginning of the collision part of a frame, after the game manager has called &amp;lt;!--
		 * --&gt;the onFrame method for all objects. This method is only called for objects with a &amp;lt;!--
		 * --&gt;{@link game.Object#bodyLayer|bodyLayer} greater or equal to 0.
		 */
		prepareCollision() {
			this.collider.prepareCollision(this.getPosition());
		}
		/**
		 * returns true if the instances collides with the parameter object. This method is called after &amp;lt;!--
		 * the {@link game.Object#canCollide|canCollide} method and before the onCollision method, for both objects
		 * @param {game.Object} obj
		 * @returns {boolean}
		 */
		collides(obj) {
			return this.collider.collides(obj.collider);
		}

		/**
		 * called by the game manager on the top priority object, with all colliding objects in the game, &amp;lt;!--
		 * --&gt;at the end of the frame. This function has to call on onCollision method for the instance &amp;lt;!--
		 * --&gt;and the objects, unless it has decided that the colliison should not be taken into account.
		 * @param {game.GameManager} gameManager
		 * @param {game.Object[]} objects
		 */
		handleCollision(gameManager, objects) {
			let i&#x3D;objects.length;
			while(i--) {
				this.onCollision(gameManager, objects[i]);
				objects[i].onCollision(gameManager, this);
			}
		}
		/**
		 * called by the object handling collision between the specified object and the instance. &amp;lt;!--
		 * --&gt;This is the function where collision event must be handled
		 * @param {game.GameManager}gameManager
		 * @param {game.Object} object
		 */
		onCollision(gameManager, object) {
		}
		/**
		 * returns true if this object can collide with objects which are in the specified layer.
		 * @param {number} layer
		 * @returns {boolean}
		 */
		isInCollisionLayer(layer) {
			return this.collisionLayers.indexOf(layer) &gt;&#x3D; 0;
		}

//______________________________________________________________________________________________________________________
// - - - - - - - - - - - - - - - - - - - - - - - - - -render methods- - - - - - - - - - - - - - - - - - - - - - - - - -
//**********************************************************************************************************************
		/**
		 * sets the &amp;lt;code&gt;renderer&amp;lt;/code&gt; attribute of the object.
		 * @param {game.ObjectRenderer} renderer
		 */
		setRenderer( renderer ) {
			/**
			 * @name game.Object#renderer
			 * @type {game.ObjectRenderer}
			 */
			this.renderer &#x3D; renderer;
		}
		/**
		 * called by the game map to draw the object on the canvas
		 * @param {CanvasRenderingContext2D}context2d
		 */
		render(context2d) {
			this.renderer &amp;amp;&amp;amp; this.renderer.setPosition(this.getPosition()).render(context2d);
		}
		/**
		 * draws the object on the canvas with the specified color.
		 * @param {webgl.GlHandler} handler
		 * @param {WebGLRenderingContext} handler.gl - webgl context
		 * @param {Float32Array} handler.vertices - a large-enough array to use (avoids creating arrays every time) &amp;lt;!--
		 * --&gt;to store vertices
		 * @param {Uint32Array} handler.colors - a large-enough array to use to store colors
		 * @param {WebGLBuffer} handler.glBuffer - the buffer created with &amp;lt;code&gt;gl.createBuffer()&amp;lt;/code&gt;
		 * @param {string} handler.positionAttrib - the location of the &amp;lt;code&gt;vec2&amp;lt;/code&gt; attribute used for &amp;lt;!--
		 * --&gt;the position of the vertex in the vertex shader
		 * @param {string} handler.colorUniform - the location of the &amp;lt;code&gt;int&amp;lt;/code&gt; uniform used for &amp;lt;!--
		 * --&gt;the color in the vertex shader
		 * @param {string} handler.depthUniform - the location of the &amp;lt;code&gt;float&amp;lt;/code&gt; uniform used for &amp;lt;!--
		 * --&gt;the depth in the vertex shader
		 */
		renderGL(handler) {
			handler.gl.uniform1f(handler.depthUniform, 10-this.renderLayer);
			this.renderer &amp;amp;&amp;amp; this.renderer.setPosition(this.getPosition()).renderGL(contextGL);
		}
		/**
		 * call this function if you want to draw debug informations on the canvas. draws the collider.
		 * @param {CanvasRenderingContext2D}context2d
		 */
		renderDebug(context2d) {
			this.collider &amp;amp;&amp;amp; this.collider.render(context2d);
		}

//______________________________________________________________________________________________________________________
// - - - - - - - - - - - - - - - - - - - - - - - - - -death methods - - - - - - - - - - - - - - - - - - - - - - - - - -
//**********************************************************************************************************************
		/**
		 * kills the object and removes it from the game before the next frame. The &amp;lt;!--
		 * --&gt;{@link game.Object#onDeath|onDeath} method is then called
		 * @param gameManager
		 */
		kill(gameManager) {
			gameManager.removeObject(this);
		}
		/**
		 * called by the game manager the moment the object is removed from the game.
		 * @param gameManager
		 */
		onDeath(gameManager) {
		}

//______________________________________________________________________________________________________________________
// - - - - - - - - - - - - - - - - - - - - - - - - -position checkers - - - - - - - - - - - - - - - - - - - - - - - - -
//**********************************************************************************************************************
		//noinspection JSSuspiciousNameCombination
		/**
		 * returns whether or not the object is outside the specified rectangle.
		 * @param {utils.geometry2d.Rect} rect
		 * @param {number} [marginX&#x3D;0]
		 * @param {number} [marginY&#x3D;marginX]
		 * @returns {boolean}
		 */
		isOutOfRect(rect, marginX &#x3D; 0, marginY &#x3D; marginX) {
			let r &#x3D; this.getRect().addMarginsXY(marginX, marginY);
			return (rect.left &gt; r.right || rect.right &amp;lt; r.left || rect.top &gt; r.bottom || rect.bottom &amp;lt; r.top );
		}

		//noinspection JSSuspiciousNameCombination (for marginX &#x3D; marginY)
		/**
		 * maintains the object inside the specified rectangle. you can call this method inside the &amp;lt;!--
		 * --&gt;{@link game.Object#moveOnFrame|moveOnFrame} method, for example, to make sure the object &amp;lt;!--
		 * --&gt;does not go out of a rectangle.
		 * This function returns the vector used to move the object inside the rectangle.
		 * @param {utils.geometry2d.Rect|Rect} rect
		 * @param {number} marginX
		 * @param {number} marginY
		 * @returns {utils.geometry2d.Vec2}
		 */
		maintainInRect(rect, marginX &#x3D; 0, marginY &#x3D; marginX) {
			rect &#x3D; rect.clone().addMarginsXY(-marginX, -marginY);
			let objRect &#x3D; this.getRect(),
				delta &#x3D; new Vec2(
					rect.left &gt; objRect.left ? rect.left - objRect.left :
						rect.right &amp;lt; objRect.right ? rect.right - objRect.right :
							0,
					rect.top &gt; objRect.top ? rect.top - objRect.top :
						rect.bottom &amp;lt; objRect.bottom ? rect.bottom - objRect.bottom :
							0);
			if (!delta.isZero()) {
				this.moveXY(delta.x, delta.y);
			}
			return delta;
		}
	}
//______________________________________________________________________________________________________________________
// - - - - - - - - - - - - - - - - - - - - - -attributes with default value - - - - - - - - - - - - - - - - - - - - - -
//**********************************************************************************************************************
	/**
	 * the render layer of this object. As it is generally common to all objects of the same class, &amp;lt;!--
	 * --&gt;this attribute is generally defined in the prototype of the class, but you can do it anywhere you want &amp;lt;!--
	 * --&gt;for your objects. The default value is {@link game.RenderLayer.OBJ1};
	 * This attributes is used to define an order for the objects to be drawn on the screen, and must be part of &amp;lt;!--
	 * --&gt;the {@link game.RenderLayer} enumeration, or an other number if you handle it in your own game map.
	 * @name game.Object#renderLayer
	 * @type {game.RenderLayer|number}
	 */
	GameObject.prototype.renderLayer &#x3D; game.RenderLayer.OBJ1;
	/**
	 * the body layer of this object. As it is generally common to all objects of the same class, &amp;lt;!--
	 * --&gt;this attribute is generally defined in the prototype of the class, but you can do it anywhere you want &amp;lt;!--
	 * --&gt;for your objects.
	 * This number defines where the body of the object is located. If an other object want to be able &amp;lt;!--
	 * --&gt;to collide with it, it must have the same number in its {@link game.Object#collisionLayers|collisionLayers} array.
	 * @name game.Object#bodyLayer
	 * @type {number}
	 */
	GameObject.prototype.bodyLayer &#x3D; 0;
	/**
	 * When two objects are colliding, the object with the highest priority will be the one handling collisions.
	 * If set to a negative number, it cannot handle collision, even with lower priotity objects.
	 * @name game.ObjectcollisionPriority
	 * @type {number}
	 */
	GameObject.prototype.collisionPriority &#x3D; 0;
	/**
	 * the collision layers of this object. As it is generally common to all objects of the same class, &amp;lt;!--
	 * --&gt;this attribute is generally defined in the prototype of the class, but you can do it anywhere you want &amp;lt;!--
	 * --&gt;for your objects.
	 * This array defines which objects this object can collide with. To collide with an object, &amp;lt;!--
	 * --&gt;this array must contain its {@link game.Object#bodyLayer|bodyLayer} attribute.
	 * @name game.Object#collisionLayers
	 * @type {number[]}
	 */
	GameObject.prototype.collisionLayers &#x3D; [0];
    return GameObject;
})();</code></pre>
          </article>
        </div>
      </div>
      <nav id="jsdoc-toc-nav" role="navigation"></nav>
    </div>
  </div>
  <footer id="jsdoc-footer" class="jsdoc-footer">
    <div id="jsdoc-footer-container">
      <p>
        Generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc</a> 3.4.3 on May 9, 2017.
      </p>
    </div>
  </footer>
  <script src="scripts/jquery.min.js"></script>
  <script src="scripts/jquery.cookie.js"></script>
  <script src="scripts/tree.jquery.js"></script>
  <script src="scripts/prettify.js"></script>
  <script src="scripts/jsdoc-toc.js"></script>
  <script src="scripts/linenumber.js"></script>
  <script src="scripts/scrollanchor.js"></script>
</body>

</html>