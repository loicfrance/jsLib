<!doctype html>
<html>

<head>
  <meta name="generator" content="JSDoc 3.4.3">
  <meta charset="utf-8">
  <title>Source: game2/renderer_collider.js</title>
  <link rel="stylesheet" href="https://brick.a.ssl.fastly.net/Karla:400,400i,700,700i" type="text/css">
  <link rel="stylesheet" href="https://brick.a.ssl.fastly.net/Noto+Serif:400,400i,700,700i" type="text/css">
  <link rel="stylesheet" href="https://brick.a.ssl.fastly.net/Inconsolata:500" type="text/css">
  <link href="css/baseline.css" rel="stylesheet">
</head>

<body onload="prettyPrint()">
  <nav id="jsdoc-navbar" role="navigation" class="jsdoc-navbar">
    <div id="jsdoc-navbar-container">
      <div id="jsdoc-navbar-content">
        <a href="index.html" class="jsdoc-navbar-package-name">Home</a>
      </div>
    </div>
  </nav>
  <div id="jsdoc-body-container">
    <div id="jsdoc-content">
      <div id="jsdoc-content-container">
        <div id="jsdoc-banner" role="banner">
        </div>
        <div id="jsdoc-main" role="main">
          <header class="page-header">
            <h1>Source: game2/renderer_collider.js</h1>
          </header>
          <article>
            <pre class="prettyprint linenums"><code>/**
 * Created by rfrance on 12/20/2016.
 */
//######################################################################################################################
//#                                                   ObjectRenderer                                                   #
//######################################################################################################################
window.game.ObjectRenderer &#x3D; (function() {
	/**
	 * @class game.ObjectRenderer
	 * @memberOf game
	 * @abstract
	 * @classdesc the base class of object renderers. Renderers are used to handle collision detection of objects.
	 */
    class ObjectRenderer {
		constructor() {
		}
		/**
		 * sets the position of the renderer.
		 * @param {utils.geometry2d.Vec2} pos
		 * @returns {game.ObjectRenderer} &amp;lt;code&gt;this&amp;lt;/code&gt;
		 */
		setPosition(pos) {
			return this;
		}

		/**
		 * rotates the renderer by the specified angle in radians
		 * @param {number} radians
		 */
		rotate(radians) {
		}

		/**
		 * multiplies the dimensions of the renderer by the specified factor
		 * @param factor
		 */
		scale(factor) {
		}

		/**
		 * draw the renderer on the canvas at the specified position if set and not null
		 * @param {CanvasRenderingContext2D} context2d
		 */
		render(context2d) {
		}

		/**
		 * creates and returns a {@link utils.geometry2d.Rect|Rect} that fits the renderer.
		 * @returns {utils.geometry2d.Rect}
		 */
		getRect() {
			return null;
		}
		/**
		 * returns the maximum distance of the center to a point of the renderer.
		 * @returns {number}
		 */
		getRadius() {
			return 0;
		}
    }
    return ObjectRenderer;
})();
//######################################################################################################################
//#                                                ShapedObjectRenderer                                                #
//######################################################################################################################
window.game.ShapedObjectRenderer &#x3D; (function() {
	/**
	 * @class game.ShapedObjectRenderer
	 * @augments game.ObjectRenderer
	 * @memberOf game
	 * @classdesc an implementation of the {@link game.ObjectRenderer|ObjectRenderer} using a &amp;lt;!--
	 * --&gt;{@link utils.geometry2d.Shape} instance and a color for drawings.
	 */
	class ShapedObjectRenderer extends game.ObjectRenderer {
		/**
		 * @constructor
		 * @param {utils.geometry2d.Shape}shape
		 * @param {string} color
		 */
		constructor(shape, color &#x3D; &#x27;#FFF&#x27;) {
			super();
			/**
			 * @name game.ShapedObjectRenderer#shape
			 * @type {utils.geometry2d.Shape}
			 */
			this.shape &#x3D; shape.clone();
			/**
			 * @name game.ShapedObjectRenderer#color
			 * @type {string}
			 */
			this.color &#x3D; color;
		}

		/**
		 * sets the renderer&#x27;s shape center to the specified position
		 * @param {utils.geometry2d.Vec2} pos
		 * @returns {game.ShapedObjectRenderer} &amp;lt;code&gt;this&amp;lt;/code&gt;
		 */
		setPosition(pos) {
			this.shape.setCenter(pos);
			return this;
		}

		/**
		 * rotates the shape of the renderer by the specified angle in radians.
		 * @param {number} radians
		 */
		rotate(radians) {
			this.shape.rotate(radians);
		}

		/**
		 * multiplies the dimensions of the shape by the specified factor.
		 * @param {number} factor
		 */
		scale(factor) {
			this.shape.scale(factor);
		}

		/**
		 * returns the {@link game.ShapedObjectRenderer#color|color} attribute of the renderer.
		 * @returns {string}
		 */
		getColor() {
			return this.color;
		}

		/**
		 * sets the {@link game.ShapedObjectRenderer#color|color} attribute of the renderer to the specified value.
		 * @param {string} color
		 */
		setColor(color) {
			this.color &#x3D; color;
		}

		/**
		 * returns the {@link game.ShapedObjectRenderer#shape|shape} attribute of the renderer.
		 * @returns {utils.geometry2d.Shape}
		 */
		getShape() {
			return this.shape;
		}

		/**
		 * sets the {@link game.ShapedObjectRenderer#shape|shape} attribute of the renderer to a copy of the &amp;lt;!--
		 * --&gt;specified shape.
		 * @param {utils.geometry2d.Shape} shape
		 */
		setShape(shape) {
			this.shape &#x3D; shape.clone();
		}

		/**
		 * draws the shape on the canvas with the specified color.
		 * @param {CanvasRenderingContext2D} context2d
		 */
		render(context2d) {
			if(!(this.color.substr)) {
				let c &#x3D; this.color.toString(16);
				if(c.length &amp;lt; 6) c &#x3D; &#x27;0&#x27;.repeat(6-c.length)+c;
				this.color &#x3D; &#x27;#&#x27;+c;
			}
			this.fill &amp;amp;&amp;amp; (context2d.fillStyle &#x3D; this.color);
			this.stroke &amp;amp;&amp;amp; (context2d.strokeStyle &#x3D; this.color);
			this.shape.draw(context2d, this.fill, this.stroke);
		}
		/**
		 * draws the shape on the canvas with the specified color.
		 * @param {webgl.GlHandler} handler
		 * @param {WebGLRenderingContext} handler.gl - webgl context
		 * @param {Float32Array} handler.vertices - a large-enough array to use (avoids creating arrays every time) &amp;lt;!--
		 * --&gt;to store vertices
		 * @param {WebGLBuffer} handler.glBuffer - the buffer created with &amp;lt;code&gt;gl.createBuffer()&amp;lt;/code&gt;
		 * @param {string} handler.positionAttrib - the location of the &amp;lt;code&gt;vec2&amp;lt;/code&gt; attribute used for &amp;lt;!--
		 * --&gt;the position of the vertex in the vertex shader
		 * @param {string} handler.colorUniform - the location of the &amp;lt;code&gt;int&amp;lt;/code&gt; uniform used for &amp;lt;!--
		 * --&gt;the color in the vertex shader
		 * @param {string} handler.depthUniform - the location of the &amp;lt;code&gt;float&amp;lt;/code&gt; uniform used for &amp;lt;!--
		 * --&gt;the depth in the vertex shader
		 */
		renderGL(handler) {
			if(this.color.substr) {
				let c &#x3D; 0;
				switch(this.color.length) {
					case 4: c &#x3D; 0xFF;
					case 5: c +&#x3D; parseInt(this.color.substr(1,1),16)*17 &amp;lt;&amp;lt; 24
						+ parseInt(this.color.substr(2,1),16)*17 &amp;lt;&amp;lt; 16
						+ parseInt(this.color.substr(3,1),16)*17 &amp;lt;&amp;lt; 8
						+ parseInt(this.color.substr(4,1),16)*17;
						break;
					case 7: c &#x3D; 0xFF;
					case 9: c +&#x3D; parseInt(this.color.substr(1,1),16) &amp;lt;&amp;lt; 24
						+ parseInt(this.color.substr(3,1),16) &amp;lt;&amp;lt; 16
						+ parseInt(this.color.substr(5,1),16) &amp;lt;&amp;lt; 8
						+ parseInt(this.color.substr(7,1),16);
						break;
					default: console.stack(this.color + &#x27; is not a valid color&#x27;);
				}
			}
			handler.gl.uniform1i(handler.colorUniform, this.color);
			handler.gl.bindBuffer(handler.glBuffer);
			let points &#x3D; this.shape.glSetVertices(handler.vertices);
			handler.gl.bufferData(handler.glBuffer, handler.vertices, handler.gl.STATIC_DRAW);
			gl.vertexAttribPointer(handler.positionAttrib, 2, gl.FLOAT, false, 0, 0);
			gl.drawArrays(this.stroke ? gl.LINE_LOOP : gl.TRIANGLE_FAN, 0, points );
		}
		/**
		 * returns a {@link utils.geometry2d.Rect|Rect} instance fitting the &amp;lt;!--
		 * --&gt;{@link game.ShapedObjectRenderer#shape|shape} attribute of the renderer.
		 * @returns {utils.geometry2d.Rect}
		 */
		getRect() {
			return this.shape.getRect();
		}

		/**
		 * returns the maximum distance of the center to a point of the renderer.
		 * @returns {number}
		 */
		getRadius() {
			return this.shape.getRadius();
		}
	}
	/**
	 * whether or not the renderer should fill the shape. as it is common to all instances of the class, &amp;lt;!--
	 * --&gt;this attribute is generally defined in the prototype of the class, but you can do it anywhere you want &amp;lt;!--
	 * --&gt;for your renderers.
	 * @name game.ShapedObjectRenderer#fill
	 * @type {boolean}
	 */
	ShapedObjectRenderer.prototype.fill &#x3D; true;
	/**
	 * whether or not the renderer should stroke the shape. as it is common to all instances of the class, &amp;lt;!--
	 * --&gt;this attribute is generally defined in the prototype of the class, but you can do it anywhere you want &amp;lt;!--
	 * --&gt;for your renderers.
	 * @name game.ShapedObjectRenderer#stroke
	 * @type {boolean}
	 */
	ShapedObjectRenderer.prototype.stroke &#x3D; false;
	return ShapedObjectRenderer;
})();
//######################################################################################################################
//#                                                ImageObjectRenderer                                                 #
//######################################################################################################################
window.game.ImageObjectRenderer &#x3D; (function() {
	const Rect &#x3D; utils.geometry2d.Rect;
	/**
	 * @class game.ImageObjectRenderer
	 * @augments game.ObjectRenderer
	 * @memberOf game
	 * @classdesc an implementation of the {@link game.ObjectRenderer|ObjectRenderer} using an image instance and &amp;lt;!--
	 * --&gt;transform informations for drawing
	 */
	class ImageObjectRenderer extends game.ObjectRenderer {
		/**
		 * @constructor
		 * @param {utils.geometry2d.Shape}shape
		 * @param {string} color
		 */
		constructor(image, clipRect&#x3D; new Rect(0,0, image.width, image.height)) {
			super();
			/**
			 * @name game.ShapedObjectRenderer#shape
			 * @type {utils.geometry2d.Shape}
			 */
			this.image &#x3D; image;
			this.position &#x3D; utils.geometry2d.Vec2.zero;
			this.clipRect &#x3D; clipRect;
		}

		/**
		 * sets the renderer&#x27;s shape center to the specified position
		 * @param {utils.geometry2d.Vec2} pos
		 * @returns {game.ShapedObjectRenderer} &amp;lt;code&gt;this&amp;lt;/code&gt;
		 */
		setPosition(pos) {
			this.position.set(pos);
			return this;
		}

		/**
		 * rotates the shape of the renderer by the specified angle in radians.
		 * @param {number} radians
		 */
		rotate(radians) {
			this.angle +&#x3D; radians;
		}

		/**
		 * multiplies the dimensions of the shape by the specified factor.
		 * @param {number} factor
		 */
		scale(factor) {
			this.scaleX *&#x3D; factor;
			this.scaleY *&#x3D; factor;
		}

		/**
		 * returns the {@link game.ImageObjectRenderer#image|image} attribute of the renderer.
		 * @returns {Image}
		 */
		getImage() {
			return this.image;
		}

		/**
		 * sets the {@link game.ImageObjectRenderer#image|image} attribute of the renderer to the &amp;lt;!--
		 * --&gt;specified image.
		 * @param {Image} image
		 */
		setImage(image) {
			this.image &#x3D; image;
		}
		setImageClipRect(clipRect) {
			this.clipRect.setRect(clipRect);
		}

		/**
		 * draws on the canvas
		 * @param {CanvasRenderingContext2D} context2d
		 */
		render(context2d) {
			if(!this.image.complete) return;
			const w &#x3D; this.clipRect.width, h &#x3D; this.clipRect.height, ws &#x3D; w * this.scaleX, hs &#x3D; h * this.scaleY;
			if(this.angle) {
				context2d.translate(this.position.x, this.position.y);
				context2d.rotate(this.angle);
				context2d.drawImage(this.image,
					this.clipRect.left, this.clipRect.top, w, h,
					-ws*0.5, -hs*0.5, ws, hs);
				context2d.rotate(-this.angle);
				context2d.translate(-this.position.x, -this.position.y);
			} else context2d.drawImage(this.image,
					this.clipRect.left, this.clipRect.top, w, h,
					this.position.x - ws*0.5, this.position.y - hs*0.5,
					ws, hs);
		}
		/**
		 * draws on the canvas.
		 * @param {webgl.GlHandler} handler
		 * @param {WebGLRenderingContext} handler.gl - webgl context
		 * @param {Float32Array} handler.vertices - a large-enough array to use (avoids creating arrays every time) &amp;lt;!--
		 * --&gt;to store vertices
		 * @param {WebGLBuffer} handler.glBuffer - the buffer created with &amp;lt;code&gt;gl.createBuffer()&amp;lt;/code&gt;
		 * @param {string} handler.positionAttrib - the location of the &amp;lt;code&gt;vec2&amp;lt;/code&gt; attribute used for &amp;lt;!--
		 * --&gt;the position of the vertex in the vertex shader
		 * @param {string} handler.colorUniform - the location of the &amp;lt;code&gt;int&amp;lt;/code&gt; uniform used for &amp;lt;!--
		 * --&gt;the color in the vertex shader
		 * @param {string} handler.depthUniform - the location of the &amp;lt;code&gt;float&amp;lt;/code&gt; uniform used for &amp;lt;!--
		 * --&gt;the depth in the vertex shader
		 */
		renderGL(handler) {
		}
		/**
		 * returns a {@link utils.geometry2d.Rect|Rect} instance fitting the &amp;lt;!--
		 * --&gt;{@link game.ImageObjectRenderer#image|image} attribute of the renderer.
		 * @returns {utils.geometry2d.Rect}
		 */
		getRect() {
			return Rect.createFromCenterWidthHeight(this.position,
				this.clipRect.width*this.scaleX, this.clipRect.height*this.scaleY);
		}

		/**
		 * returns the maximum distance of the center to a point of the renderer.
		 * @returns {number}
		 */
		getRadius() {
			const r &#x3D; this.getRect();
			return Math.max(r.width, r.height);
		}
	}
	utils.tools.merge(ImageObjectRenderer.prototype, {
		angle: 0, scaleX: 1, scaleY: 1
	});
	return ImageObjectRenderer;
})();
//######################################################################################################################
//#                                            MultiRenderersObjectRenderer                                            #
//######################################################################################################################
window.game.MultiRenderersObjectRenderer &#x3D; (function(){
	&quot;use strict&quot;;/**
	 * @class game.MultiRenderersObjectRenderer
	 * @augments game.ObjectRenderer
	 * @memberOf game
	 * @classdesc an implementation of the {@link game.ObjectRenderer|ObjectRenderer} using several instances of &amp;lt;!--
	 * --&gt;{@link game.ObjectRenderer}.
	 */
	class MultiRenderersObjectRenderer extends game.ObjectRenderer {
		/**
		 * @constructor
		 * @param {game.ObjectRenderer[]} renderers
		 */
		constructor(renderers) {
			super();
			this.renderers &#x3D; renderers;
			this.renderersNumber &#x3D; renderers.length;
			this.position &#x3D; utils.geometry2d.Vec2.zero;
		}
		/**
		 * sets the renderer&#x27;s shape center to the specified position
		 * @param {utils.geometry2d.Vec2} pos
		 * @returns {game.ShapedObjectRenderer} &amp;lt;code&gt;this&amp;lt;/code&gt;
		 */
		setPosition(pos) {
			this.position.set(pos);
			let i &#x3D; this.renderersNumber;
			while(i--) {
				this.renderers[i].setPosition(pos);
			}
			return this;
		}
		updateRenderersNumber() {
			this.renderersNumber &#x3D; this.renderers.length;
		}
		/**
		 * rotates the shape of the renderer by the specified angle in radians.
		 * @param {number} radians
		 */
		rotate(radians) {
			let i &#x3D; this.renderersNumber;
			while(i--) {
				this.renderers[i].rotate(radians);
			}
		}
		/**
		 * multiplies the dimensions by the specified factor.
		 * @param {number} factor
		 */
		scale(factor) {
			let i &#x3D; this.renderersNumber;
			while(i--) {
				this.renderers[i].scale(factor);
			}
		}
		/**
		 * draws on the canvas
		 * @param {CanvasRenderingContext2D} context2d
		 */
		render(context2d) {
			let i &#x3D; -1, n &#x3D; this.renderersNumber;
			while(++i &amp;lt; n) {
				this.renderers[i].render(context2d);
			}
		}
		/**
		 * draws on the canvas.
		 * @param {webgl.GlHandler} handler
		 * @param {WebGLRenderingContext} handler.gl - webgl context
		 * @param {Float32Array} handler.vertices - a large-enough array to use (avoids creating arrays every time) &amp;lt;!--
		 * --&gt;to store vertices
		 * @param {WebGLBuffer} handler.glBuffer - the buffer created with &amp;lt;code&gt;gl.createBuffer()&amp;lt;/code&gt;
		 * @param {string} handler.positionAttrib - the location of the &amp;lt;code&gt;vec2&amp;lt;/code&gt; attribute used for &amp;lt;!--
		 * --&gt;the position of the vertex in the vertex shader
		 * @param {string} handler.colorUniform - the location of the &amp;lt;code&gt;int&amp;lt;/code&gt; uniform used for &amp;lt;!--
		 * --&gt;the color in the vertex shader
		 * @param {string} handler.depthUniform - the location of the &amp;lt;code&gt;float&amp;lt;/code&gt; uniform used for &amp;lt;!--
		 * --&gt;the depth in the vertex shader
		 */
		renderGL(handler) {
			let i &#x3D; -1, n &#x3D; this.renderersNumber;
			while(++i &amp;lt; n) {
				this.renderers[i].renderGL(handler);
			}
		}
		/**
		 * creates and returns a {@link utils.geometry2d.Rect|Rect} that fits the renderer.
		 * @returns {utils.geometry2d.Rect}
		 */
		getRect() {
			if(this.renderersNumber &#x3D;&#x3D; 0)
				return utils.geometry2d.Rect.createFromPoint(this.position);
			let rects &#x3D; new Array(this.renderersNumber), i &#x3D; this.renderersNumber;
			while(i--) {
				rects[i] &#x3D; this.renderers[i].getRect();
			}
			return utils.geometry2d.Rect.getUnion(rects);
		}
		/**
		 * returns the maximum distance of the center to a point of the renderer.
		 * @returns {number}
		 */
		getRadius() {
			if(this.renderersNumber &#x3D;&#x3D; 0) return 0;
			let max &#x3D; 0, i &#x3D; this.renderersNumber, r;
			while(i--) {
				r &#x3D; this.renderers[i].getRadius();
				if(r &gt; max) max &#x3D; r;
			}
			return max;
		}
	}
	return MultiRenderersObjectRenderer;
})();
//######################################################################################################################
//#                                                   ObjectCollider                                                   #
//######################################################################################################################
window.game.ObjectCollider &#x3D; (function() {
	/**
	 * @class game.ObjectCollider
	 * @memberOf game
	 * @abstract
	 * @classdesc the base class of object colliders. Colliders are used to handle collision detection of objects.
	 */
	class ObjectCollider {
		/**
		 * @constructor
		 * @param {utils.geometry2d.Rect} rect
		 */
		constructor(rect) {
			/**
			 * @name game.ObjectCollider#rect
			 * @type {utils.geometry2d.Rect}
			 */
			this.rect &#x3D; rect.clone();
		}
		/**
		 * sets the collider position to the specified one
		 * @param {utils.geometry2d.Vec2} pos
		 * @returns {game.ObjectCollider} &amp;lt;code&gt;this&amp;lt;/code&gt;
		 */
		setPosition(pos) {
			this.rect.setCenter(pos); return this;
		}
		/**
		 * rotates the collider with the specified angle in radians.
		 * Automatically called when the {@link game.Object#rotate|rotate} method of the associated object is called.
		 * @param {number} radians
		 */
		rotate(radians) {
		}
		/**
		 * scales the collider with the specified factor.
		 * Automatically called when the {@link game.Object#scale|scale} method of the associated object is called.
		 * @param {number} factor
		 */
		scale(factor) {
		}
		/**
		 * returns the radius of the collider, i.e the maximum distance from the center to any point of the collider.
		 * @returns {number}
		 */
		getRadius() {
			return 0;
		}
		/**
		 * returns the {@link game.ObjectCollider#rect} attribute of the collider
		 * @returns {utils.geometry2d.Rect}
		 */
		getRect() {
			return this.rect;
		}
		/**
		 * returns whether or not this collider can be considered as colliding with the specified collider
		 * is it is inside. Otherwise, the colliders will need to intersect for the &amp;lt;!--
		 * --&gt;{@link game.ObjectCollider#collides|collides} method to return true.
		 * @param {game.ObjectCollider} collider
		 * @returns {boolean}
		 */
		collidesInside(collider) {
			return false;
		}
		/**
		 * prepare the collision detection by acquiring necessary variables, such as the the &amp;lt;!--
		 * --&gt;{@link game.ObjectCollider#rect|rect} attribute.
		 * @param {utils.geometry2d.Vec2} position
		 */
		prepareCollision(position) {
			this.setPosition(position);
		}
		/**
		 * tells the collider that the collision detection is over for this object on this frame.
		 */
		finishCollision() {
		}

		/**
		 * handle the collision with all colliding objects
		 * @param gameManager
		 * @param objects
		 */
		handleCollision(gameManager, objects) {
			let i &#x3D; 0, n &#x3D; objects.length;
			while(i &amp;lt; n &amp;amp;&amp;amp; !this.collides(objects[i++]));
		}
		/**
		 * returns true if the two colliders are colliding.
		 * @param {game.ObjectCollider} collider
		 * @returns {boolean}
		 */
		collides(collider) {
			return false;
		}
		/**
		 * draw the collider on the canvas for debug purpose.
		 * @param context2d
		 */
		render(context2d) {
			this.rect.draw(context2d);
		}
	}

	/**
	 * whether or not the object will collide. As this won&#x27;t change during the life of most objects, it is defined &amp;lt;!--
	 * --&gt;in the prototype. But if you change it for some objects, it  is preferable to define it in the &amp;lt;!--
	 * --&gt;constructor of the object-specific collider.
	 * @name game.ObjectCollider#activated
	 * @type {boolean}
	 */
	ObjectCollider.prototype.activated &#x3D; true;
	return ObjectCollider;
})();
//######################################################################################################################
//#                                                    AABBCollider                                                    #
//######################################################################################################################
window.game.AABBObjectCollider &#x3D; (function() {
	&quot;use strict&quot;;
	/**
	 * @class game.AABBObjectCollider
	 * @augments game.ObjectCollider
	 * @memberOf game
	 * @classdesc an implementation of the {@link game.ObjectCollider|ObjectCollider} using a &amp;lt;!--
	 * --&gt;an axis-aligned bounding box for collision detection.
	 */
	class AABBObjectCollider extends game.ObjectCollider {
		/**
		 * @constructor
		 * @param {utils.geometry2d.Shape} shape
		 */
		constructor(shape) {
			super(shape.getRect());
			/**
			 * @name game.ShapedObjectCollider#shape}
			 * @type {utils.geometry2d.shapes}
			 */
			this.shape &#x3D; shape.clone();
		}

		/**
		 * sets the position of the collider.
		 * @param {utils.geometry2d.Vec2} pos
		 * @returns {game.ShapedObjectCollider} &amp;lt;code&gt;this&amp;lt;/code&gt;
		 */
		setPosition(pos) {
			this.shape.setCenter(pos); return super.setPosition(pos);
		}

		/**
		 * rotates the {@link game.ShapedObjectCollider#shape}.
		 * @param {number} radians
		 */
		rotate(radians) {
			this.shape.rotate(radians);
		}

		/**
		 * scales the {@link game.ShapedObjectCollider#shape}.
		 * @param {number} factor
		 */
		scale(factor) {
			this.shape.scale(factor);
		}

		/**
		 * returns the {@link game.ShapedObjectCollider#shape}.
		 * @returns {utils.geometry2d.Shape}
		 */
		getShape() {
			return this.shape;
		}

		/**
		 * sets the {@link game.ShapedObjectCollider#shape} to a copy of the argument.
		 * @param {utils.geometry2d.Shape} shape
		 */
		setShape(shape) {
			this.shape &#x3D; shape.clone();
		}

		/**
		 * returns true if the two colliders are colliding.
		 * @param {game.ObjectCollider} collider
		 * @returns {boolean}
		 */
		collides(collider) {
			if(collider instanceof AABBObjectCollider)
				return collider.rect.overlap(this.rect) &amp;amp;&amp;amp;
					(this.collidesInside(collider) || !collider.rect.containsRect(this.rect)) &amp;amp;&amp;amp;
					(collider.collidesInside(this) || !this.rect.containsRect(collider.rect));
			else return collider.collides(this);
		}

		/**
		 * returns the {@link game.ObjectCollider#rect|rect} attribute of the collider.
		 * @returns {utils.geometry2d.Rect}
		 */
		getRect() {
			return this.rect;
		}

		/**
		 * returns the radius of the collider, i.e the maximum distance from the center to any point of the collider.
		 * @returns {number}
		 */
		getRadius() {
			return Math.sqrt(this.rect.width*this.rect.width + this.rect.height*this.rect.height)*0.5;
		}
	}
	return AABBObjectCollider;
})();
//######################################################################################################################
//#                                                ShapedObjectCollider                                                #
//######################################################################################################################
window.game.ShapedObjectCollider &#x3D; (function() {
	/**
	 * @class game.ShapedObjectCollider
	 * @augments game.ObjectCollider
	 * @memberOf game
	 * @classdesc an implementation of the {@link game.ObjectCollider|ObjectCollider} using a &amp;lt;!--
	 * --&gt;{@link utils.geometry2d.Shape} instance for collision detection.
	 */
	class ShapedObjectCollider extends game.ObjectCollider {
		/**
		 * @constructor
		 * @param {utils.geometry2d.Shape} shape
		 */
		constructor(shape) {
			super(shape.getRect());
			/**
			 * @name game.ShapedObjectCollider#shape}
			 * @type {utils.geometry2d.shapes}
			 */
			this.shape &#x3D; shape.clone();
		}

		/**
		 * sets the position of the collider.
		 * @param {utils.geometry2d.Vec2} pos
		 * @returns {game.ShapedObjectCollider} &amp;lt;code&gt;this&amp;lt;/code&gt;
		 */
		setPosition(pos) {
			this.shape.setCenter(pos); return super.setPosition(pos);
		}

		/**
		 * rotates the {@link game.ShapedObjectCollider#shape}.
		 * @param {number} radians
		 */
		rotate(radians) {
			this.shape.rotate(radians);
		}

		/**
		 * scales the {@link game.ShapedObjectCollider#shape}.
		 * @param {number} factor
		 */
		scale(factor) {
			this.shape.scale(factor);
		}

		/**
		 * returns the {@link game.ShapedObjectCollider#shape}.
		 * @returns {utils.geometry2d.Shape}
		 */
		getShape() {
			return this.shape;
		}

		/**
		 * sets the {@link game.ShapedObjectCollider#shape} to a copy of the argument.
		 * @param {utils.geometry2d.Shape} shape
		 */
		setShape(shape) {
			this.shape &#x3D; shape.clone();
		}

		/**
		 * returns true if the two colliders are colliding.
		 * @param {game.ObjectCollider} collider
		 * @returns {boolean}
		 */
		collides(collider) {
			if(collider instanceof game.AABBObjectCollider) {
				if(collider.rect.overlap(this.rect)) {
					let shape &#x3D; collider.rect.getShape();
					return (this.collidesInside(collider) &amp;amp;&amp;amp; shape.contains(this.shape.center)) ||
						(collides.collidesInside(this) &amp;amp;&amp;amp; this.shape.contains(shape.center)) ||
						this.shape.intersect(shape);
				}
			} else if(collider instanceof ShapedObjectCollider) {
				return collider.shape &amp;amp;&amp;amp; collider.rect.overlap(this.rect) &amp;amp;&amp;amp;
					(this.collidesInside(collider) &amp;amp;&amp;amp; collider.shape.contains(this.shape.center)) ||
					(collider.collidesInside(this) &amp;amp;&amp;amp; this.shape.contains(collider.shape.center)) ||
					this.shape.intersect(collider.shape);
			} else return collider.collides(this);
		}

		/**
		 * returns the {@link game.ObjectCollider#rect|rect} attribute of the collider after setting the &amp;lt;!--
		 * --&gt;{@link game.ObjectCollider#rect|rect} to the return value of the &amp;lt;!--
		 * --&gt;{@link game.ShapedObjectCollider#shape|shape}&#x27;s {@link utils.geometry2d.Shape#getRect|getRect} method.
		 * @returns {utils.geometry2d.Rect}
		 */
		getRect() {
			return this.rect.setRect(this.shape.getRect());
		}

		/**
		 * returns the radius of the collider, i.e the maximum distance from the center to any point of the collider.
		 * @returns {number}
		 */
		getRadius() {
			return this.shape.getRadius();
		}

		/**
		 * draws the rect and the shape on the canvas.
		 * @param {CanvasRenderingContext2D} context2d
		 */
		render(context2d) {
			super.render(context2d);
			this.shape.draw(context2d);
		}

	}
	return ShapedObjectCollider;
})();</code></pre>
          </article>
        </div>
      </div>
      <nav id="jsdoc-toc-nav" role="navigation"></nav>
    </div>
  </div>
  <footer id="jsdoc-footer" class="jsdoc-footer">
    <div id="jsdoc-footer-container">
      <p>
        Generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc</a> 3.4.3 on September 2, 2017.
      </p>
    </div>
  </footer>
  <script src="scripts/jquery.min.js"></script>
  <script src="scripts/jquery.cookie.js"></script>
  <script src="scripts/tree.jquery.js"></script>
  <script src="scripts/prettify.js"></script>
  <script src="scripts/jsdoc-toc.js"></script>
  <script src="scripts/linenumber.js"></script>
  <script src="scripts/scrollanchor.js"></script>
</body>

</html>